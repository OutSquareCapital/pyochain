{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pyochain \u26d3\ufe0f","text":"<p>Functional-style method chaining for Python data structures.</p> <p>Welcome to the <code>pyochain</code> documentation! This library brings a fluent, declarative API inspired by Rust and DataFrame libraries to your Python iterables and dictionaries.</p>"},{"location":"#documentation-navigation","title":"Documentation Navigation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Examples &amp; Cookbook \u2014 Practical use cases and data manipulation patterns</li> <li>Core Types Overview \u2014 Comprehensive guide to all pyochain types</li> </ul>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#collections","title":"Collections","text":"<ul> <li>Iter[T] \u2014 Lazy processing of iterators</li> <li>Seq[T] \u2014 Immutable collections (tuple-backed)</li> <li>Set[T] \u2014 Immutable collections (frozenset-backed)</li> <li>SetMut[T] \u2014 Mutable Set (set-backed)</li> <li>Vec[T] \u2014 Mutable collections (list-backed)</li> <li>Dict[K, V] \u2014 Chainable dictionaries</li> </ul>"},{"location":"#error-handling-optionals","title":"Error Handling &amp; Optionals","text":"<ul> <li>Result[T, E] \u2014 Explicit error handling (<code>Ok</code> / <code>Err</code>)</li> <li>Option[T] \u2014 Optional values (<code>Some</code> / <code>NONE</code>)</li> </ul> <p>Each reference page includes detailed examples and complete type signatures.</p>"},{"location":"#useful-links","title":"Useful Links","text":"<ul> <li>GitHub Repository</li> <li>Contributing Guide</li> <li>Examples</li> <li>PyPI Package</li> </ul>"},{"location":"core-types-overview/","title":"Core Types Overview","text":"<p>The following tables summarizes the main types provided by pyochain, along with their characteristics and Python equivalents.</p>"},{"location":"core-types-overview/#collections-iterators","title":"Collections &amp; Iterators","text":"<p>All collection types can be created from any object implementing the <code>Iterable</code> protocol (think anything you can use in a <code>for</code> loop). Since they implement collections Protocols, they can act as drop-in replacements for their Python counterparts/underlying types.</p> Type Underlying Structure Implement Ordered Uniqueness Mutability <code>Iter[T]</code> <code>Iterator[T]</code> <code>Iterator</code> N/A N/A N/A <code>Seq[T]</code> <code>tuple[T]</code> <code>Sequence</code> Yes No No <code>Vec[T]</code> <code>list[T]</code> <code>MutableSequence</code> Yes No Yes <code>Set[T]</code> <code>frozenset[T]</code> <code>Set</code> No Yes No <code>SetMut[T]</code> <code>set[T]</code> <code>MutableSet</code> No Yes Yes <code>Dict[K,V]</code> <code>dict[K, V]</code> <code>MutableMapping</code> Yes Keys Yes"},{"location":"core-types-overview/#option-result-types","title":"Option &amp; Result Types","text":"<p>Due to type inference limitations in Python, small functions with explicit <code>Result[T, E]</code> or <code>Option[T]</code> return types are the recommended way to create those types. Note that <code>Option</code> is easier to infer from context than <code>Result</code>, and can henceforth be created with simple lambdas most of the time.</p> Type Description Creation Python Equivalent <code>Option[T]</code> Optional value container (abstract) <code>Option.from_(value)</code> or if/else statements <code>T \\| None</code> <code>Some[T]</code> Represents a present value <code>Some(value)</code> with if/else or <code>Option.from_(value)</code> <code>T</code> <code>NONE</code> Represents absence of value <code>NONE</code> (singleton) with if/else or <code>Option.from_(None)</code> <code>None</code> <code>Result[T, E]</code> Success or failure container (abstract) In functions with try/except pattern <code>T \\| E</code> <code>Ok[T]</code> Represents a successful result <code>Ok(value)</code> in try block or success path <code>T</code> <code>Err[E]</code> Represents a failed result <code>Err(error)</code> in except block or error path <code>Exception</code>"},{"location":"core-types-overview/#graphical-overview","title":"Graphical Overview","text":"<p>Below is a graphical representation of the core classes and their relationships.</p> <pre><code>---\nconfig:\n  look: neo\n  layout: elk\n  theme: neo-dark\n---\nflowchart BT\n subgraph Collections[\"\ud83d\udce6 Collections\"]\n    direction TB\n        Seq[\"Seq[T]tuple\"]\n        Vec[\"Vec[T]list\"]\n        Set[\"Set[T]frozenset\"]\n        SetMut[\"SetMut[T]set\"]\n        Dict[\"Dict[K,V]dict\"]\n  end\n subgraph OptionGroup[\"\ud83c\udf81 Option Types\"]\n    direction TB\n        Option[\"Option[T](abstract)\"]\n        Some[\"Some[T](has value)\"]\n        NONE[\"NONE(no value)\"]\n  end\n subgraph ResultGroup[\"\u2705 Result Types\"]\n    direction TB\n        Result[\"Result[T,E](abstract)\"]\n        Ok[\"Ok[T](success)\"]\n        Err[\"Err[E](error)\"]\n  end\n    Option -.-&gt; Some &amp; NONE\n    Result -.-&gt; Ok &amp; Err\n    Collections --&gt; IterMethod[\"\u26d3\ufe0f.iter()\"] &amp; Into[\"\ud83d\udd04.into(func/type)\"]\n    OptionGroup --&gt; IterMethod &amp; OkOrMethod[\"\u2705.ok_or(err)\"] &amp; Into\n    ResultGroup --&gt; IterMethod &amp; OkMethod[\"\ud83c\udf81.ok()\"] &amp; Into\n    IterMethod --&gt; Iter[\"Iter[T]lazy iterator\"]\n    Iter --&gt; CollectMethod[\"\ud83d\udce6.collect(func/type)\"] &amp; Into\n    CollectMethod --&gt; Collections\n    OkOrMethod --&gt; ResultGroup\n    OkMethod --&gt; OptionGroup\n    Into --&gt; AnyType[\"\ud83d\udd04 Any Type\"]\n\n    IterMethod@{ shape: rounded}\n    Into@{ shape: rounded}\n    OkOrMethod@{ shape: rounded}\n    OkMethod@{ shape: rounded}\n    CollectMethod@{ shape: rounded}\n     Seq:::collectionsStyle\n     Vec:::collectionsStyle\n     Set:::collectionsStyle\n     SetMut:::collectionsStyle\n     Dict:::collectionsStyle\n     Option:::optionStyle\n     Some:::optionStyle\n     NONE:::optionStyle\n     Result:::resultStyle\n     Ok:::resultStyle\n     Err:::resultStyle\n     IterMethod:::iterMethodStyle\n     Into:::intoStyle\n     OkOrMethod:::okOrMethodStyle\n     OkMethod:::okMethodStyle\n     Iter:::iterStyle\n     CollectMethod:::collectMethodStyle\n     AnyType:::anyStyle\n    classDef collectionsStyle fill:#e3f2fd,stroke:#1976d2,stroke-width:3px,color:#000\n    classDef iterMethodStyle fill:#c8e6c9,stroke:#2e7d32,stroke-width:3px,color:#000\n    classDef iterStyle fill:#e8f5e9,stroke:#388e3c,stroke-width:3px,color:#000\n    classDef collectMethodStyle fill:#b3e5fc,stroke:#0277bd,stroke-width:3px,color:#000\n    classDef okOrMethodStyle fill:#ffccbc,stroke:#d84315,stroke-width:3px,color:#000\n    classDef okMethodStyle fill:#fff59d,stroke:#f9a825,stroke-width:3px,color:#000\n    classDef optionStyle fill:#fff9c4,stroke:#f57f17,stroke-width:3px,color:#000\n    classDef resultStyle fill:#ffebee,stroke:#c62828,stroke-width:3px,color:#000\n    classDef intoStyle fill:#e1bee7,stroke:#7b1fa2,stroke-width:3px,color:#000\n    classDef anyStyle fill:#f5f5f5,stroke:#616161,stroke-width:2px,stroke-dasharray:5,color:#000\n    style IterMethod fill:#FFD600,stroke:#FF6D00\n    style Into stroke:#FF6D00,fill:#FFD600\n    style OkOrMethod fill:#FFD600,stroke:#FF6D00\n    style OkMethod fill:#FFD600,stroke:#FF6D00\n    style CollectMethod fill:#FFD600,stroke:#FF6D00\n    style AnyType stroke-width:1px,stroke-dasharray: 0\n</code></pre>"},{"location":"core-types-overview/#shared-features-and-interoperability","title":"Shared Features and interoperability","text":"<p>All provided classes share the following core methods for enhanced usability:</p>"},{"location":"core-types-overview/#inspect","title":"<code>.inspect()</code>","text":"<p>Insert functions who compute side-effects in the chain without breaking it (print, mutation of an external variable, logging...). If Option or Result, call the function only if <code>Some</code> or <code>Ok</code>.</p>"},{"location":"core-types-overview/#into-collect","title":"<code>.into()</code> &amp; <code>.collect()</code>","text":"<p>Take a <code>Callable[[Self, P], T]</code> as argument to convert from Self to T in a chained way.</p> <p>E.g <code>Seq[T].into()</code> can take any function/object that expect a <code>Sequence[T]</code> as argument, and return it's result <code>R</code>. Conceptually, replace<code>f(x, args, kwargs)</code> with <code>x.into(f, args, kwargs)</code>.</p> <p><code>Iter.collect()</code> is a specific case of <code>into()</code>, with constraint on the return type being one of the collection types (but the implementation is the same), and <code>Seq</code> as a default argument value. Using <code>collect()</code> for <code>Iter</code> rather than <code>into()</code> is considered the idiomatic way to materialize data from an iterator in pyochain.</p>"},{"location":"core-types-overview/#filter_map-dictiter_values-resultok-optionok_or-etc","title":"<code>.filter_map()</code>, <code>Dict.iter_values()</code>, <code>Result.ok()</code>, <code>Option.ok_or()</code>, etc","text":"<p>Various methods across the different classes return, accept, handle or produce other pyochain types, enabling seamless interoperability and chaining between them.</p>"},{"location":"examples/","title":"Cookbook","text":"<p>This cookbook provides practical examples of how to use the <code>pyochain</code> library for various data manipulation tasks in Python. Each example demonstrates a specific use case, showcasing the power and flexibility of <code>pyochain</code> for functional programming and data processing.</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":""},{"location":"examples/#chained-data-transformations","title":"Chained Data Transformations","text":"<pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; result = (\n...    pc.Iter.from_count(1)  # Infinite iterator: 1, 2, 3, ...\n...    .filter(lambda x: x % 2 != 0)  # Keep odd numbers\n...    .map(lambda x: x * x)  # Square them\n...    .take(5)  # Take the first 5\n...    .collect()  # Materialize the result into a Seq\n... )\n&gt;&gt;&gt; result\nSeq(1, 9, 25, 49, 81)\n</code></pre>"},{"location":"examples/#type-safe-error-handling-result-and-option","title":"Type-Safe Error Handling (<code>Result</code> and <code>Option</code>)","text":"<p>Write robust code by handling potential failures explicitly.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; def divide(a: int, b: int) -&gt; pc.Result[float, str]:\n...     if b == 0:\n...         return pc.Err(\"Cannot divide by zero\")\n...     return pc.Ok(a / b)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # --- With Result ---\n&gt;&gt;&gt; res1 = divide(10, 2)\n&gt;&gt;&gt; res1\nOk(5.0)\n&gt;&gt;&gt; res2 = divide(10, 0)\n&gt;&gt;&gt; res2\nErr('Cannot divide by zero')\n&gt;&gt;&gt; # Safely unwrap or provide a default\n&gt;&gt;&gt; res2.unwrap_or(0.0)\n0.0\n&gt;&gt;&gt; # Map over a successful result\n&gt;&gt;&gt; res1.map(lambda x: x * x)\nOk(25.0)\n&gt;&gt;&gt; # --- With Option ---\n&gt;&gt;&gt; def find_user(user_id: int) -&gt; pc.Option[str]:\n...     users = {1: \"Alice\", 2: \"Bob\"}\n...     return pc.Some(users.get(user_id)) if user_id in users else pc.NONE\n&gt;&gt;&gt;\n&gt;&gt;&gt; find_user(1).map(str.upper).unwrap_or(\"Not Found\")\n'ALICE'\n&gt;&gt;&gt; find_user(3).unwrap_or(\"Not Found\")\n'Not Found'\n</code></pre>"},{"location":"examples/#combining-them-in-data-pipelines","title":"Combining them in Data Pipelines","text":"<p>Classes have been designed to work seamlessly together, enabling complex data processing pipelines with clear error handling.</p> <pre><code>from pathlib import Path\n\nimport polars as pl\n\nimport pyochain as pc\n\n\ndef safe_parse_int(s: str) -&gt; pc.Result[int, str]:\n    try:\n        return pc.Ok(int(s))\n    except ValueError:\n        return pc.Err(f\"Invalid integer: {s}\")\n\n\ndef _write_to_file(lf: pl.LazyFrame, file_path: Path) -&gt; pc.Result[None, str]:\n    \"\"\"Write the LazyFrame to a CSV file.\"\"\"\n    try:\n        return pc.Ok(lf.filter(pl.col(\"value\") &gt; 15).sink_parquet(file_path))\n    except (OSError, pl.exceptions.ComputeError) as e:\n        return pc.Err(f\"Failed to write to file: {e}\")\n\n\n&gt;&gt;&gt; PATH = Path(\"parsed_integers.parquet\")\n&gt;&gt;&gt; data = [\"10\", \"20\", \"foo\", \"30\", \"bar\"]\n&gt;&gt;&gt; results = (\n...    pc.Iter(data)\n...    .map(safe_parse_int)  # Parse each string safely\n...    .filter_map(lambda r: r.ok())  # Keep only successful parses\n...    .enumerate()  # Add indices\n...    .collect()  # Materialize the results\n...    .inspect(\n...        lambda seq: print(f\"Parsed integers: {seq}\") # Log parsed integers\n...    )\n...    .into(pl.LazyFrame, schema=[\"index\", \"value\"])  # Pass to Polars LazyFrame\n...    .pipe(_write_to_file, PATH)  # Write to file\n...    .map_err(lambda e: print(f\"Error: {e}\"))  # Print error message\n)\n</code></pre>"},{"location":"examples/#concrete-use-cases","title":"Concrete Use Cases","text":"<p>Below are some more specific examples demonstrating how to use <code>pyochain</code> for specific tasks encountered in real-world scenarios.</p>"},{"location":"examples/#finding-the-earliest-compatible-dependency-versions","title":"Finding the Earliest Compatible Dependency Versions","text":"<p>Problem: Multiple folders in a src tree may have their own <code>requirements.txt</code> files specifying dependencies with version constraints. e.g:</p> <pre><code>--- src/my_project/module_a/requirements.txt\n  numpy&gt;=1.20.0\n  pandas==1.3.0\n--- src/my_project/module_b/requirements.txt\n  numpy&gt;=1.18.0\n    pandas&gt;=1.2.0\netc...\n</code></pre> <p>Goal: To find all the files paths, and then their earliest compatible versions for each dependency across all files.</p> <p>Solution:</p> <pre><code>from enum import StrEnum, auto\nfrom pathlib import Path\n\nimport pyochain as pc\n\nPROJECT = \"my_project\"\nSRC = Path(\"src\").joinpath(PROJECT)\n\n\nclass Splitter(StrEnum):\n    EQ = \"==\"\n    GT = \"&gt;=\"\n    LT = \"&lt;=\"\n    UNSPECIFIED = auto()\n\n\ndef _split_version(line: str, pos: int) -&gt; str:\n    def _split_with(splitter: Splitter) -&gt; str:\n        return line.split(splitter)[pos]\n\n    return (\n        _split_with(Splitter.EQ)\n        if Splitter.EQ in line\n        else _split_with(Splitter.GT)\n        if Splitter.GT in line\n        else _split_with(Splitter.LT)\n        if Splitter.LT in line\n        else Splitter.UNSPECIFIED\n    )\n\n\ndef find_paths() -&gt; pc.Seq[Path]:\n    \"\"\"Find all requirements.txt files in the src/project directory.\"\"\"\n    return pc.Iter(SRC.rglob(\"*requirements.txt\")).collect()\n\n\ndef main() -&gt; pc.Dict[str, str]:\n    return (\n        pc.Iter(SRC.rglob(\"*requirements.txt\"))\n        .map(lambda p: p.read_text().splitlines())\n        .flatten()\n        .group_by(lambda line: _split_version(line, 0))\n        .map(\n            lambda lines: (\n                lines.key,\n                lines.values.map(lambda line: _split_version(line, 1).strip())\n                .sort()\n                .first(),\n            )\n        )\n        .collect(pc.Dict)\n    )\n\n\nif __name__ == \"__main__\":\n    find_paths()\n    main()\n</code></pre>"},{"location":"examples/#determining-all-public-methods-of-a-class","title":"Determining All Public Methods of a Class","text":"<p>Below is an example of using pyochain to get all the public methods of the <code>pc.Iter</code> class, both with pyochain and with pure python.</p> <pre><code>from typing import Any\n\nimport pyochain as pc\n\n\ndef get_all_iter_methods() -&gt; dict[int, str]:\n    return (\n        pc.Iter(pc.Iter.mro())\n        .flat_map(lambda x: x.__dict__.values())\n        .filter(lambda f: callable(f) and not f.__name__.startswith(\"_\"))\n        .map(lambda f: f.__name__)\n        .sort()\n        .iter()\n        .enumerate()\n        .collect(dict)\n    )\n\n\ndef get_all_iter_methods_pure_python() -&gt; dict[int, str]:\n    dict_values: list[Any] = []\n    for cls in pc.Iter.mro():\n        dict_values.extend(cls.__dict__.values())\n\n    return dict(\n        enumerate(\n            sorted(\n                [\n                    obj.__name__\n                    for obj in dict_values\n                    if callable(obj) and not obj.__name__.startswith(\"_\")\n                ],\n            ),\n        ),\n    )\n\n\nif __name__ == \"__main__\":\n    methods = get_all_iter_methods()\n    methods_pure = get_all_iter_methods_pure_python()\n    assert methods == methods_pure\n</code></pre>"},{"location":"examples/#checking-whether-functions-are-implemented-in-python-or-rust","title":"Checking whether functions are implemented in Python or Rust","text":"<p>In this example, I want to check which functions of the Iter class or Rust Iterator class are not implemented in both languages.</p> <p>It demonstrate how to combine pyochain with polars in uninterrupted data pipelines, who combines lazy Iterators, LazyFrames, and streaming mode writing.</p> <pre><code>from typing import Literal\n\nimport polars as pl\n\nimport pyochain as pc\n\n\ndef _with_source(fn_name: str, src: Literal[\"python\", \"rust\"]) -&gt; tuple[str, str]:\n    return (src, fn_name)\n\n\nRUST_FN = [\n    ...\n]  # list of rust Iterator trait methods names as strings, copy pasted from website\n\n\ndef main() -&gt; None:\n    fn: pl.Expr = pl.col(\"fn\")\n    return (\n        # create an iterator over the class hierarchy\n        pc.Iter(pc.Iter.mro())\n        # get the dict values view of each class and flatten them\n        .flat_map(lambda x: x.__dict__.values())\n        # keep only callables (methods of the classes here)\n        .filter(callable)\n        # get the method name, associate it with \"python\"\n        .map(lambda x: _with_source(x.__name__, \"python\"))\n        # do the same for rust functions, simply associating it with \"rust\"\n        .chain(pc.Iter(RUST_FN).map(lambda x: _with_source(x, \"rust\")))\n        # pass the iterator directly into a polars lazyframe, with specified schema (otherwise columns are named column_0, column_1)\n        .into(lambda x: pl.LazyFrame(x, schema=[\"source\", \"fn\"]))\n        # keep only unique fn names, and those not starting with _ (dunder/private methods)\n        .filter(fn.is_unique().and_(fn.str.starts_with(\"_\").not_()))\n        .sort(fn)  # sort by fn name\n        # write the result to an ndjson file in streaming mode.\n        .sink_ndjson(\"iter_fn_sources.ndjson\")\n    )\n</code></pre>"},{"location":"reference/dict/","title":"Dict","text":"<p>::: pyochain.dict.Dict     options:       inherited_members: true       show_overloads: true       members_order: alphabetical       filters:         - \"!^\"</p>"},{"location":"reference/err/","title":"Err","text":"<p>::: pyochain.result.Err     options:       inherited_members: true       show_overloads: true       members_order: alphabetical       filters:         - \"!^\"</p>"},{"location":"reference/iter/","title":"Iter","text":"<p>::: pyochain.iter.Iter     options:       inherited_members: true       show_overloads: true       members_order: alphabetical       filters:         - \"!^\"</p>"},{"location":"reference/none/","title":"None","text":"<p>::: pyochain._option.NoneOption</p> <pre><code>options:\n  inherited_members: true\n  show_overloads: true\n  members_order: alphabetical\n  filters:\n    - \"!^_\"\n</code></pre>"},{"location":"reference/ok/","title":"Ok","text":"<p>::: pyochain._result.Ok</p> <pre><code>options:\n  inherited_members: true\n  show_overloads: true\n  members_order: alphabetical\n  filters:\n    - \"!^_\"\n</code></pre>"},{"location":"reference/option/","title":"Option","text":"<p>::: pyochain._option.Option</p> <pre><code>options:\n  inherited_members: true\n  show_overloads: true\n  members_order: alphabetical\n  filters:\n    - \"!^_\"\n</code></pre>"},{"location":"reference/result/","title":"Result","text":"<p>::: pyochain.result.Result     options:       inherited_members: true       show_overloads: true       members_order: alphabetical       filters:         - \"!^\"</p>"},{"location":"reference/seq/","title":"Seq","text":"<p>::: pyochain.iter.Seq     options:       inherited_members: true       show_overloads: true       members_order: alphabetical       filters:         - \"!^\"</p>"},{"location":"reference/set/","title":"Set","text":"<p>::: pyochain.iter.Set     options:       inherited_members: true       show_overloads: true       members_order: alphabetical       filters:         - \"!^\"</p>"},{"location":"reference/setmut/","title":"SetMut","text":"<p>::: pyochain.iter.SetMut     options:       inherited_members: true       show_overloads: true       members_order: alphabetical       filters:         - \"!^\"</p>"},{"location":"reference/some/","title":"Some","text":"<p>::: pyochain._option.Some</p> <pre><code>options:\n  inherited_members: true\n  show_overloads: true\n  members_order: alphabetical\n  filters:\n    - \"!^_\"\n</code></pre>"},{"location":"reference/vec/","title":"Vec","text":"<p>::: pyochain._iter.Vec</p> <pre><code>options:\n  inherited_members: true\n  show_overloads: true\n  members_order: alphabetical\n  filters:\n    - \"!^_\"\n</code></pre>"}]}