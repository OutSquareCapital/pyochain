{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"pyochain ‚õìÔ∏è","text":"<p>Functional-style method chaining for Python data structures.</p> <p>Welcome to the <code>pyochain</code> documentation! This library brings a fluent, declarative API inspired by Rust and DataFrame libraries to your Python iterables and dictionaries.</p> <ul> <li>Getting Started ‚Äî installation + quick start + next steps</li> <li>API Reference ‚Äî complete public API docs</li> <li>GitHub Repository</li> <li>Contributing Guide</li> <li>PyPI Package</li> </ul>","path":["pyochain ‚õìÔ∏è"],"tags":[]},{"location":"api-reference/","level":1,"title":"API Reference","text":"<p>This page is the entry point to the complete public API documentation.</p>","path":["API Reference"],"tags":[]},{"location":"api-reference/#collections","level":2,"title":"Collections","text":"<ul> <li><code>Iter[T]</code> ‚Äî Lazy processing of iterators</li> <li><code>Seq[T]</code> ‚Äî Immutable collections (tuple-backed)</li> <li><code>Vec[T]</code> ‚Äî Mutable collections (list-backed)</li> <li><code>Set[T]</code> ‚Äî Immutable collections (frozenset-backed)</li> <li><code>SetMut[T]</code> ‚Äî Mutable sets (set-backed)</li> <li><code>Dict[K, V]</code> ‚Äî Chainable dictionaries</li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#error-handling","level":2,"title":"Error handling","text":"<ul> <li><code>Result[T, E]</code> ‚Äî Explicit error handling (<code>Ok</code> / <code>Err</code>)</li> <li><code>Ok</code></li> <li><code>Err</code></li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#optional-values","level":2,"title":"Optional values","text":"<ul> <li><code>Option[T]</code> ‚Äî Optional values (<code>Some</code> / <code>NONE</code>)</li> <li><code>Some</code></li> <li><code>None</code></li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#traits-mixins","level":2,"title":"Traits &amp; mixins","text":"<ul> <li><code>Pipeable</code> ‚Äî <code>.into()</code>, <code>.inspect()</code></li> <li><code>Checkable</code> ‚Äî <code>.then()</code>, <code>.ok_or()</code>, ...</li> </ul>","path":["API Reference"],"tags":[]},{"location":"core-types-overview/","level":1,"title":"Core Types Overview","text":"<p>The following tables summarizes the main types provided by pyochain, along with their characteristics and Python equivalents.</p>","path":["Getting Started","Core Types Overview"],"tags":[]},{"location":"core-types-overview/#collections-iterators","level":2,"title":"Collections &amp; Iterators","text":"<p>All collection types can be created from any object implementing the <code>Iterable</code> protocol (think anything you can use in a <code>for</code> loop). Since they implement collections Protocols, they can act as drop-in replacements for their Python counterparts/underlying types.</p> Type Underlying Structure Implement Ordered Uniqueness Mutability <code>Iter[T]</code> <code>Iterator[T]</code> <code>Iterator</code> N/A N/A N/A <code>Seq[T]</code> <code>tuple[T]</code> <code>Sequence</code> Yes No No <code>Vec[T]</code> <code>list[T]</code> <code>MutableSequence</code> Yes No Yes <code>Set[T]</code> <code>frozenset[T]</code> <code>Set</code> No Yes No <code>SetMut[T]</code> <code>set[T]</code> <code>MutableSet</code> No Yes Yes <code>Dict[K,V]</code> <code>dict[K, V]</code> <code>MutableMapping</code> Yes Keys Yes","path":["Getting Started","Core Types Overview"],"tags":[]},{"location":"core-types-overview/#option-result-types","level":2,"title":"Option &amp; Result Types","text":"<p>Due to type inference limitations in Python, small functions with explicit <code>Result[T, E]</code> or <code>Option[T]</code> return types are the recommended way to create those types. Note that <code>Option</code> is easier to infer from context than <code>Result</code>, and can henceforth be created with simple lambdas most of the time.</p> Type Description Creation Python Equivalent <code>Option[T]</code> Optional value container (abstract) <code>Option(value)</code> - auto-dispatches to <code>Some</code> or <code>NONE</code> <code>T \\| None</code> <code>Some[T]</code> Represents a present value <code>Some(value)</code> or via <code>Option(value)</code> when value is not <code>None</code> <code>T</code> <code>NONE</code> Represents absence of value <code>NONE</code> (singleton) or via <code>Option(None)</code> <code>None</code> <code>Result[T, E]</code> Success or failure container (abstract) In functions with try/except pattern <code>T \\| E</code> <code>Ok[T]</code> Represents a successful result <code>Ok(value)</code> in try block or success path <code>T</code> <code>Err[E]</code> Represents a failed result <code>Err(error)</code> in except block or error path <code>Exception</code>","path":["Getting Started","Core Types Overview"],"tags":[]},{"location":"core-types-overview/#graphical-overview","level":2,"title":"Graphical Overview","text":"<p>Below is a diagram showing the inheritance structure and trait implementation of shared types.</p> <pre><code>---\nconfig:\n  layout: elk\n---\nflowchart TB\n subgraph Collections[\"üì¶ Collections Hierarchy\"]\n        BaseIter[\"BaseIter&lt;br&gt;(internal)\"]\n        Iter[\"Iter[T]&lt;br&gt;lazy iterator\"]\n        Seq[\"Seq[T]&lt;br&gt;immutable sequence\"]\n        Vec[\"Vec[T]&lt;br&gt;mutable sequence\"]\n        Set[\"Set[T]&lt;br&gt;immutable uniqueness\"]\n        SetMut[\"SetMut[T]&lt;br&gt;mutable uniqueness\"]\n  end\n subgraph ErrorHandling[\"‚ùå Error Handling Hierarchy\"]\n        Result[\"Result[T, E]&lt;br&gt;(abstract)\"]\n        Ok[\"Ok[T]&lt;br&gt;success\"]\n        Err[\"Err[E]&lt;br&gt;error\"]\n  end\n subgraph Optional[\"üéÅ Optional Values Hierarchy\"]\n        Option[\"Option[T]&lt;br&gt;(abstract)\"]\n        Some[\"Some[T]&lt;br&gt;some value\"]\n        NONE[\"NONE&lt;br&gt;no value\"]\n  end\n    BaseIter --&gt; Iter &amp; Seq &amp; Set\n    Seq --&gt; Vec\n    Set --&gt; SetMut\n    Result --&gt; Ok &amp; Err\n    Option --&gt; Some &amp; NONE\n    Pipeable[\"üîÑ Pipeable&lt;br&gt;(mixin)\"] --&gt; BaseIter &amp; Dict[\"Dict[K,V]&lt;br&gt;mutable mapping\"] &amp; Result &amp; Option\n    Checkable[\"‚úÖ Checkable&lt;br&gt;(mixin)\"] --&gt; BaseIter &amp; Dict</code></pre>","path":["Getting Started","Core Types Overview"],"tags":[]},{"location":"examples/","level":1,"title":"Cookbook","text":"<p>This cookbook provides practical examples of how to use the <code>pyochain</code> library for various data manipulation tasks in Python. Each example demonstrates a specific use case, showcasing the power and flexibility of <code>pyochain</code> for functional programming and data processing.</p>","path":["Getting Started","Cookbook"],"tags":[]},{"location":"examples/#combining-option-result-and-iterators-in-data-pipelines","level":2,"title":"Combining Option, Result and Iterators in Data Pipelines","text":"<p>Classes have been designed to work seamlessly together, enabling complex data processing pipelines with clear error handling.</p> <p>Note: We return pc.Ok(None) for simplicity.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; def safe_parse_int(s: str) -&gt; pc.Result[int, str]:\n...     try:\n...         return pc.Ok(int(s))\n...     except ValueError:\n...         return pc.Err(f\"Invalid integer: {s}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; def _run_ok(lf: pl.LazyFrame) -&gt; pc.Result[pl.LazyFrame, str]:\n...     \"\"\"Collect and run the pipeline.\"\"\"\n...     try:\n...         return pc.Ok(lf.filter(pl.col(\"value\").gt(15)))\n...     except (pl.exceptions.ComputeError) as e:\n...         return pc.Err(f\"Failed to write to file: {e}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = [\"10\", \"20\", \"foo\", \"30\", \"bar\"]\n&gt;&gt;&gt; results = (\n...    pc.Iter(data)\n...    .map(safe_parse_int)  # Parse each string safely\n...    .filter_map(lambda r: r.ok())  # Keep only successful parses\n...    .enumerate()  # Add indices\n...    .collect()  # Materialize the results\n...    .inspect(\n...        lambda seq: print(f\"Parsed integers: {seq}\") # Log parsed integers\n...    )\n...    .into(pl.LazyFrame, schema=[\"index\", \"value\"])  # Pass to Polars LazyFrame\n...    .pipe(_run_ok)  # Run the pipeline\n...    .map_err(lambda e: print(f\"Error: {e}\"))  # Print error message\n...    .map(lambda _: None)\n... )\nParsed integers: Seq((0, 10), (1, 20), (2, 30))\n&gt;&gt;&gt; results\nOk(None)\n</code></pre>","path":["Getting Started","Cookbook"],"tags":[]},{"location":"examples/#determining-all-public-methods-of-a-class","level":3,"title":"Determining All Public Methods of a Class","text":"<p>Below is an example of using pyochain to:</p> <p>1. extract all public methods of a class. 2. enumerate them 3. sort them by name 4. convert the first three into a dictionary.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; \n&gt;&gt;&gt; def get_public_methods(cls: type) -&gt; dict[int, str]:\n...     return (\n...         pc.Iter(cls.mro())\n...         .flat_map(lambda x: x.__dict__.values())\n...         .filter(lambda f: callable(f) and not f.__name__.startswith(\"_\"))\n...         .map(lambda f: f.__name__)\n...         .enumerate()\n...         .sort(key=lambda pair: pair.value)\n...         .iter()\n...         .take(3)\n...         .collect(dict)\n...     )\n&gt;&gt;&gt;\n&gt;&gt;&gt; get_public_methods(pc.Iter)\n{24: 'accumulate', 66: 'adjacent', 94: 'all'}\n</code></pre> <p>For comparison, here's the equivalent using pure Python:</p> <pre><code>&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; def get_public_methods_pure(cls: type) -&gt; dict[int, str]:\n...     return dict(\n...         itertools.islice(\n...             sorted(\n...                 enumerate(\n...                     f.__name__\n...                     for f in itertools.chain.from_iterable(\n...                         map(lambda x: x.__dict__.values(), cls.mro())\n...                     )\n...                     if callable(f) and not f.__name__.startswith(\"_\")\n...                 ),\n...                 key=lambda pair: pair[1],\n...             ),\n...             3,\n...         )\n...     )\n&gt;&gt;&gt;\n&gt;&gt;&gt; get_public_methods_pure(pc.Iter)\n{24: 'accumulate', 66: 'adjacent', 94: 'all'}\n</code></pre>","path":["Getting Started","Cookbook"],"tags":[]},{"location":"getting-started/","level":1,"title":"Getting Started","text":"","path":["Getting Started"],"tags":[]},{"location":"getting-started/#installation","level":2,"title":"Installation","text":"<pre><code>uv add pyochain\n</code></pre>","path":["Getting Started"],"tags":[]},{"location":"getting-started/#quick-start","level":2,"title":"Quick start","text":"<pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; res: pc.Seq[int] = (\n...     pc.Iter.from_count(1)\n...     .filter(lambda x: x % 2 != 0)\n...     .map(lambda x: x**2)\n...     .take(5)\n...     .collect()\n... )\n&gt;&gt;&gt; res\nSeq(1, 9, 25, 49, 81)\n</code></pre>","path":["Getting Started"],"tags":[]},{"location":"getting-started/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Core Types Overview: choose between the various provided types</li> <li>Interoperability: convert between types with various methods</li> <li>Examples &amp; Cookbook: practical patterns and concrete examples</li> </ul>","path":["Getting Started"],"tags":[]},{"location":"interoperability/","level":1,"title":"Interoperability &amp; Chaining Guide","text":"<p>Pyochain is designed for fluent API usage. Most types can be converted into others seamlessly, allowing you to chain operations without breaking the flow.</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#shared-features","level":2,"title":"Shared Features","text":"<p>To enable this flexibility, Pyochain provides two core traits (mixins) that extend all types with powerful chaining and conditional logic capabilities.</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#pipeable-trait","level":3,"title":"Pipeable trait","text":"<p>All pyochain types implement <code>Pipeable</code>, providing universal methods to continue a chain:</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#intofunc-args-kwargs-r","level":4,"title":"<code>.into(func, *args, **kwargs) -&gt; R</code>","text":"<p>Convert <code>Self</code> to any type <code>R</code> via a function, maintaining fluent chaining.</p> <p>Conceptually, this replaces <code>f(x, args, kwargs)</code> with <code>x.into(f, args, kwargs)</code>.</p> <p>This is particularly useful when you need to pass the result to a function you don't control (like a library function), or to convert to a type not native to Pyochain.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import json\n&gt;&gt;&gt; # Flow is broken, nested function calls, read from middle -&gt; right -&gt; left -&gt; right\n&gt;&gt;&gt; json.dumps(dict(pc.Dict({\"id\": 1, \"name\": \"Alice\"}).map_keys(str.upper)))\n'{\"ID\": 1, \"NAME\": \"Alice\"}'\n&gt;&gt;&gt; # Fluent chaining with .into(), read left -&gt; right\n&gt;&gt;&gt; pc.Dict({\"id\": 1, \"name\": \"Alice\"}).map_keys(str.upper).into(lambda d: json.dumps(dict(d)))\n'{\"ID\": 1, \"NAME\": \"Alice\"}'\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#inspectfunc-args-kwargs-self","level":4,"title":"<code>.inspect(func, *args, **kwargs) -&gt; Self</code>","text":"<p>Pass <code>Self</code> to a function for side effects (logging, debugging, metrics) without breaking the chain. The instance is returned unchanged.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).inspect(print).iter().map(lambda x: x * 2).collect()\nSeq(1, 2, 3)\nSeq(2, 4, 6)\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#checkable-trait","level":3,"title":"Checkable trait","text":"<p>Collections (<code>Seq</code>, <code>Vec</code>, <code>Set</code>, <code>SetMut</code>, <code>Dict</code>) and iterators (<code>Iter</code>) implement <code>Checkable</code>, providing conditional chaining based on truthiness (usually emptiness):</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#thenfunc-args-kwargs-optionr","level":4,"title":"<code>.then(func, *args, **kwargs) -&gt; Option[R]</code>","text":"<p>Call func and wrap result in <code>Some</code> only if the instance is truthy.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#then_some-optionself","level":4,"title":"<code>.then_some() -&gt; Option[Self]</code>","text":"<p>Wrap the instance in <code>Some</code> if truthy, otherwise <code>NONE</code>.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#ok_orerr-resultself-e","level":4,"title":"<code>.ok_or(err) -&gt; Result[Self, E]</code>","text":"<p>Wrap in <code>Ok</code> if truthy, otherwise wrap the error in <code>Err</code>.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty list\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty list\")\nErr('empty list')\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#ok_or_elsefunc-args-kwargs-resultself-e","level":4,"title":"<code>.ok_or_else(func, *args, **kwargs) -&gt; Result[Self, E]</code>","text":"<p>Wrap in <code>Ok</code> if truthy, otherwise call func and wrap result in <code>Err</code> (lazy evaluation).</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda _: \"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda _: \"empty\")\nErr('empty')\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#conversion-interoperability-map","level":2,"title":"Conversion &amp; Interoperability Map","text":"<p>The following graph illustrates all the built-in ways to convert between types in Pyochain.</p> <ul> <li>Types are grouped by category.</li> <li>Arrows color and direction represent conversion paths.</li> <li>Arrow labels represent methods.</li> </ul> <pre><code>---\nconfig:\n  layout: elk\n---\nflowchart TB\n subgraph Collections[\"üì¶ Collections (Eager)\"]\n    direction LR\n        Seq[\"&lt;b&gt;Seq[T]&lt;/b&gt;&lt;br&gt;immutable&lt;br&gt;tuple\"]\n        Vec[\"&lt;b&gt;Vec[T]&lt;/b&gt;&lt;br&gt;mutable&lt;br&gt;list\"]\n        Set[\"&lt;b&gt;Set[T]&lt;/b&gt;&lt;br&gt;immutable&lt;br&gt;frozenset\"]\n        SetMut[\"&lt;b&gt;SetMut[T]&lt;/b&gt;&lt;br&gt;mutable&lt;br&gt;set\"]\n  end\n subgraph Lazy[\"‚õìÔ∏è Lazy\"]\n    direction LR\n        Iter[\"&lt;b&gt;Iter[T]&lt;/b&gt;&lt;br&gt;lazy iterator&lt;br&gt;Iterator\"]\n  end\n subgraph DictGroup[\"üîë Dictionary\"]\n    direction LR\n        Dict[\"&lt;b&gt;Dict[K,V]&lt;/b&gt;&lt;br&gt;mutable&lt;br&gt;dict\"]\n  end\n subgraph OptionGroup[\"üéÅ Option Types\"]\n    direction LR\n        Option[\"&lt;b&gt;Option[T]&lt;/b&gt;\"]\n        Some[\"&lt;b&gt;Some[T]&lt;/b&gt;\"]\n        NONE[\"&lt;b&gt;NONE&lt;/b&gt;\"]\n  end\n subgraph ResultGroup[\"‚úÖ Result Types\"]\n    direction LR\n        Result[\"&lt;b&gt;Result[T,E]&lt;/b&gt;\"]\n        Ok[\"&lt;b&gt;Ok[T]&lt;/b&gt;\"]\n        Err[\"&lt;b&gt;Err[E]&lt;/b&gt;\"]\n  end\n subgraph External[\"üåê External Types\"]\n    direction LR\n        AnyType[\"&lt;b&gt;Any Type&lt;/b&gt;&lt;br&gt;via .into(func)\"]\n  end\n    Option -.-&gt; Some &amp; NONE\n    Result -.-&gt; Ok &amp; Err\n    Collections -- \".iter()\" --&gt; Lazy\n    Lazy -- \".collect()\" --&gt; Collections\n    Lazy -- \".collect(Dict)\" --&gt; DictGroup\n    DictGroup -- \".iter() ‚Üí Item[K,V]&lt;br&gt;.keys_iter() ‚Üí K&lt;br&gt;.values_iter() ‚Üí V\" --&gt; Lazy\n    OptionGroup -- \".iter()\" --&gt; Lazy\n    ResultGroup -- \".iter()\" --&gt; Lazy\n    DictGroup -- \".get_item(key)&lt;br&gt;.insert(key, val)&lt;br&gt;.remove(key)\" --&gt; OptionGroup\n    DictGroup -- \".try_insert(key, val)\" --&gt; ResultGroup\n    Collections -- \".then(func)&lt;br&gt;.then_some()\" --&gt; OptionGroup\n    Lazy -- \".then(func)&lt;br&gt;.then_some()\" --&gt; OptionGroup\n    DictGroup -- \".then(func)&lt;br&gt;.then_some()\" --&gt; OptionGroup\n    Collections -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    Lazy -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    DictGroup -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    OptionGroup -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    ResultGroup -- \".ok()&lt;br&gt;.err()\" --&gt; OptionGroup\n    OptionGroup L_OptionGroup_ResultGroup_2@&lt;-- \".transpose()\" --&gt; ResultGroup\n    Collections -- \".into(func)\" --&gt; External\n    Lazy -- \".into(func)\" --&gt; External\n    DictGroup -- \".into(func)\" --&gt; External\n    OptionGroup -- \".into(func)\" --&gt; External\n    ResultGroup -- \".into(func)\" --&gt; External\n\n     Seq:::collectionsStyle\n     Vec:::collectionsStyle\n     Set:::collectionsStyle\n     SetMut:::collectionsStyle\n     Iter:::iterStyle\n     Dict:::dictStyle\n     Option:::optionStyle\n     Some:::optionStyle\n     NONE:::optionStyle\n     Result:::resultStyle\n     Ok:::resultStyle\n     Err:::resultStyle\n     AnyType:::externalStyle\n     Collections:::collectionsStyle\n     OptionGroup:::optionStyle\n     ResultGroup:::resultStyle\n    classDef collectionsStyle fill:#1e88e5,stroke:#0d47a1,stroke-width:2px,color:#fff\n    classDef iterStyle fill:#43a047,stroke:#1b5e20,stroke-width:2px,color:#fff\n    classDef dictStyle fill:#fb8c00,stroke:#e65100,stroke-width:2px,color:#fff\n    classDef optionStyle fill:#fdd835,stroke:#f57f17,stroke-width:2px,color:#000\n    classDef resultStyle fill:#e53935,stroke:#b71c1c,stroke-width:2px,color:#fff\n    classDef externalStyle fill:#9e9e9e,stroke:#424242,stroke-width:2px,color:#fff\n    style Seq color:none\n    style Vec color:none\n    style Set color:none\n    style SetMut color:none\n    style Dict fill:#FF6D00,color:none,stroke:#FF6D00\n    style Option color:#FFFFFF,fill:transparent,stroke:#FFD600\n    style Some color:#FFFFFF,fill:transparent,stroke:#FFD600\n    style NONE color:#FFFFFF,fill:transparent,stroke:#FFD600\n    style Result fill:#D50000\n    style Ok fill:#D50000\n    style Err fill:#D50000\n    style Collections fill:#000000,color:none,stroke:#2962FF\n    style Lazy fill:#000000,stroke:#00C853\n    style DictGroup fill:#000000,color:none,stroke:#FF6D00\n    style OptionGroup fill:#000000,color:#FFFFFF,stroke:#FFD600\n    style ResultGroup fill:#000000,stroke:#D50000\n    style External fill:#000000\n    linkStyle 0 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 1 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 2 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 3 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 4 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 5 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 6 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 7 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 8 stroke:#fdd835,stroke-width:2.5px,fill:none\n    linkStyle 9 stroke:#e53935,stroke-width:2.5px,fill:none\n    linkStyle 10 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 11 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 12 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 13 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 14 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 15 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 16 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 17 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 18 stroke:#fdd835,stroke-width:2.5px,fill:none\n    linkStyle 19 stroke:#e53935,stroke-width:2.5px,fill:none\n    linkStyle 20 stroke:#9c27b0,stroke-width:2.5px,fill:none\n    linkStyle 21 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 22 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 23 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 24 stroke:#fdd835,stroke-width:2.5px,fill:none\n    linkStyle 25 stroke:#e53935,stroke-width:2.5px,fill:none\n\n    L_OptionGroup_ResultGroup_2@{ animation: none }</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"reference/checkable/","level":1,"title":"Checkable","text":"<p>Mixin class providing conditional chaining methods based on truthiness.</p> <p>This class provides methods inspired by Rust's <code>bool</code> type for conditional execution and wrapping in <code>Option</code> or <code>Result</code> types.</p> <p>All methods evaluate the instance's truthiness to determine their behavior.</p> Source code in <code>src/pyochain/traits.py</code> <pre><code>class Checkable:\n    \"\"\"Mixin class providing conditional chaining methods based on truthiness.\n\n    This class provides methods inspired by Rust's `bool` type for conditional\n    execution and wrapping in `Option` or `Result` types.\n\n    All methods evaluate the instance's truthiness to determine their behavior.\n    \"\"\"\n\n    def then[**P, R](\n        self,\n        func: Callable[Concatenate[Self, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Option[R]:\n        \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n        `R` being the return type of **func**.\n\n        The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Args:\n            func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n        Some(6)\n        &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n        NONE\n\n        ```\n        \"\"\"\n        from ._option import NONE, Some\n\n        return Some(func(self, *args, **kwargs)) if self else NONE\n\n    def then_some(self) -&gt; Option[Self]:\n        \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Returns:\n            Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n        Some(Seq(1, 2, 3))\n        &gt;&gt;&gt; pc.Seq([]).then_some()\n        NONE\n\n        ```\n        \"\"\"\n        from ._option import NONE, Some\n\n        return Some(self) if self else NONE\n\n    def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n        \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Args:\n            err (E): The error value to wrap in Err if self is falsy.\n\n        Returns:\n            Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n        Ok(Seq(1, 2, 3))\n        &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n        Err('empty')\n\n        ```\n        \"\"\"\n        from ._result import Err, Ok\n\n        return Ok(self) if self else Err(err)\n\n    def ok_or_else[**P, E](\n        self,\n        func: Callable[Concatenate[Self, P], E],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Result[Self, E]:\n        \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n        `E` being the return type of **func**.\n\n        The function is only called if self evaluates to False.\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Args:\n            func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n            *args (P.args): Positional arguments to pass to the function.\n            **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n        Returns:\n            Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n        Ok(Seq(1, 2, 3))\n        &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n        Err('empty seq')\n\n        ```\n        \"\"\"\n        from ._result import Err, Ok\n\n        return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.traits.Checkable.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.traits.Checkable.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.traits.Checkable.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.traits.Checkable.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/dict/","level":1,"title":"Dict","text":"<p>               Bases: <code>Pipeable</code>, <code>Checkable</code>, <code>MutableMapping[K, V]</code></p> <p>A <code>Dict</code> is a key-value store similar to Python's built-in <code>dict</code>, but with additional methods inspired by Rust's <code>HashMap</code>.</p> <p>You can initialize it with an existing Python <code>dict</code>, or from any object that can be converted into a dict with the <code>from_</code> method.</p> <p>Implement the <code>MutableMapping</code> interface, so all standard dictionary operations are supported.</p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>class Dict[K, V](Pipeable, Checkable, MutableMapping[K, V]):\n    \"\"\"A `Dict` is a key-value store similar to Python's built-in `dict`, but with additional methods inspired by Rust's `HashMap`.\n\n    You can initialize it with an existing Python `dict`, or from any object that can be converted into a dict with the `from_` method.\n\n    Implement the `MutableMapping` interface, so all standard dictionary operations are supported.\n\n    \"\"\"\n\n    __slots__ = (\"_inner\",)\n\n    _inner: dict[K, V]\n\n    def __init__(\n        self, data: Mapping[K, V] | Iterable[tuple[K, V]] | SupportsKeysAndGetItem[K, V]\n    ) -&gt; None:\n        self._inner = dict(data)\n\n    def __repr__(self) -&gt; str:\n        return f\"{get_config().dict_repr(self._inner)}\"\n\n    def __iter__(self) -&gt; Iterator[K]:\n        return self._inner.__iter__()\n\n    def __len__(self) -&gt; int:\n        return len(self._inner)\n\n    def __getitem__(self, key: K) -&gt; V:\n        return self._inner[key]\n\n    def __setitem__(self, key: K, value: V) -&gt; None:\n        self._inner[key] = value\n\n    def __delitem__(self, key: K) -&gt; None:\n        del self._inner[key]\n\n    def contains_key(self, key: K) -&gt; bool:\n        \"\"\"Check if the `Dict` contains the specified key.\n\n        This is equivalent to using the `in` keyword directly on the `Dict`.\n\n        Args:\n            key (K): The key to check for existence.\n\n        Returns:\n            bool: True if the key exists in the Dict, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.contains_key(1)\n        True\n        &gt;&gt;&gt; data.contains_key(3)\n        False\n\n        ```\n        \"\"\"\n        return key in self._inner\n\n    def length(self) -&gt; int:\n        \"\"\"Return the number of key-value pairs in the `Dict`.\n\n        Equivalent to `len(self)`.\n\n        Returns:\n            int: The number of items in the Dict.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\", 3: \"c\"})\n        &gt;&gt;&gt; data.length()\n        3\n\n        ```\n        \"\"\"\n        return len(self._inner)\n\n    @classmethod\n    def new(cls) -&gt; Self:\n        \"\"\"Create an empty `Dict`.\n\n        Returns:\n            Self: An empty Dict instance.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict.new()\n        {}\n\n        ```\n        \"\"\"\n        return cls({})\n\n    @staticmethod\n    def from_kwargs[U](**kwargs: U) -&gt; Dict[str, U]:\n        \"\"\"Create a `Dict` from keyword arguments.\n\n        Args:\n            **kwargs (U): Key-value pairs to initialize the Dict.\n\n        Returns:\n            Dict[str, U]: A new Dict instance containing the provided key-value pairs.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict.from_kwargs(a=1, b=2)\n        {'a': 1, 'b': 2}\n\n        ```\n        \"\"\"\n        return Dict(kwargs)\n\n    @staticmethod\n    def from_object(obj: object) -&gt; Dict[str, Any]:\n        \"\"\"Create a `Dict` from an object `__dict__` attribute.\n\n        We can't know in advance the values types, so we use `Any`.\n\n        Args:\n            obj (object): The object whose `__dict__` attribute will be used to create the Dict.\n\n        Returns:\n            Dict[str, Any]: A new Dict instance containing the attributes of the object.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; class Person:\n        ...     def __init__(self, name: str, age: int):\n        ...         self.name = name\n        ...         self.age = age\n        &gt;&gt;&gt; person = Person(\"Alice\", 30)\n        &gt;&gt;&gt; pc.Dict.from_object(person)\n        {'name': 'Alice', 'age': 30}\n\n        ```\n        \"\"\"\n        return Dict(obj.__dict__)\n\n    def insert(self, key: K, value: V) -&gt; Option[V]:\n        \"\"\"Insert a key-value pair into the `Dict`.\n\n        If the `Dict` did not have this **key** present, `NONE` is returned.\n\n        If the `Dict` did have this **key** present, the **value** is updated, and the old value is returned.\n\n        The **key** is not updated.\n\n        Args:\n            key (K): The key to insert.\n            value (V): The value associated with the key.\n\n        Returns:\n            Option[V]: The previous value associated with the key, or None if the key was not present.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict.new()\n        &gt;&gt;&gt; data.insert(37, \"a\")\n        NONE\n        &gt;&gt;&gt; data.is_empty()\n        False\n\n        &gt;&gt;&gt; data.insert(37, \"b\")\n        Some('a')\n        &gt;&gt;&gt; data.insert(37, \"c\")\n        Some('b')\n        &gt;&gt;&gt; data[37]\n        'c'\n\n        ```\n        \"\"\"\n        from ._option import Option\n\n        previous = self._inner.get(key, None)\n        self._inner[key] = value\n        return Option(previous)\n\n    def try_insert(self, key: K, value: V) -&gt; Result[V, KeyError]:\n        \"\"\"Tries to insert a key-value pair into the map, and returns a mutable reference to the value in the entry.\n\n        If the map already had this key present, nothing is updated, and an error containing the occupied entry and the value is returned.\n\n        Args:\n            key (K): The key to insert.\n            value (V): The value associated with the key.\n\n        Returns:\n            Result[V, KeyError]: Ok containing the value if the key was not present, or Err containing a KeyError if the key already existed.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; d = pc.Dict.new()\n        &gt;&gt;&gt; d.try_insert(37, \"a\").unwrap()\n        'a'\n        &gt;&gt;&gt; d.try_insert(37, \"b\")\n        Err(KeyError('Key 37 already exists with value a.'))\n\n        ```\n        \"\"\"\n        from ._result import Err, Ok\n\n        if key in self._inner:\n            return Err(\n                KeyError(f\"Key {key} already exists with value {self._inner[key]}.\")\n            )\n        self._inner[key] = value\n        return Ok(value)\n\n    def remove(self, key: K) -&gt; Option[V]:\n        \"\"\"Remove a key from the `Dict` and return its value if it existed.\n\n        Equivalent to `dict.pop(key, None)`, with an `Option` return type.\n\n        Args:\n            key (K): The key to remove.\n\n        Returns:\n            Option[V]: The value associated with the removed key, or None if the key was not present.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.remove(1)\n        Some('a')\n        &gt;&gt;&gt; data.remove(3)\n        NONE\n\n        ```\n        \"\"\"\n        from ._option import Option\n\n        return Option(self._inner.pop(key, None))\n\n    def remove_entry(self, key: K) -&gt; Option[tuple[K, V]]:\n        \"\"\"Remove a key from the `Dict` and return the `Item` if it existed.\n\n        Return an `Item` containing the (key, value) pair if the key was present.\n\n        Args:\n            key (K): The key to remove.\n\n        Returns:\n            Option[tuple[K, V]]: The (key, value) pair associated with the removed key, or None if the key was not present.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.remove_entry(1)\n        Some((1, 'a'))\n        &gt;&gt;&gt; data.remove_entry(3)\n        NONE\n\n        ```\n        \"\"\"\n        from ._option import NONE, Some\n\n        if key in self._inner:\n            return Some((key, self._inner.pop(key)))\n        return NONE\n\n    def keys_iter(self) -&gt; Iter[K]:\n        \"\"\"Return an Iter of the dict's keys.\n\n        Returns:\n            Iter[K]: An Iter wrapping the dictionary's keys.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict({1: 2}).keys_iter().collect()\n        Seq(1,)\n\n        ```\n        \"\"\"\n        from ._iter import Iter\n\n        return Iter(self._inner.keys())\n\n    def values_iter(self) -&gt; Iter[V]:\n        \"\"\"Return an `Iter` of the `Dict` values.\n\n        Returns:\n            Iter[V]: An Iter wrapping the dictionary's values.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict({1: 2}).values_iter().collect()\n        Seq(2,)\n\n        ```\n        \"\"\"\n        from ._iter import Iter\n\n        return Iter(self._inner.values())\n\n    def iter(self) -&gt; Iter[tuple[K, V]]:\n        \"\"\"Return an `Iter` of the dict's items.\n\n        Yield tuples of (key, value) pairs.\n\n        Note:\n            `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n            This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n        Returns:\n            Iter[tuple[K, V]]: An Iter wrapping the dictionary's (key, value) pairs.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({\"a\": 1, \"b\": 2})\n        &gt;&gt;&gt; data.iter().collect()\n        Seq(('a', 1), ('b', 2))\n        &gt;&gt;&gt; data.iter().map_star(lambda key, value: key).collect()\n        Seq('a', 'b')\n        &gt;&gt;&gt; data.iter().map_star(lambda key, value: value).collect()\n        Seq(1, 2)\n\n        ```\n        \"\"\"\n        from ._iter import Iter\n\n        return Iter(self._inner.items())\n\n    def get_item(self, key: K) -&gt; Option[V]:\n        \"\"\"Retrieve a value from the `Dict`.\n\n        Returns `Some(value)` if the key exists, or `None` if it does not.\n\n        Args:\n            key (K): The key to look up.\n\n        Returns:\n            Option[V]: Value that is associated with the key, or None if not found.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = {\"a\": 1}\n        &gt;&gt;&gt; pc.Dict(data).get_item(\"a\")\n        Some(1)\n        &gt;&gt;&gt; pc.Dict(data).get_item(\"x\").unwrap_or('Not Found')\n        'Not Found'\n\n        ```\n        \"\"\"\n        from ._option import Option\n\n        return Option(self._inner.get(key, None))\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Returns true if the map contains no elements.\n\n        Returns:\n            bool: True if the Dict is empty, False otherwise.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; d = pc.Dict.new()\n        &gt;&gt;&gt; d.is_empty()\n        True\n        &gt;&gt;&gt; d.insert(1, \"a\")\n        NONE\n        &gt;&gt;&gt; d.is_empty()\n        False\n\n        ```\n        \"\"\"\n        return len(self._inner) == 0\n\n    @overload\n    def filter_keys[U](self, predicate: Callable[[K], TypeIs[U]]) -&gt; Dict[U, V]: ...\n    @overload\n    def filter_keys(self, predicate: Callable[[K], bool]) -&gt; Dict[K, V]: ...\n    def filter_keys[U](\n        self,\n        predicate: Callable[[K], bool | TypeIs[U]],\n    ) -&gt; Dict[K, V] | Dict[U, V]:\n        \"\"\"Return a new `Dict` containing only the items whose keys satisfy the **predicate**.\n\n        This does not modify the original `Dict`.\n\n        Args:\n            predicate (Callable[[K], bool | TypeIs[U]]): Function to determine if a key should be included.\n\n        Returns:\n            Dict[K, V] | Dict[U, V]: Filtered Dict with keys satisfying predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; d = {1: 2, 2: 3, 3: 4, 4: 5}\n        &gt;&gt;&gt; pc.Dict(d).filter_keys(lambda x: x % 2 == 0)\n        {2: 3, 4: 5}\n\n        ```\n        \"\"\"\n        return Dict(cz.dicttoolz.keyfilter(predicate, self._inner))\n\n    @overload\n    def filter_values[U](self, predicate: Callable[[V], TypeIs[U]]) -&gt; Dict[K, U]: ...\n    @overload\n    def filter_values(self, predicate: Callable[[V], bool]) -&gt; Dict[K, V]: ...\n    def filter_values[U](\n        self,\n        predicate: Callable[[V], bool] | Callable[[V], TypeIs[U]],\n    ) -&gt; Dict[K, V] | Dict[K, U]:\n        \"\"\"Return a new `Dict` containing only the items whose values satisfy the **predicate**.\n\n        This does not modify the original `Dict`.\n\n        Args:\n            predicate (Callable[[V], bool] | Callable[[V], TypeIs[U]]): Function to determine if a value should be included.\n\n        Returns:\n            Dict[K, V] | Dict[K, U]: Filtered Dict with values satisfying predicate\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; d = {1: 2, 2: 3, 3: 4, 4: 5}\n        &gt;&gt;&gt; pc.Dict(d).filter_values(lambda x: x % 2 == 0)\n        {1: 2, 3: 4}\n        &gt;&gt;&gt; pc.Dict(d).filter_values(lambda x: not x &gt; 3)\n        {1: 2, 2: 3}\n\n        ```\n        \"\"\"\n        return Dict(cz.dicttoolz.valfilter(predicate, self._inner))\n\n    def filter_items(self, predicate: Callable[[tuple[K, V]], bool]) -&gt; Dict[K, V]:\n        \"\"\"Return a new `Dict` containing only the items that satisfy the **predicate**.\n\n        This does not modify the original `Dict`.\n\n        Args:\n            predicate (Callable[[tuple[K, V]], bool]): Function to determine if a (key, value) pair should be included.\n\n        Returns:\n            Dict[K, V]: A new Dict instance containing only the items that satisfy the predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def isvalid(item):\n        ...     k, v = item\n        ...     return k % 2 == 0 and v &lt; 4\n        &gt;&gt;&gt; d = pc.Dict({1: 2, 2: 3, 3: 4, 4: 5})\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; d.filter_items(isvalid)\n        {2: 3}\n        &gt;&gt;&gt; d.filter_items(lambda kv: not isvalid(kv))\n        {1: 2, 3: 4, 4: 5}\n\n        ```\n        \"\"\"\n        return Dict(cz.dicttoolz.itemfilter(predicate, self._inner))\n\n    def map_keys[T](self, func: Callable[[K], T]) -&gt; Dict[T, V]:\n        \"\"\"Return a new `Dict` with keys transformed by the provided **func**.\n\n        The values of the original `Dict` remain unchanged.\n\n        Args:\n            func (Callable[[K], T]): Function to apply to each key in the dictionary.\n\n        Returns:\n            Dict[T, V]: Dict with transformed keys.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict({\"Alice\": [20, 15, 30], \"Bob\": [10, 35]}).map_keys(str.lower)\n        {'alice': [20, 15, 30], 'bob': [10, 35]}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Dict({1: \"a\"}).map_keys(str)\n        {'1': 'a'}\n\n        ```\n        \"\"\"\n        return Dict(cz.dicttoolz.keymap(func, self._inner))\n\n    def map_values[T](self, func: Callable[[V], T]) -&gt; Dict[K, T]:\n        \"\"\"Return a new `Dict` with values transformed by the provided **func**.\n\n        The keys of the original `Dict` remain unchanged.\n\n        Args:\n            func (Callable[[V], T]): Function to apply to each value in the dictionary.\n\n        Returns:\n            Dict[K, T]: Dict with transformed values.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict({\"Alice\": [20, 15, 30], \"Bob\": [10, 35]}).map_values(sum)\n        {'Alice': 65, 'Bob': 45}\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Dict({1: 1}).map_values(lambda v: v + 1)\n        {1: 2}\n\n        ```\n        \"\"\"\n        return Dict(cz.dicttoolz.valmap(func, self._inner))\n\n    def map_items[KR, VR](\n        self,\n        func: Callable[[tuple[K, V]], tuple[KR, VR]],\n    ) -&gt; Dict[KR, VR]:\n        \"\"\"Return a new `Dict` with items transformed by the provided **func**.\n\n        The original `Dict` remains unchanged.\n\n        Args:\n            func (Callable[[tuple[K, V]], tuple[KR, VR]]): Function to transform each (key, value) pair into a new (key, value) tuple.\n\n        Returns:\n            Dict[KR, VR]: Dict with transformed items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict({\"Alice\": 10, \"Bob\": 20}).map_items(\n        ...     lambda kv: (kv[0].upper(), kv[1] * 2)\n        ... )\n        {'ALICE': 20, 'BOB': 40}\n\n        ```\n        \"\"\"\n        return Dict(cz.dicttoolz.itemmap(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.contains_key","level":2,"title":"<code>contains_key(key)</code>","text":"<p>Check if the <code>Dict</code> contains the specified key.</p> <p>This is equivalent to using the <code>in</code> keyword directly on the <code>Dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to check for existence.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key exists in the Dict, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.contains_key(1)\nTrue\n&gt;&gt;&gt; data.contains_key(3)\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def contains_key(self, key: K) -&gt; bool:\n    \"\"\"Check if the `Dict` contains the specified key.\n\n    This is equivalent to using the `in` keyword directly on the `Dict`.\n\n    Args:\n        key (K): The key to check for existence.\n\n    Returns:\n        bool: True if the key exists in the Dict, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.contains_key(1)\n    True\n    &gt;&gt;&gt; data.contains_key(3)\n    False\n\n    ```\n    \"\"\"\n    return key in self._inner\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.filter_items","level":2,"title":"<code>filter_items(predicate)</code>","text":"<p>Return a new <code>Dict</code> containing only the items that satisfy the predicate.</p> <p>This does not modify the original <code>Dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[tuple[K, V]], bool]</code> <p>Function to determine if a (key, value) pair should be included.</p> required <p>Returns:</p> Type Description <code>Dict[K, V]</code> <p>Dict[K, V]: A new Dict instance containing only the items that satisfy the predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def isvalid(item):\n...     k, v = item\n...     return k % 2 == 0 and v &lt; 4\n&gt;&gt;&gt; d = pc.Dict({1: 2, 2: 3, 3: 4, 4: 5})\n&gt;&gt;&gt;\n&gt;&gt;&gt; d.filter_items(isvalid)\n{2: 3}\n&gt;&gt;&gt; d.filter_items(lambda kv: not isvalid(kv))\n{1: 2, 3: 4, 4: 5}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def filter_items(self, predicate: Callable[[tuple[K, V]], bool]) -&gt; Dict[K, V]:\n    \"\"\"Return a new `Dict` containing only the items that satisfy the **predicate**.\n\n    This does not modify the original `Dict`.\n\n    Args:\n        predicate (Callable[[tuple[K, V]], bool]): Function to determine if a (key, value) pair should be included.\n\n    Returns:\n        Dict[K, V]: A new Dict instance containing only the items that satisfy the predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def isvalid(item):\n    ...     k, v = item\n    ...     return k % 2 == 0 and v &lt; 4\n    &gt;&gt;&gt; d = pc.Dict({1: 2, 2: 3, 3: 4, 4: 5})\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; d.filter_items(isvalid)\n    {2: 3}\n    &gt;&gt;&gt; d.filter_items(lambda kv: not isvalid(kv))\n    {1: 2, 3: 4, 4: 5}\n\n    ```\n    \"\"\"\n    return Dict(cz.dicttoolz.itemfilter(predicate, self._inner))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.filter_keys","level":2,"title":"<code>filter_keys(predicate)</code>","text":"<pre><code>filter_keys(\n    predicate: Callable[[K], TypeIs[U]],\n) -&gt; Dict[U, V]\n</code></pre><pre><code>filter_keys(predicate: Callable[[K], bool]) -&gt; Dict[K, V]\n</code></pre> <p>Return a new <code>Dict</code> containing only the items whose keys satisfy the predicate.</p> <p>This does not modify the original <code>Dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[K], bool | TypeIs[U]]</code> <p>Function to determine if a key should be included.</p> required <p>Returns:</p> Type Description <code>Dict[K, V] | Dict[U, V]</code> <p>Dict[K, V] | Dict[U, V]: Filtered Dict with keys satisfying predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; d = {1: 2, 2: 3, 3: 4, 4: 5}\n&gt;&gt;&gt; pc.Dict(d).filter_keys(lambda x: x % 2 == 0)\n{2: 3, 4: 5}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def filter_keys[U](\n    self,\n    predicate: Callable[[K], bool | TypeIs[U]],\n) -&gt; Dict[K, V] | Dict[U, V]:\n    \"\"\"Return a new `Dict` containing only the items whose keys satisfy the **predicate**.\n\n    This does not modify the original `Dict`.\n\n    Args:\n        predicate (Callable[[K], bool | TypeIs[U]]): Function to determine if a key should be included.\n\n    Returns:\n        Dict[K, V] | Dict[U, V]: Filtered Dict with keys satisfying predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; d = {1: 2, 2: 3, 3: 4, 4: 5}\n    &gt;&gt;&gt; pc.Dict(d).filter_keys(lambda x: x % 2 == 0)\n    {2: 3, 4: 5}\n\n    ```\n    \"\"\"\n    return Dict(cz.dicttoolz.keyfilter(predicate, self._inner))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.filter_values","level":2,"title":"<code>filter_values(predicate)</code>","text":"<pre><code>filter_values(\n    predicate: Callable[[V], TypeIs[U]],\n) -&gt; Dict[K, U]\n</code></pre><pre><code>filter_values(predicate: Callable[[V], bool]) -&gt; Dict[K, V]\n</code></pre> <p>Return a new <code>Dict</code> containing only the items whose values satisfy the predicate.</p> <p>This does not modify the original <code>Dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[V], bool] | Callable[[V], TypeIs[U]]</code> <p>Function to determine if a value should be included.</p> required <p>Returns:</p> Type Description <code>Dict[K, V] | Dict[K, U]</code> <p>Dict[K, V] | Dict[K, U]: Filtered Dict with values satisfying predicate</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; d = {1: 2, 2: 3, 3: 4, 4: 5}\n&gt;&gt;&gt; pc.Dict(d).filter_values(lambda x: x % 2 == 0)\n{1: 2, 3: 4}\n&gt;&gt;&gt; pc.Dict(d).filter_values(lambda x: not x &gt; 3)\n{1: 2, 2: 3}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def filter_values[U](\n    self,\n    predicate: Callable[[V], bool] | Callable[[V], TypeIs[U]],\n) -&gt; Dict[K, V] | Dict[K, U]:\n    \"\"\"Return a new `Dict` containing only the items whose values satisfy the **predicate**.\n\n    This does not modify the original `Dict`.\n\n    Args:\n        predicate (Callable[[V], bool] | Callable[[V], TypeIs[U]]): Function to determine if a value should be included.\n\n    Returns:\n        Dict[K, V] | Dict[K, U]: Filtered Dict with values satisfying predicate\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; d = {1: 2, 2: 3, 3: 4, 4: 5}\n    &gt;&gt;&gt; pc.Dict(d).filter_values(lambda x: x % 2 == 0)\n    {1: 2, 3: 4}\n    &gt;&gt;&gt; pc.Dict(d).filter_values(lambda x: not x &gt; 3)\n    {1: 2, 2: 3}\n\n    ```\n    \"\"\"\n    return Dict(cz.dicttoolz.valfilter(predicate, self._inner))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.from_kwargs","level":2,"title":"<code>from_kwargs(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a <code>Dict</code> from keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>U</code> <p>Key-value pairs to initialize the Dict.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, U]</code> <p>Dict[str, U]: A new Dict instance containing the provided key-value pairs.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict.from_kwargs(a=1, b=2)\n{'a': 1, 'b': 2}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>@staticmethod\ndef from_kwargs[U](**kwargs: U) -&gt; Dict[str, U]:\n    \"\"\"Create a `Dict` from keyword arguments.\n\n    Args:\n        **kwargs (U): Key-value pairs to initialize the Dict.\n\n    Returns:\n        Dict[str, U]: A new Dict instance containing the provided key-value pairs.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict.from_kwargs(a=1, b=2)\n    {'a': 1, 'b': 2}\n\n    ```\n    \"\"\"\n    return Dict(kwargs)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.from_object","level":2,"title":"<code>from_object(obj)</code>  <code>staticmethod</code>","text":"<p>Create a <code>Dict</code> from an object <code>__dict__</code> attribute.</p> <p>We can't know in advance the values types, so we use <code>Any</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object whose <code>__dict__</code> attribute will be used to create the Dict.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A new Dict instance containing the attributes of the object.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; class Person:\n...     def __init__(self, name: str, age: int):\n...         self.name = name\n...         self.age = age\n&gt;&gt;&gt; person = Person(\"Alice\", 30)\n&gt;&gt;&gt; pc.Dict.from_object(person)\n{'name': 'Alice', 'age': 30}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>@staticmethod\ndef from_object(obj: object) -&gt; Dict[str, Any]:\n    \"\"\"Create a `Dict` from an object `__dict__` attribute.\n\n    We can't know in advance the values types, so we use `Any`.\n\n    Args:\n        obj (object): The object whose `__dict__` attribute will be used to create the Dict.\n\n    Returns:\n        Dict[str, Any]: A new Dict instance containing the attributes of the object.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; class Person:\n    ...     def __init__(self, name: str, age: int):\n    ...         self.name = name\n    ...         self.age = age\n    &gt;&gt;&gt; person = Person(\"Alice\", 30)\n    &gt;&gt;&gt; pc.Dict.from_object(person)\n    {'name': 'Alice', 'age': 30}\n\n    ```\n    \"\"\"\n    return Dict(obj.__dict__)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.get_item","level":2,"title":"<code>get_item(key)</code>","text":"<p>Retrieve a value from the <code>Dict</code>.</p> <p>Returns <code>Some(value)</code> if the key exists, or <code>None</code> if it does not.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to look up.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: Value that is associated with the key, or None if not found.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = {\"a\": 1}\n&gt;&gt;&gt; pc.Dict(data).get_item(\"a\")\nSome(1)\n&gt;&gt;&gt; pc.Dict(data).get_item(\"x\").unwrap_or('Not Found')\n'Not Found'\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def get_item(self, key: K) -&gt; Option[V]:\n    \"\"\"Retrieve a value from the `Dict`.\n\n    Returns `Some(value)` if the key exists, or `None` if it does not.\n\n    Args:\n        key (K): The key to look up.\n\n    Returns:\n        Option[V]: Value that is associated with the key, or None if not found.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = {\"a\": 1}\n    &gt;&gt;&gt; pc.Dict(data).get_item(\"a\")\n    Some(1)\n    &gt;&gt;&gt; pc.Dict(data).get_item(\"x\").unwrap_or('Not Found')\n    'Not Found'\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(self._inner.get(key, None))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.insert","level":2,"title":"<code>insert(key, value)</code>","text":"<p>Insert a key-value pair into the <code>Dict</code>.</p> <p>If the <code>Dict</code> did not have this key present, <code>NONE</code> is returned.</p> <p>If the <code>Dict</code> did have this key present, the value is updated, and the old value is returned.</p> <p>The key is not updated.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to insert.</p> required <code>value</code> <code>V</code> <p>The value associated with the key.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: The previous value associated with the key, or None if the key was not present.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict.new()\n&gt;&gt;&gt; data.insert(37, \"a\")\nNONE\n&gt;&gt;&gt; data.is_empty()\nFalse\n\n&gt;&gt;&gt; data.insert(37, \"b\")\nSome('a')\n&gt;&gt;&gt; data.insert(37, \"c\")\nSome('b')\n&gt;&gt;&gt; data[37]\n'c'\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def insert(self, key: K, value: V) -&gt; Option[V]:\n    \"\"\"Insert a key-value pair into the `Dict`.\n\n    If the `Dict` did not have this **key** present, `NONE` is returned.\n\n    If the `Dict` did have this **key** present, the **value** is updated, and the old value is returned.\n\n    The **key** is not updated.\n\n    Args:\n        key (K): The key to insert.\n        value (V): The value associated with the key.\n\n    Returns:\n        Option[V]: The previous value associated with the key, or None if the key was not present.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict.new()\n    &gt;&gt;&gt; data.insert(37, \"a\")\n    NONE\n    &gt;&gt;&gt; data.is_empty()\n    False\n\n    &gt;&gt;&gt; data.insert(37, \"b\")\n    Some('a')\n    &gt;&gt;&gt; data.insert(37, \"c\")\n    Some('b')\n    &gt;&gt;&gt; data[37]\n    'c'\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    previous = self._inner.get(key, None)\n    self._inner[key] = value\n    return Option(previous)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.is_empty","level":2,"title":"<code>is_empty()</code>","text":"<p>Returns true if the map contains no elements.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Dict is empty, False otherwise.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; d = pc.Dict.new()\n&gt;&gt;&gt; d.is_empty()\nTrue\n&gt;&gt;&gt; d.insert(1, \"a\")\nNONE\n&gt;&gt;&gt; d.is_empty()\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Returns true if the map contains no elements.\n\n    Returns:\n        bool: True if the Dict is empty, False otherwise.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; d = pc.Dict.new()\n    &gt;&gt;&gt; d.is_empty()\n    True\n    &gt;&gt;&gt; d.insert(1, \"a\")\n    NONE\n    &gt;&gt;&gt; d.is_empty()\n    False\n\n    ```\n    \"\"\"\n    return len(self._inner) == 0\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.iter","level":2,"title":"<code>iter()</code>","text":"<p>Return an <code>Iter</code> of the dict's items.</p> <p>Yield tuples of (key, value) pairs.</p> Note <p><code>Iter.map_star</code> can then be used for subsequent operations on the index and value, in a destructuring manner. This keep the code clean and readable, without index access like <code>[0]</code> and <code>[1]</code> for inline lambdas.</p> <p>Returns:</p> Type Description <code>Iter[tuple[K, V]]</code> <p>Iter[tuple[K, V]]: An Iter wrapping the dictionary's (key, value) pairs.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({\"a\": 1, \"b\": 2})\n&gt;&gt;&gt; data.iter().collect()\nSeq(('a', 1), ('b', 2))\n&gt;&gt;&gt; data.iter().map_star(lambda key, value: key).collect()\nSeq('a', 'b')\n&gt;&gt;&gt; data.iter().map_star(lambda key, value: value).collect()\nSeq(1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def iter(self) -&gt; Iter[tuple[K, V]]:\n    \"\"\"Return an `Iter` of the dict's items.\n\n    Yield tuples of (key, value) pairs.\n\n    Note:\n        `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n        This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n    Returns:\n        Iter[tuple[K, V]]: An Iter wrapping the dictionary's (key, value) pairs.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({\"a\": 1, \"b\": 2})\n    &gt;&gt;&gt; data.iter().collect()\n    Seq(('a', 1), ('b', 2))\n    &gt;&gt;&gt; data.iter().map_star(lambda key, value: key).collect()\n    Seq('a', 'b')\n    &gt;&gt;&gt; data.iter().map_star(lambda key, value: value).collect()\n    Seq(1, 2)\n\n    ```\n    \"\"\"\n    from ._iter import Iter\n\n    return Iter(self._inner.items())\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.keys_iter","level":2,"title":"<code>keys_iter()</code>","text":"<p>Return an Iter of the dict's keys.</p> <p>Returns:</p> Type Description <code>Iter[K]</code> <p>Iter[K]: An Iter wrapping the dictionary's keys.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict({1: 2}).keys_iter().collect()\nSeq(1,)\n</code></pre> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def keys_iter(self) -&gt; Iter[K]:\n    \"\"\"Return an Iter of the dict's keys.\n\n    Returns:\n        Iter[K]: An Iter wrapping the dictionary's keys.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict({1: 2}).keys_iter().collect()\n    Seq(1,)\n\n    ```\n    \"\"\"\n    from ._iter import Iter\n\n    return Iter(self._inner.keys())\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.length","level":2,"title":"<code>length()</code>","text":"<p>Return the number of key-value pairs in the <code>Dict</code>.</p> <p>Equivalent to <code>len(self)</code>.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of items in the Dict.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\", 3: \"c\"})\n&gt;&gt;&gt; data.length()\n3\n</code></pre> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def length(self) -&gt; int:\n    \"\"\"Return the number of key-value pairs in the `Dict`.\n\n    Equivalent to `len(self)`.\n\n    Returns:\n        int: The number of items in the Dict.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\", 3: \"c\"})\n    &gt;&gt;&gt; data.length()\n    3\n\n    ```\n    \"\"\"\n    return len(self._inner)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.map_items","level":2,"title":"<code>map_items(func)</code>","text":"<p>Return a new <code>Dict</code> with items transformed by the provided func.</p> <p>The original <code>Dict</code> remains unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[tuple[K, V]], tuple[KR, VR]]</code> <p>Function to transform each (key, value) pair into a new (key, value) tuple.</p> required <p>Returns:</p> Type Description <code>Dict[KR, VR]</code> <p>Dict[KR, VR]: Dict with transformed items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict({\"Alice\": 10, \"Bob\": 20}).map_items(\n...     lambda kv: (kv[0].upper(), kv[1] * 2)\n... )\n{'ALICE': 20, 'BOB': 40}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def map_items[KR, VR](\n    self,\n    func: Callable[[tuple[K, V]], tuple[KR, VR]],\n) -&gt; Dict[KR, VR]:\n    \"\"\"Return a new `Dict` with items transformed by the provided **func**.\n\n    The original `Dict` remains unchanged.\n\n    Args:\n        func (Callable[[tuple[K, V]], tuple[KR, VR]]): Function to transform each (key, value) pair into a new (key, value) tuple.\n\n    Returns:\n        Dict[KR, VR]: Dict with transformed items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict({\"Alice\": 10, \"Bob\": 20}).map_items(\n    ...     lambda kv: (kv[0].upper(), kv[1] * 2)\n    ... )\n    {'ALICE': 20, 'BOB': 40}\n\n    ```\n    \"\"\"\n    return Dict(cz.dicttoolz.itemmap(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.map_keys","level":2,"title":"<code>map_keys(func)</code>","text":"<p>Return a new <code>Dict</code> with keys transformed by the provided func.</p> <p>The values of the original <code>Dict</code> remain unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[K], T]</code> <p>Function to apply to each key in the dictionary.</p> required <p>Returns:</p> Type Description <code>Dict[T, V]</code> <p>Dict[T, V]: Dict with transformed keys.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict({\"Alice\": [20, 15, 30], \"Bob\": [10, 35]}).map_keys(str.lower)\n{'alice': [20, 15, 30], 'bob': [10, 35]}\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Dict({1: \"a\"}).map_keys(str)\n{'1': 'a'}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def map_keys[T](self, func: Callable[[K], T]) -&gt; Dict[T, V]:\n    \"\"\"Return a new `Dict` with keys transformed by the provided **func**.\n\n    The values of the original `Dict` remain unchanged.\n\n    Args:\n        func (Callable[[K], T]): Function to apply to each key in the dictionary.\n\n    Returns:\n        Dict[T, V]: Dict with transformed keys.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict({\"Alice\": [20, 15, 30], \"Bob\": [10, 35]}).map_keys(str.lower)\n    {'alice': [20, 15, 30], 'bob': [10, 35]}\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Dict({1: \"a\"}).map_keys(str)\n    {'1': 'a'}\n\n    ```\n    \"\"\"\n    return Dict(cz.dicttoolz.keymap(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.map_values","level":2,"title":"<code>map_values(func)</code>","text":"<p>Return a new <code>Dict</code> with values transformed by the provided func.</p> <p>The keys of the original <code>Dict</code> remain unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[V], T]</code> <p>Function to apply to each value in the dictionary.</p> required <p>Returns:</p> Type Description <code>Dict[K, T]</code> <p>Dict[K, T]: Dict with transformed values.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict({\"Alice\": [20, 15, 30], \"Bob\": [10, 35]}).map_values(sum)\n{'Alice': 65, 'Bob': 45}\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Dict({1: 1}).map_values(lambda v: v + 1)\n{1: 2}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def map_values[T](self, func: Callable[[V], T]) -&gt; Dict[K, T]:\n    \"\"\"Return a new `Dict` with values transformed by the provided **func**.\n\n    The keys of the original `Dict` remain unchanged.\n\n    Args:\n        func (Callable[[V], T]): Function to apply to each value in the dictionary.\n\n    Returns:\n        Dict[K, T]: Dict with transformed values.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict({\"Alice\": [20, 15, 30], \"Bob\": [10, 35]}).map_values(sum)\n    {'Alice': 65, 'Bob': 45}\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Dict({1: 1}).map_values(lambda v: v + 1)\n    {1: 2}\n\n    ```\n    \"\"\"\n    return Dict(cz.dicttoolz.valmap(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.new","level":2,"title":"<code>new()</code>  <code>classmethod</code>","text":"<p>Create an empty <code>Dict</code>.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An empty Dict instance.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict.new()\n{}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>@classmethod\ndef new(cls) -&gt; Self:\n    \"\"\"Create an empty `Dict`.\n\n    Returns:\n        Self: An empty Dict instance.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict.new()\n    {}\n\n    ```\n    \"\"\"\n    return cls({})\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.remove","level":2,"title":"<code>remove(key)</code>","text":"<p>Remove a key from the <code>Dict</code> and return its value if it existed.</p> <p>Equivalent to <code>dict.pop(key, None)</code>, with an <code>Option</code> return type.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: The value associated with the removed key, or None if the key was not present.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.remove(1)\nSome('a')\n&gt;&gt;&gt; data.remove(3)\nNONE\n</code></pre> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def remove(self, key: K) -&gt; Option[V]:\n    \"\"\"Remove a key from the `Dict` and return its value if it existed.\n\n    Equivalent to `dict.pop(key, None)`, with an `Option` return type.\n\n    Args:\n        key (K): The key to remove.\n\n    Returns:\n        Option[V]: The value associated with the removed key, or None if the key was not present.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.remove(1)\n    Some('a')\n    &gt;&gt;&gt; data.remove(3)\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(self._inner.pop(key, None))\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.remove_entry","level":2,"title":"<code>remove_entry(key)</code>","text":"<p>Remove a key from the <code>Dict</code> and return the <code>Item</code> if it existed.</p> <p>Return an <code>Item</code> containing the (key, value) pair if the key was present.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>Option[tuple[K, V]]</code> <p>Option[tuple[K, V]]: The (key, value) pair associated with the removed key, or None if the key was not present.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.remove_entry(1)\nSome((1, 'a'))\n&gt;&gt;&gt; data.remove_entry(3)\nNONE\n</code></pre> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def remove_entry(self, key: K) -&gt; Option[tuple[K, V]]:\n    \"\"\"Remove a key from the `Dict` and return the `Item` if it existed.\n\n    Return an `Item` containing the (key, value) pair if the key was present.\n\n    Args:\n        key (K): The key to remove.\n\n    Returns:\n        Option[tuple[K, V]]: The (key, value) pair associated with the removed key, or None if the key was not present.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.remove_entry(1)\n    Some((1, 'a'))\n    &gt;&gt;&gt; data.remove_entry(3)\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    if key in self._inner:\n        return Some((key, self._inner.pop(key)))\n    return NONE\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.try_insert","level":2,"title":"<code>try_insert(key, value)</code>","text":"<p>Tries to insert a key-value pair into the map, and returns a mutable reference to the value in the entry.</p> <p>If the map already had this key present, nothing is updated, and an error containing the occupied entry and the value is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to insert.</p> required <code>value</code> <code>V</code> <p>The value associated with the key.</p> required <p>Returns:</p> Type Description <code>Result[V, KeyError]</code> <p>Result[V, KeyError]: Ok containing the value if the key was not present, or Err containing a KeyError if the key already existed.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; d = pc.Dict.new()\n&gt;&gt;&gt; d.try_insert(37, \"a\").unwrap()\n'a'\n&gt;&gt;&gt; d.try_insert(37, \"b\")\nErr(KeyError('Key 37 already exists with value a.'))\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def try_insert(self, key: K, value: V) -&gt; Result[V, KeyError]:\n    \"\"\"Tries to insert a key-value pair into the map, and returns a mutable reference to the value in the entry.\n\n    If the map already had this key present, nothing is updated, and an error containing the occupied entry and the value is returned.\n\n    Args:\n        key (K): The key to insert.\n        value (V): The value associated with the key.\n\n    Returns:\n        Result[V, KeyError]: Ok containing the value if the key was not present, or Err containing a KeyError if the key already existed.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; d = pc.Dict.new()\n    &gt;&gt;&gt; d.try_insert(37, \"a\").unwrap()\n    'a'\n    &gt;&gt;&gt; d.try_insert(37, \"b\")\n    Err(KeyError('Key 37 already exists with value a.'))\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    if key in self._inner:\n        return Err(\n            KeyError(f\"Key {key} already exists with value {self._inner[key]}.\")\n        )\n    self._inner[key] = value\n    return Ok(value)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.values_iter","level":2,"title":"<code>values_iter()</code>","text":"<p>Return an <code>Iter</code> of the <code>Dict</code> values.</p> <p>Returns:</p> Type Description <code>Iter[V]</code> <p>Iter[V]: An Iter wrapping the dictionary's values.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict({1: 2}).values_iter().collect()\nSeq(2,)\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>def values_iter(self) -&gt; Iter[V]:\n    \"\"\"Return an `Iter` of the `Dict` values.\n\n    Returns:\n        Iter[V]: An Iter wrapping the dictionary's values.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict({1: 2}).values_iter().collect()\n    Seq(2,)\n\n    ```\n    \"\"\"\n    from ._iter import Iter\n\n    return Iter(self._inner.values())\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/err/","level":1,"title":"Err","text":"<p>               Bases: <code>Result[T, E]</code></p> <p>Represents an error value.</p> <p>For more documentation, see the <code>Result[T, E]</code> class.</p> <p>Attributes:</p> Name Type Description <code>error</code> <code>E</code> <p>The contained error value.</p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@final\n@dataclass(slots=True)\nclass Err[T, E](Result[T, E]):\n    \"\"\"Represents an error value.\n\n    For more documentation, see the `Result[T, E]` class.\n\n    Attributes:\n        error (E): The contained error value.\n    \"\"\"\n\n    __match_args__ = (\"error\",)\n\n    error: E\n\n    def __repr__(self) -&gt; str:\n        return f\"Err({self.error!r})\"\n\n    def is_ok(self) -&gt; bool:\n        return False\n\n    def is_err(self) -&gt; bool:\n        return True\n\n    def unwrap(self) -&gt; Never:\n        msg = f\"called `unwrap` on Err: {self.error!r}\"\n        raise ResultUnwrapError(msg)\n\n    def unwrap_err(self) -&gt; E:\n        return self.error\n\n    def map_or_else[U](self, ok: Callable[[T], U], err: Callable[[E], U]) -&gt; U:  # noqa: ARG002\n        return err(self.unwrap_err())\n\n    def expect(self, msg: str) -&gt; T:\n        err_msg = f\"{msg}: {self.unwrap_err()}\"\n        raise ResultUnwrapError(err_msg)\n\n    def expect_err(self, msg: str) -&gt; E:  # noqa: ARG002\n        return self.unwrap_err()\n\n    def unwrap_or(self, default: T) -&gt; T:\n        return default\n\n    def unwrap_or_else[**P](\n        self, fn: Callable[Concatenate[E, P], T], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; T:\n        return fn(self.unwrap_err(), *args, **kwargs)\n\n    def map[**P, R](\n        self,\n        fn: Callable[Concatenate[T, P], R],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Result[R, E]:\n        return cast(Result[R, E], self)\n\n    def map_err[**P, R](\n        self, fn: Callable[Concatenate[E, P], R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[T, R]:\n        return Err(fn(self.unwrap_err(), *args, **kwargs))\n\n    def inspect[**P](\n        self,\n        fn: Callable[Concatenate[T, P], object],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Result[T, E]:\n        return self\n\n    def inspect_err[**P](\n        self, fn: Callable[Concatenate[E, P], object], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[T, E]:\n        fn(self.unwrap_err(), *args, **kwargs)\n        return self\n\n    def and_[U](self, res: Result[U, E]) -&gt; Result[U, E]:  # noqa: ARG002\n        return cast(Result[U, E], self)\n\n    def and_then[**P, R](\n        self,\n        fn: Callable[Concatenate[T, P], Result[R, E]],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Result[R, E]:\n        return cast(Result[R, E], self)\n\n    def or_else[**P](\n        self,\n        fn: Callable[Concatenate[E, P], Result[T, E]],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Result[T, E]:\n        return fn(self.unwrap_err(), *args, **kwargs)\n\n    def ok(self) -&gt; Option[T]:\n        from ._option import NONE\n\n        return NONE\n\n    def err(self) -&gt; Option[E]:\n        from ._option import Some\n\n        return Some(self.unwrap_err())\n\n    def is_ok_and[**P](\n        self,\n        pred: Callable[Concatenate[T, P], bool],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; bool:\n        return False\n\n    def is_err_and[**P](\n        self, pred: Callable[Concatenate[E, P], bool], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; bool:\n        return pred(self.unwrap_err(), *args, **kwargs)\n\n    def map_or[**P, R](\n        self,\n        default: R,\n        f: Callable[Concatenate[T, P], R],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; R:\n        return default\n\n    def transpose(self: Result[Option[T], E]) -&gt; Option[Result[T, E]]:\n        from ._option import Some\n\n        return Some(Err(self.unwrap_err()))\n\n    def or_[F](self, res: Result[T, F]) -&gt; Result[T, F]:\n        return res\n</code></pre>","path":["API Reference","Error Handling","Err"],"tags":[]},{"location":"reference/err/#pyochain._result.Err.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Result</code>.</p> <p>Converts from <code>Result[Result[T, E], E]</code> to <code>Result[T, E]</code>.</p> <p>Equivalent to calling <code>Result.and_then(lambda x: x)</code>, but more convenient when there's no need to process the inner <code>Ok</code> value.</p> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The flattened result.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n&gt;&gt;&gt; nested_ok.flatten()\nOk(2)\n&gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n&gt;&gt;&gt; nested_err.flatten()\nErr('inner error')\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>def flatten(self: Result[Result[T, E], E]) -&gt; Result[T, E]:\n    \"\"\"Flattens a nested `Result`.\n\n    Converts from `Result[Result[T, E], E]` to `Result[T, E]`.\n\n    Equivalent to calling `Result.and_then(lambda x: x)`, but more convenient when there's no need to process the inner `Ok` value.\n\n    Returns:\n        Result[T, E]: The flattened result.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n    &gt;&gt;&gt; nested_ok.flatten()\n    Ok(2)\n    &gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n    &gt;&gt;&gt; nested_err.flatten()\n    Err('inner error')\n\n    ```\n    \"\"\"\n    return self.and_then(lambda x: x)\n</code></pre>","path":["API Reference","Error Handling","Err"],"tags":[]},{"location":"reference/err/#pyochain._result.Err.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Error Handling","Err"],"tags":[]},{"location":"reference/err/#pyochain._result.Err.iter","level":2,"title":"<code>iter()</code>","text":"<p>Returns a <code>Iter[T]</code> over the possibly contained value.</p> <p>The iterator yields one value if the result is <code>Ok</code>, otherwise none.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterator over the <code>Ok</code> value, or empty if <code>Err</code>.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(7).iter().next()\nSome(7)\n&gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Returns a `Iter[T]` over the possibly contained value.\n\n    The iterator yields one value if the result is `Ok`, otherwise none.\n\n    Returns:\n        Iter[T]: An iterator over the `Ok` value, or empty if `Err`.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(7).iter().next()\n    Some(7)\n    &gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\n    NONE\n\n    ```\n    \"\"\"\n    return self.ok().iter()\n</code></pre>","path":["API Reference","Error Handling","Err"],"tags":[]},{"location":"reference/iter/","level":1,"title":"Iter","text":"<p>               Bases: <code>BaseIter[T]</code>, <code>Iterator[T]</code></p> <p>A superset around Python's built-in <code>Iterator</code> Protocol, providing a rich set of functional programming tools.</p> <p>Implements the <code>Iterator</code> Protocol from <code>collections.abc</code>, so it can be used as a standard iterator.</p> <ul> <li>An <code>Iterable</code> is any object capable of returning its members one at a time, permitting it to be iterated over in a for-loop.</li> <li>An <code>Iterator</code> is an object representing a stream of data; returned by calling <code>iter()</code> on an <code>Iterable</code>.</li> <li>Once an <code>Iterator</code> is exhausted, it cannot be reused or reset.</li> </ul> <p>It's designed around lazy evaluation, allowing for efficient processing of large datasets.</p> <p>Once an <code>Iter</code> is created, it can be transformed and manipulated using a variety of chainable methods.</p> <p>However, keep in mind that <code>Iter</code> instances are single-use; once exhausted, they cannot be reused or reset.</p> <p>If you need to reuse the data, consider collecting it into a collection first with <code>.collect()</code>.</p> <p>You can always convert back to an <code>Iter</code> using <code>{Seq, Vec}.iter()</code> for free.</p> <p>In general, avoid intermediate references when dealing with lazy iterators, and prioritize method chaining instead.</p> Note <p><code>Iter</code> inerhit from <code>Checkable</code> from it's internal base class <code>BaseIter</code>.</p> <p>However, since it does not implement <code>__len__</code> (contrary to other collections like <code>Seq</code> or <code>Vec</code>), the methods like <code>.then()</code>, <code>.ok_or()</code> etc. will always return <code>Some[Iter[T]], or</code>Ok[Iter[T]`.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>Any object that can be iterated over.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Iter[T](BaseIter[T], Iterator[T]):\n    \"\"\"A superset around Python's built-in `Iterator` Protocol, providing a rich set of functional programming tools.\n\n    Implements the `Iterator` Protocol from `collections.abc`, so it can be used as a standard iterator.\n\n    - An `Iterable` is any object capable of returning its members one at a time, permitting it to be iterated over in a for-loop.\n    - An `Iterator` is an object representing a stream of data; returned by calling `iter()` on an `Iterable`.\n    - Once an `Iterator` is exhausted, it cannot be reused or reset.\n\n    It's designed around lazy evaluation, allowing for efficient processing of large datasets.\n\n    Once an `Iter` is created, it can be transformed and manipulated using a variety of chainable methods.\n\n    However, keep in mind that `Iter` instances are single-use; once exhausted, they cannot be reused or reset.\n\n    If you need to reuse the data, consider collecting it into a collection first with `.collect()`.\n\n    You can always convert back to an `Iter` using `{Seq, Vec}.iter()` for free.\n\n    In general, avoid intermediate references when dealing with lazy iterators, and prioritize method chaining instead.\n\n    Note:\n        `Iter` inerhit from `Checkable` from it's internal base class `BaseIter`.\n\n        However, since it does not implement `__len__` (contrary to other collections like `Seq` or `Vec`), the methods like `.then()`, `.ok_or()` etc. will always return `Some[Iter[T]], or `Ok[Iter[T]`.\n\n    Args:\n        data (Iterable[T]): Any object that can be iterated over.\n    \"\"\"\n\n    _inner: Iterator[T]\n\n    __slots__ = (\"_inner\",)\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = iter(data)  # pyright: ignore[reportIncompatibleVariableOverride]\n\n    def __next__(self) -&gt; T:\n        return next(self._inner)\n\n    @classmethod\n    def empty(cls) -&gt; Self:\n        \"\"\"Create an empty `Iter`.\n\n        Make sure to specify the type when calling this method, e.g., `Iter[int].empty()`.\n\n        Otherwise, `T` will be inferred as `Any`.\n\n        Returns:\n            Self: A new empty Iter instance.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter.empty().collect()\n        Seq()\n\n        ```\n        \"\"\"\n        return cls(())\n\n    def next(self) -&gt; Option[T]:\n        \"\"\"Return the next element in the iterator.\n\n        Note:\n            The actual `.__next__()` method is conform to the Python `Iterator` Protocol, and is what will be actually called if you iterate over the `Iter` instance.\n\n            `Iter.next()` is a convenience method that wraps the result in an `Option` to handle exhaustion gracefully, for custom use cases.\n\n            Not only for typing, but for performance reasons, and coherence (iter(`Iter`) and iter(`Iter._inner`) wouldn't behave consistently otherwise).\n\n        Returns:\n            Option[T]: The next element in the iterator. `Some[T]`, or `NONE` if the iterator is exhausted.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; it = pc.Seq([1, 2, 3]).iter()\n        &gt;&gt;&gt; it.next().unwrap()\n        1\n        &gt;&gt;&gt; it.next().unwrap()\n        2\n\n        ```\n        \"\"\"\n        from ._option import Option\n\n        return Option(next(self, None))\n\n    @staticmethod\n    def once[V](value: V) -&gt; Iter[V]:\n        \"\"\"Create an `Iter` that yields a single value.\n\n        If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n        This can be considered the equivalent of `.insert()` but as a constructor.\n\n        Args:\n            value (V): The single value to yield.\n\n        Returns:\n            Iter[V]: An iterator yielding the specified value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter.once(42).collect()\n        Seq(42,)\n\n        ```\n        \"\"\"\n        return Iter((value,))\n\n    @staticmethod\n    def once_with[**P, R](\n        func: Callable[P, R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Iter[R]:\n        \"\"\"Create an `Iter`  that lazily generates a value exactly once by invoking the provided closure.\n\n        If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n        This can be considered the equivalent of `.insert()` but as a constructor.\n\n        Unlike `.once()`, this function will lazily generate the value on request.\n\n        Args:\n            func (Callable[P, R]): The single value to yield.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            Iter[R]: An iterator yielding the specified value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter.once(42).collect()\n        Seq(42,)\n\n        ```\n        \"\"\"\n        return Iter(func(*args, **kwargs) for _ in range(1))\n\n    @staticmethod\n    def from_count(start: int = 0, step: int = 1) -&gt; Iter[int]:\n        \"\"\"Create an infinite `Iterator` of evenly spaced values.\n\n        **Warning** ‚ö†Ô∏è\n            This creates an infinite iterator.\n            Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n        Args:\n            start (int): Starting value of the sequence. Defaults to 0.\n            step (int): Difference between consecutive values. Defaults to 1.\n\n        Returns:\n            Iter[int]: An iterator generating the sequence.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter.from_count(10, 2).take(3).collect()\n        Seq(10, 12, 14)\n\n        ```\n        \"\"\"\n        return Iter(itertools.count(start, step))\n\n    @staticmethod\n    def from_fn[R](f: Callable[[], Option[R]]) -&gt; Iter[R]:\n        \"\"\"Create an `Iter` from a nullary generator function.\n\n        The callable must return:\n\n        - `Some(value)` to yield a value\n        - `NONE` to stop\n\n\n        Args:\n            f (Callable[[], Option[R]]): Callable that returns the next item wrapped in `Option`.\n\n        Returns:\n            Iter[R]: An iterator yielding values produced by **f**.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; counter = 0\n        &gt;&gt;&gt; def gen() -&gt; pc.Option[int]:\n        ...     global counter\n        ...     counter += 1\n        ...     return pc.Some(counter) if counter &lt; 6 else pc.NONE\n        &gt;&gt;&gt; pc.Iter.from_fn(gen).collect()\n        Seq(1, 2, 3, 4, 5)\n\n        ```\n        \"\"\"\n\n        def _from_fn() -&gt; Iterator[R]:\n            while True:\n                item = f()\n                if item.is_none():\n                    return\n                yield item.unwrap()\n\n        return Iter(_from_fn())\n\n    @staticmethod\n    def successors[U](first: Option[U], succ: Callable[[U], Option[U]]) -&gt; Iter[U]:\n        \"\"\"Create an iterator of successive values computed from the previous one.\n\n        The iterator yields `first` (if it is `Some`), then repeatedly applies **succ** to the\n        previous yielded value until it returns `NONE`.\n\n        Args:\n            first (Option[U]): Initial item.\n            succ (Callable[[U], Option[U]]): Successor function.\n\n        Returns:\n            Iter[U]: Iterator yielding `first` and its successors.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def next_pow10(x: int) -&gt; pc.Option[int]:\n        ...     return pc.Some(x * 10) if x &lt; 10_000 else pc.NONE\n        &gt;&gt;&gt; pc.Iter.successors(pc.Some(1), next_pow10).collect()\n        Seq(1, 10, 100, 1000, 10000)\n\n        ```\n        \"\"\"\n\n        def _successors() -&gt; Iterator[U]:\n            current = first\n            while current.is_some():\n                value = current.unwrap()\n                yield value\n                current = succ(value)\n\n        return Iter(_successors())\n\n    def collect[R: Collection[Any]](\n        self, collector: Callable[[Iterator[T]], R] = Seq[T]\n    ) -&gt; R:\n        \"\"\"Transforms an `Iter` into a collection.\n\n        The most basic pattern in which collect() is used is to turn one collection into another.\n\n        You take a collection, call `iter()` on it, do a bunch of transformations, and then `collect()` at the end.\n\n        You can specify the target collection type by providing a **collector** function or type.\n\n        This can be any `Callable` that takes an `Iterator[T]` and returns a `Collection[T]` of those types.\n\n        Note:\n            This can be tought as `.into()` with a default value (`Seq[T]`), and a different constraint (`Collection[Any]`).\n            However, the runtime behavior is identical in both cases: pass **self** to the provided function, return the result.\n\n        Args:\n            collector (Callable[[Iterator[T]], R]): Function|type that defines the target collection. Defaults to `Seq[T]`. `R` is constrained to a `Collection`.\n\n        Returns:\n            R: A materialized collection containing the collected elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(range(5)).collect()\n        Seq(0, 1, 2, 3, 4)\n        &gt;&gt;&gt; iterator = pc.Iter((1, 2, 3))\n        &gt;&gt;&gt; iterator._inner.__class__.__name__\n        'tuple_iterator'\n        &gt;&gt;&gt; mapped = iterator.map(lambda x: x * 2)\n        &gt;&gt;&gt; mapped._inner.__class__.__name__\n        'map'\n        &gt;&gt;&gt; mapped.collect()\n        Seq(2, 4, 6)\n        &gt;&gt;&gt; # iterator is now exhausted\n        &gt;&gt;&gt; iterator.collect()\n        Seq()\n        &gt;&gt;&gt; pc.Iter(range(5)).collect(list)\n        [0, 1, 2, 3, 4]\n        &gt;&gt;&gt; pc.Iter(range(5)).collect(pc.Vec)\n        Vec(0, 1, 2, 3, 4)\n        &gt;&gt;&gt; iterator = pc.Iter([1, 2, 3])\n        &gt;&gt;&gt; iterator._inner.__class__.__name__\n        'list_iterator'\n\n        ```\n        \"\"\"\n        return collector(self._inner)\n\n    def try_collect[U](self: TryIter[U]) -&gt; Option[Vec[U]]:\n        \"\"\"Fallibly transforms **self** into a `Vec`, short circuiting if a failure is encountered.\n\n        `try_collect()` is a variation of `collect()` that allows fallible conversions during collection.\n\n        Its main use case is simplifying conversions from iterators yielding `Option[T]`, `Result[T, E]` or `U | None` into `Option[Sequence[T]]`.\n\n        Also, if a failure is encountered during `try_collect()`, the iterator is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure.\n\n        See the last example below for an example of how this works.\n\n        Note:\n            This method return `Vec[U]` instead of `Seq[U]` because the underlying data structure must be mutable in order to build up the collection.\n\n        Returns:\n            Option[Vec[U]]: `Some[Vec[U]]` if all elements were successfully collected, or `NONE` if a failure was encountered.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Successfully collecting an iterator of Option[int] into Option[Vec[int]]:\n        &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.Some(3)]).try_collect()\n        Some(Vec(1, 2, 3))\n        &gt;&gt;&gt; # Failing to collect in the same way:\n        &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.NONE, pc.Some(3)]).try_collect()\n        NONE\n        &gt;&gt;&gt; # A similar example, but with Result:\n        &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Ok(2), pc.Ok(3)]).try_collect()\n        Some(Vec(1, 2, 3))\n        &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Err(\"error\"), pc.Ok(3)]).try_collect()\n        NONE\n        &gt;&gt;&gt; def external_fn(x: int) -&gt; int | None:\n        ...     if x % 2 == 0:\n        ...         return x\n        ...     return None\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map(external_fn).try_collect()\n        NONE\n        &gt;&gt;&gt; # Demonstrating that the iterator remains usable after a failure:\n        &gt;&gt;&gt; it = pc.Iter([pc.Some(1), pc.NONE, pc.Some(3), pc.Some(4)])\n        &gt;&gt;&gt; it.try_collect()\n        NONE\n        &gt;&gt;&gt; it.try_collect()\n        Some(Vec(3, 4))\n\n        ```\n        \"\"\"\n        from ._option import NONE, Option, Some\n        from ._result import Result\n\n        collected = Vec[U].new()\n\n        for item in self._inner:\n            if item is None:\n                return NONE\n            match item:\n                case Result():\n                    if item.is_err():\n                        return NONE\n                    collected.append(item.unwrap())  # pyright: ignore[reportUnknownArgumentType]\n                case Option():\n                    if item.is_none():\n                        return NONE\n                    collected.append(item.unwrap())  # pyright: ignore[reportUnknownArgumentType]\n                case _ as plain_value:\n                    collected.append(plain_value)\n        return Some(collected)\n\n    def for_each[**P](\n        self,\n        func: Callable[Concatenate[T, P], Any],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; None:\n        \"\"\"Consume the Iterator by applying a function to each element in the iterable.\n\n        Is a terminal operation, and is useful for functions that have side effects,\n        or when you want to force evaluation of a lazy iterable.\n\n        Args:\n            func (Callable[Concatenate[T, P], Any]): Function to apply to each element.\n            *args (P.args): Positional arguments for the function.\n            **kwargs (P.kwargs): Keyword arguments for the function.\n\n        Returns:\n            None: This is a terminal operation with no return value.\n\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).iter().for_each(lambda x: print(x + 1))\n        2\n        3\n        4\n\n        ```\n        \"\"\"\n        for v in self._inner:\n            func(v, *args, **kwargs)\n\n    @overload\n    def for_each_star[R](\n        self: Iter[tuple[Any]],\n        func: Callable[[Any], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, R](\n        self: Iter[tuple[T1, T2]],\n        func: Callable[[T1, T2], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, R](\n        self: Iter[tuple[T1, T2, T3]],\n        func: Callable[[T1, T2, T3], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, R](\n        self: Iter[tuple[T1, T2, T3, T4]],\n        func: Callable[[T1, T2, T3, T4], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5]],\n        func: Callable[[T1, T2, T3, T4, T5], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6]],\n        func: Callable[[T1, T2, T3, T4, T5, T6], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, T8, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R],\n    ) -&gt; None: ...\n    def for_each_star[U: Iterable[Any], R](\n        self: Iter[U],\n        func: Callable[..., R],\n    ) -&gt; None:\n        \"\"\"Consume the `Iterator` by applying a function to each unpacked item in the iterable.\n\n        Is a terminal operation, and is useful for functions that have side effects,\n        or when you want to force evaluation of a lazy iterable.\n\n        Each item yielded by the iterator is expected to be an iterable itself (e.g., a tuple or list),\n        and its elements are unpacked as arguments to the provided function.\n\n        This is often used after methods like `zip()` or `enumerate()` that yield tuples.\n\n        Args:\n            func (Callable[..., R]): Function to apply to each unpacked element.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([(1, 2), (3, 4)]).for_each_star(lambda x, y: print(x + y))\n        3\n        7\n\n        ```\n        \"\"\"\n        for item in self._inner:\n            func(*item)\n\n    def try_for_each[E](self, f: Callable[[T], Result[Any, E]]) -&gt; Result[None, E]:\n        \"\"\"An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.\n\n        This can also be thought of as the fallible form of `.for_each()`.\n\n        Args:\n            f (Callable[[T], Result[Any, E]]): A function that takes an item of type `T` and returns a `Result`.\n\n        Returns:\n            Result[None, E]: Returns `Ok(None)` if all applications of **f** were successful (i.e., returned `Ok`), or the first error `E` encountered.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def validate_positive(n: int) -&gt; pc.Result[None, str]:\n        ...     if n &gt; 0:\n        ...         return pc.Ok(None)\n        ...     return pc.Err(f\"Value {n} is not positive\")\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).try_for_each(validate_positive)\n        Ok(None)\n        &gt;&gt;&gt; # Short-circuit on first error:\n        &gt;&gt;&gt; pc.Iter([1, 2, -1, 4]).try_for_each(validate_positive)\n        Err('Value -1 is not positive')\n\n        ```\n        \"\"\"\n        from ._result import Ok\n\n        for item in self._inner:\n            res = f(item)\n            if res.is_err():\n                return res\n        return Ok(None)\n\n    def array_chunks(self, size: int) -&gt; Iter[Iter[T]]:\n        \"\"\"Yield subiterators (chunks) that each yield a fixed number elements, determined by size.\n\n        The last chunk will be shorter if there are not enough elements.\n\n        Args:\n            size (int): Number of elements in each chunk.\n\n        Returns:\n            Iter[Iter[T]]: An iterable of iterators, each yielding n elements.\n\n        If the sub-iterables are read in order, the elements of *iterable*\n        won't be stored in memory.\n\n        If they are read out of order, :func:`itertools.tee` is used to cache\n        elements as necessary.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; all_chunks = pc.Iter.from_count().array_chunks(4)\n        &gt;&gt;&gt; c_1, c_2, c_3 = all_chunks.next(), all_chunks.next(), all_chunks.next()\n        &gt;&gt;&gt; c_2.unwrap().collect()  # c_1's elements have been cached; c_3's haven't been\n        Seq(4, 5, 6, 7)\n        &gt;&gt;&gt; c_1.unwrap().collect()\n        Seq(0, 1, 2, 3)\n        &gt;&gt;&gt; c_3.unwrap().collect()\n        Seq(8, 9, 10, 11)\n        &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n        Seq(Seq(1, 2, 3), Seq(4, 5, 6))\n        &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6, 7, 8]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n        Seq(Seq(1, 2, 3), Seq(4, 5, 6), Seq(7, 8))\n\n        ```\n        \"\"\"\n        from collections import deque\n        from contextlib import suppress\n\n        def _chunks(data: Iterable[T], size: int) -&gt; Iterator[Iter[T]]:\n            def _ichunk(\n                iterator: Iterator[T], n: int\n            ) -&gt; tuple[Iterator[T], Callable[[int], int]]:\n                cache: deque[T] = deque()\n                chunk = itertools.islice(iterator, n)\n\n                def generator() -&gt; Iterator[T]:\n                    with suppress(StopIteration):\n                        while True:\n                            if cache:\n                                yield cache.popleft()\n                            else:\n                                yield next(chunk)\n\n                def materialize_next(n: int) -&gt; int:\n                    to_cache = n - len(cache)\n\n                    # materialize up to n\n                    if to_cache &gt; 0:\n                        cache.extend(itertools.islice(chunk, to_cache))\n\n                    # return number materialized up to n\n                    return min(n, len(cache))\n\n                return (generator(), materialize_next)\n\n            iterator = iter(data)\n            while True:\n                # Create new chunk\n                chunk, materialize_next = _ichunk(iterator, size)\n\n                # Check to see whether we're at the end of the source iterable\n                if not materialize_next(size):\n                    return\n\n                yield self.__class__(chunk)\n                materialize_next(size)\n\n        return Iter(_chunks(self._inner, size))\n\n    @overload\n    def flatten[U](self: Iter[KeysView[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Iterable[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Generator[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[ValuesView[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Iterator[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Collection[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Sequence[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[list[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[tuple[U, ...]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Iter[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Seq[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Set[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten(self: Iter[range]) -&gt; Iter[int]: ...\n    def flatten[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Any]:\n        \"\"\"Flatten one level of nesting and return a new Iterable wrapper.\n\n        This is a shortcut for `.apply(itertools.chain.from_iterable)`.\n\n        Returns:\n            Iter[Any]: An iterable of flattened elements.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([[1, 2], [3]]).flatten().collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        return Iter(itertools.chain.from_iterable(self._inner))\n\n    def flat_map[R](self, func: Callable[[T], Iterable[R]]) -&gt; Iter[R]:\n        \"\"\"Creates an iterator that applies a function to each element of the original iterator and flattens the result.\n\n        This is useful when the **func** you want to pass to `.map()` itself returns an iterable, and you want to avoid having nested iterables in the output.\n\n        This is equivalent to calling `.map(func).flatten()`.\n\n        Args:\n            func (Callable[[T], Iterable[R]]): Function to apply to each element.\n\n        Returns:\n            Iter[R]: An iterable of flattened transformed elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).flat_map(lambda x: range(x)).collect()\n        Seq(0, 0, 1, 0, 1, 2)\n\n        ```\n        \"\"\"\n        return Iter(itertools.chain.from_iterable(map(func, self._inner)))\n\n    def unique_to_each[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Iter[U]]:\n        \"\"\"Return the elements from each of the iterators that aren't in the other iterators.\n\n        It is assumed that the elements of each iterable are hashable.\n\n        **Credits**\n\n            more_itertools.unique_to_each\n\n        Returns:\n            Iter[Iter[U]]: An iterator of iterators, each containing the unique elements from the corresponding input iterable.\n\n        For example, suppose you have a set of packages, each with a set of dependencies:\n\n        **{'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}**\n\n        If you remove one package, which dependencies can also be removed?\n\n        If pkg_1 is removed, then A is no longer necessary - it is not associated with pkg_2 or pkg_3.\n\n        Similarly, C is only needed for pkg_2, and D is only needed for pkg_3:\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = ({\"A\", \"B\"}, {\"B\", \"C\"}, {\"B\", \"D\"})\n        &gt;&gt;&gt; pc.Iter(data).unique_to_each().map(lambda x: x.into(list)).collect()\n        Seq(['A'], ['C'], ['D'])\n\n        ```\n\n        If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output.\n\n        Input order is preserved:\n        ```python\n        &gt;&gt;&gt; data = (\"mississippi\", \"missouri\")\n        &gt;&gt;&gt; pc.Seq(data).iter().unique_to_each().map(lambda x: x.into(list)).collect()\n        Seq(['p', 'p'], ['o', 'u', 'r'])\n\n        ```\n        \"\"\"\n        from collections import Counter\n\n        pool: tuple[Iterable[U], ...] = tuple(self._inner)\n        counts: Counter[U] = Counter(itertools.chain.from_iterable(map(set, pool)))\n        uniques: set[U] = {element for element in counts if counts[element] == 1}\n\n        return Iter((Iter(filter(uniques.__contains__, it))) for it in pool)\n\n    def split_into(self, *sizes: Option[int]) -&gt; Iter[Iter[T]]:\n        \"\"\"Yield a list of sequential items from iterable of length 'n' for each integer 'n' in sizes.\n\n        Args:\n            *sizes (Option[int]): `Some` integers specifying the sizes of each chunk. Use `NONE` for the remainder.\n\n        Returns:\n            Iter[Iter[T]]: An iterator of iterators, each containing a chunk of the original iterable.\n\n        If the sum of sizes is smaller than the length of iterable, then the remaining items of iterable will not be returned.\n\n        If the sum of sizes is larger than the length of iterable:\n\n        - fewer items will be returned in the iteration that overruns the iterable\n        - further lists will be empty\n\n        When a `NONE` object is encountered in sizes, the returned list will contain items up to the end of iterable the same way that itertools.slice does.\n\n        split_into can be useful for grouping a series of items where the sizes of the groups are not uniform.\n\n        An example would be where in a row from a table:\n\n        - multiple columns represent elements of the same feature (e.g. a point represented by x,y,z)\n        - the format is not the same for all columns.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _get_results(x: pc.Iter[pc.Iter[int]]) -&gt; pc.Seq[pc.Seq[int]]:\n        ...    return x.map(lambda x: x.collect()).collect()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6]\n        &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(1), pc.Some(2), pc.Some(3)).into(_get_results)\n        Seq(Seq(1,), Seq(2, 3), Seq(4, 5, 6))\n        &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3)).into(_get_results)\n        Seq(Seq(1, 2), Seq(3, 4, 5))\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).split_into(pc.Some(1), pc.Some(2), pc.Some(3), pc.Some(4)).into(_get_results)\n        Seq(Seq(1,), Seq(2, 3), Seq(4,), Seq())\n        &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n        &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3), pc.NONE).into(_get_results)\n        Seq(Seq(1, 2), Seq(3, 4, 5), Seq(6, 7, 8, 9, 0))\n\n        ```\n        \"\"\"\n\n        def _split_into(data: Iterator[T]) -&gt; Iterator[Iter[T]]:\n            \"\"\"Credits: more_itertools.split_into.\"\"\"\n            for size in sizes:\n                if size.is_none():\n                    yield self.__class__(data)\n                    return\n                else:\n                    yield self.__class__(itertools.islice(data, size.unwrap()))\n\n        return Iter(_split_into(self._inner))\n\n    def split_when(\n        self,\n        predicate: Callable[[T, T], bool],\n        max_split: int = -1,\n    ) -&gt; Iter[Iter[T]]:\n        \"\"\"Split iterable into pieces based on the output of a predicate function.\n\n        Args:\n            predicate (Callable[[T, T], bool]): Function that takes successive pairs of items and returns True if the iterable should be split.\n            max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n\n        Returns:\n            Iter[Iter[T]]: An iterator of iterators of items.\n\n        At most *max_split* splits are done.\n\n        If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n        The example below shows how to find runs of increasing numbers, by splitting the iterable when element i is larger than element i + 1.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Seq([1, 2, 3, 3, 2, 5, 2, 4, 2])\n        &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y).map(lambda x: x.collect()).collect()\n        Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4), Seq(2,))\n        &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y, max_split=2).map(lambda x: x.collect()).collect()\n        Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4, 2))\n\n        ```\n        \"\"\"\n\n        def _split_when(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n            \"\"\"Credits: more_itertools.split_when.\"\"\"\n            if max_split == 0:\n                yield self\n                return\n            try:\n                cur_item = next(data)\n            except StopIteration:\n                return\n\n            buf = [cur_item]\n            for next_item in data:\n                if predicate(cur_item, next_item):\n                    yield Iter(buf)\n                    if max_split == 1:\n                        yield Iter((next_item, *data))\n                        return\n                    buf = []\n                    max_split -= 1\n\n                buf.append(next_item)\n                cur_item = next_item\n\n            yield Iter(buf)\n\n        return Iter(_split_when(self._inner, max_split))\n\n    def split_at(\n        self,\n        predicate: Callable[[T], bool],\n        max_split: int = -1,\n        *,\n        keep_separator: bool = False,\n    ) -&gt; Iter[Iter[T]]:\n        \"\"\"Yield iterators of items from iterable, where each iterator is delimited by an item where `predicate` returns True.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine the split points.\n            max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n            keep_separator (bool): Whether to include the separator in the output. Defaults to False.\n\n        Returns:\n            Iter[Iter[T]]: An iterator of iterators, each containing a segment of the original iterable.\n\n        By default, the delimiting items are not included in the output.\n\n        To include them, set *keep_separator* to `True`.\n        At most *max_split* splits are done.\n\n        If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _to_res(x: pc.Iter[pc.Iter[str]]) -&gt; pc.Seq[pc.Seq[str]]:\n        ...     return x.map(lambda x: x.into(list)).collect()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(lambda x: x == \"b\").into(_to_res)\n        Seq(['a'], ['c', 'd', 'c'], ['a'])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1).into(_to_res)\n        Seq([0], [2], [4], [6], [8], [])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1, max_split=2).into(_to_res)\n        Seq([0], [2], [4, 5, 6, 7, 8, 9])\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def cond(x: str) -&gt; bool:\n        ...     return x == \"b\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(cond, keep_separator=True).into(_to_res)\n        Seq(['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a'])\n\n        ```\n        \"\"\"\n\n        def _split_at(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n            \"\"\"Credits: more_itertools.split_at.\"\"\"\n            if max_split == 0:\n                yield self\n                return\n\n            buf: list[T] = []\n            for item in data:\n                if predicate(item):\n                    yield self.__class__(buf)\n                    if keep_separator:\n                        yield self.__class__((item,))\n                    if max_split == 1:\n                        yield self.__class__(data)\n                        return\n                    buf = []\n                    max_split -= 1\n                else:\n                    buf.append(item)\n            yield self.__class__(buf)\n\n        return Iter(_split_at(self._inner, max_split))\n\n    def split_after(\n        self,\n        predicate: Callable[[T], bool],\n        max_split: int = -1,\n    ) -&gt; Iter[Iter[T]]:\n        \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine the split points.\n            max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n\n        Returns:\n            Iter[Iter[T]]: An iterable of lists of items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"one1two2\").split_after(str.isdigit).map(list).collect()\n        Seq(['o', 'n', 'e', '1'], ['t', 'w', 'o', '2'])\n\n        &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n        ...     return n % 3 == 0\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond).map(list).collect()\n        Seq([0], [1, 2, 3], [4, 5, 6], [7, 8, 9])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond, max_split=2).map(list).collect()\n        Seq([0], [1, 2, 3], [4, 5, 6, 7, 8, 9])\n\n        ```\n        \"\"\"\n\n        def _split_after(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n            \"\"\"Credits: more_itertools.split_after.\"\"\"\n            if max_split == 0:\n                yield self.__class__(data)\n                return\n\n            buf: list[T] = []\n            for item in data:\n                buf.append(item)\n                if predicate(item) and buf:\n                    yield self.__class__(buf)\n                    if max_split == 1:\n                        buf = list(data)\n                        if buf:\n                            yield self.__class__(buf)\n                        return\n                    buf = []\n                    max_split -= 1\n            if buf:\n                yield self.__class__(buf)\n\n        return Iter(_split_after(self._inner, max_split))\n\n    def split_before(\n        self,\n        predicate: Callable[[T], bool],\n        max_split: int = -1,\n    ) -&gt; Iter[Iter[T]]:\n        \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine the split points.\n            max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n\n        Returns:\n            Iter[Iter[T]]: An iterable of lists of items.\n\n\n        At most *max_split* are done.\n\n\n        If *max_split* is not specified or -1, then there is no limit on the number of splits:\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_before(lambda x: x == \"b\").map(list).collect()\n        Seq(['a'], ['b', 'c', 'd', 'c'], ['b', 'a'])\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n        ...     return n % 2 == 1\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond).map(list).collect()\n        Seq([0], [1, 2], [3, 4], [5, 6], [7, 8], [9])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond, max_split=2).map(list).collect()\n        Seq([0], [1, 2], [3, 4, 5, 6, 7, 8, 9])\n\n        ```\n        \"\"\"\n\n        def _split_before(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n            \"\"\"Credits: more_itertools.split_before.\"\"\"\n            if max_split == 0:\n                yield self.__class__(data)\n                return\n\n            buf: list[T] = []\n            for item in data:\n                if predicate(item) and buf:\n                    yield self.__class__(buf)\n                    if max_split == 1:\n                        yield self.__class__([item, *data])\n                        return\n                    buf = []\n                    max_split -= 1\n                buf.append(item)\n            if buf:\n                yield self.__class__(buf)\n\n        return Iter(_split_before(self._inner, max_split))\n\n    def find_map[R](self, func: Callable[[T], Option[R]]) -&gt; Option[R]:\n        \"\"\"Applies function to the elements of the `Iterator` and returns the first Some(R) result.\n\n        `Iter.find_map(f)` is equivalent to `Iter.filter_map(f).next()`.\n\n        Args:\n            func (Callable[[T], Option[R]]): Function to apply to each element, returning an `Option[R]`.\n\n        Returns:\n            Option[R]: The first `Some(R)` result from applying `func`, or `NONE` if no such result is found.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Option[int]:\n        ...     try:\n        ...         return pc.Some(int(s))\n        ...     except ValueError:\n        ...         return pc.NONE\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([\"lol\", \"NaN\", \"2\", \"5\"]).find_map(_parse)\n        Some(2)\n\n        ```\n        \"\"\"\n        return self.filter_map(func).next()\n\n    # map -----------------------------------------------------------------\n\n    def map[R](self, func: Callable[[T], R]) -&gt; Iter[R]:\n        \"\"\"Apply a function to each element of the iterable.\n\n        If you are good at thinking in types, you can think of map() like this:\n            If you have an iterator that gives you elements of some type A, and you want an iterator of some other type B, you can use map(),\n            passing a closure that takes an A and returns a B.\n\n        map() is conceptually similar to a for loop.\n\n        However, as map() is lazy, it is best used when you are already working with other iterators.\n\n        If you are doing some sort of looping for a side effect, it is considered more idiomatic to use `for_each` than map().\n\n        Args:\n            func (Callable[[T], R]): Function to apply to each element.\n\n        Returns:\n            Iter[R]: An iterator of transformed elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).map(lambda x: x + 1).collect()\n        Seq(2, 3)\n\n        ```\n        \"\"\"\n        return Iter(map(func, self._inner))\n\n    @overload\n    def map_star[R](\n        self: Iter[tuple[Any]],\n        func: Callable[[Any], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, R](\n        self: Iter[tuple[T1, T2]],\n        func: Callable[[T1, T2], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, R](\n        self: Iter[tuple[T1, T2, T3]],\n        func: Callable[[T1, T2, T3], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, R](\n        self: Iter[tuple[T1, T2, T3, T4]],\n        func: Callable[[T1, T2, T3, T4], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5]],\n        func: Callable[[T1, T2, T3, T4, T5], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6]],\n        func: Callable[[T1, T2, T3, T4, T5, T6], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, T8, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R],\n    ) -&gt; Iter[R]: ...\n    def map_star[U: Iterable[Any], R](\n        self: Iter[U],\n        func: Callable[..., R],\n    ) -&gt; Iter[R]:\n        \"\"\"Applies a function to each element.where each element is an iterable.\n\n        Unlike `.map()`, which passes each element as a single argument,\n        `.starmap()` unpacks each element into positional arguments for the function.\n\n        In short, for each `element` in the sequence, it computes `func(*element)`.\n\n        - Use map_star when the performance matters (it is faster).\n        - Use map with unpacking when readability matters (the types can be inferred).\n\n        Args:\n            func (Callable[..., R]): Function to apply to unpacked elements.\n\n        Returns:\n            Iter[R]: An iterable of results from applying the function to unpacked elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def make_sku(color: str, size: str) -&gt; str:\n        ...     return f\"{color}-{size}\"\n        &gt;&gt;&gt; data = pc.Seq([\"blue\", \"red\"])\n        &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map_star(make_sku).collect()\n        Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n        &gt;&gt;&gt; # This is equivalent to:\n        &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map(lambda x: make_sku(*x)).collect()\n        Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n\n        ```\n        \"\"\"\n        return Iter(itertools.starmap(func, self._inner))\n\n    def map_while[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n        \"\"\"Creates an iterator that both yields elements based on a predicate and maps.\n\n        `map_while()` takes a closure as an argument. It will call this closure on each element of\n        the iterator, and yield elements while it returns `Some(_)`.\n\n        After `NONE` is returned, `map_while()` stops and the rest of the elements are ignored.\n\n        Args:\n            func (Callable[[T], Option[R]]): Function to apply to each element that returns `Option[R]`.\n\n        Returns:\n            Iter[R]: An iterator of transformed elements until `NONE` is encountered.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def checked_div(x: int) -&gt; pc.Option[int]:\n        ...     return pc.Some(16 // x) if x != 0 else pc.NONE\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = pc.Iter([-1, 4, 0, 1])\n        &gt;&gt;&gt; data.map_while(checked_div).collect()\n        Seq(-16, 4)\n        &gt;&gt;&gt; data = pc.Iter([0, 1, 2, -3, 4, 5, -6])\n        &gt;&gt;&gt; # Convert to positive ints, stop at first negative\n        &gt;&gt;&gt; data.map_while(lambda x: pc.Some(x) if x &gt;= 0 else pc.NONE).collect()\n        Seq(0, 1, 2)\n\n        ```\n        \"\"\"\n\n        def _gen() -&gt; Generator[R]:\n            for opt in map(func, self._inner):\n                if opt.is_none():\n                    return\n                yield opt.unwrap()\n\n        return Iter(_gen())\n\n    def repeat(\n        self,\n        n: int,\n        factory: Callable[[Iterable[T]], Sequence[T]] = tuple,\n    ) -&gt; Iter[Iterable[T]]:\n        \"\"\"Repeat the entire iterable n times (as elements).\n\n        Args:\n            n (int): Number of repetitions.\n            factory (Callable[[Iterable[T]], Sequence[T]]): Factory to create the repeated Sequence (default: tuple).\n\n        Returns:\n            Iter[Iterable[T]]: An iterable of repeated sequences.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).repeat(2).collect()\n        Seq((1, 2), (1, 2))\n        &gt;&gt;&gt; pc.Iter([1, 2]).repeat(3, list).collect()\n        Seq([1, 2], [1, 2], [1, 2])\n\n        ```\n        \"\"\"\n        return Iter(itertools.repeat(factory(self._inner), n))\n\n    def accumulate(\n        self, func: Callable[[T, T], T], initial: T | None = None\n    ) -&gt; Iter[T]:\n        \"\"\"Return an `Iter` of accumulated binary function results.\n\n        In principle, `.accumulate()` is similar to `.fold()` if you provide it with the same binary function.\n\n        However, instead of returning the final accumulated result, it returns an `Iter` that yields the current value `T` of the accumulator for each iteration.\n\n        In other words, the last element yielded by `.accumulate()` is what would have been returned by `.fold()` if it had been used instead.\n\n        Args:\n            func (Callable[[T, T], T]): A binary function to apply cumulatively.\n            initial (T | None): Optional initial value to start the accumulation. Defaults to None.\n\n        Returns:\n            Iter[T]: A new Iterable wrapper with accumulated results.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a + b, 0).collect()\n        Seq(0, 1, 3, 6)\n        &gt;&gt;&gt; # The final accumulated result is the same as fold:\n        &gt;&gt;&gt; pc.Iter((1,2,3)).fold(0, lambda a, b: a + b)\n        6\n        &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a * b).collect()\n        Seq(1, 2, 6)\n\n\n        ```\n        \"\"\"\n        return Iter(itertools.accumulate(self._inner, func, initial=initial))\n\n    def scan[U](self, initial: U, func: Callable[[U, T], Option[U]]) -&gt; Iter[U]:\n        \"\"\"Transform elements by sharing state between iterations.\n\n        `scan` takes two arguments:\n            - an **initial** value which seeds the internal state\n            - a **func** with two arguments\n\n        The first being a reference to the internal state and the second an iterator element.\n\n        The **func** can assign to the internal state to share state between iterations.\n\n        On iteration, the **func** will be applied to each element of the iterator and the return value from the func, an Option, is returned by the next method.\n\n        Thus the **func** can return `Some(value)` to yield value, or None to end the iteration.\n\n        Args:\n            initial (U): Initial state.\n            func (Callable[[U, T], Option[U]]): Function that takes the current state and an item, and returns an Option.\n\n        Returns:\n            Iter[U]: An iterable of the yielded values.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def accumulate_until_limit(state: int, item: int) -&gt; pc.Option[int]:\n        ...     new_state = state + item\n        ...     match new_state:\n        ...         case _ if new_state &lt;= 10:\n        ...             return pc.Some(new_state)\n        ...         case _:\n        ...             return pc.NONE\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).scan(0, accumulate_until_limit).collect()\n        Seq(1, 3, 6, 10)\n\n        ```\n        \"\"\"\n\n        def gen(data: Iterable[T]) -&gt; Iterator[U]:\n            current: U = initial\n            for item in data:\n                res = func(current, item)\n                if res.is_none():\n                    break\n                current = res.unwrap()\n                yield res.unwrap()\n\n        return Iter(gen(self._inner))\n\n    # filters ------------------------------------------------------------\n    @overload\n    def filter[U](self, func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]: ...\n    @overload\n    def filter(self, func: Callable[[T], bool]) -&gt; Iter[T]: ...\n    def filter[U](self, func: Callable[[T], bool | TypeIs[U]]) -&gt; Iter[T] | Iter[U]:\n        \"\"\"Creates an `Iter` which uses a closure to determine if an element should be yielded.\n\n        Given an element the closure must return true or false.\n\n        The returned `Iter` will yield only the elements for which the closure returns true.\n\n        The closure can return a `TypeIs` to narrow the type of the returned iterable.\n\n        This won't have any runtime effect, but allows for better type inference.\n\n        Note:\n            `Iter.filter(f).next()` is equivalent to `Iter.find(f)`.\n\n        Args:\n            func (Callable[[T], bool | TypeIs[U]]): Function to evaluate each item.\n\n        Returns:\n            Iter[T] | Iter[U]: An iterable of the items that satisfy the predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = (1, 2, 3)\n        &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).collect()\n        Seq(2, 3)\n        &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).next()\n        Some(2)\n        &gt;&gt;&gt; pc.Iter(data).find(lambda x: x &gt; 1)\n        Some(2)\n\n        ```\n        \"\"\"\n        return Iter(filter(func, self._inner))\n\n    @overload\n    def filter_star(\n        self: Iter[tuple[Any]],\n        func: Callable[[Any], bool],\n    ) -&gt; Iter[tuple[Any]]: ...\n    @overload\n    def filter_star[T1, T2](\n        self: Iter[tuple[T1, T2]],\n        func: Callable[[T1, T2], bool],\n    ) -&gt; Iter[tuple[T1, T2]]: ...\n    @overload\n    def filter_star[T1, T2, T3](\n        self: Iter[tuple[T1, T2, T3]],\n        func: Callable[[T1, T2, T3], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4](\n        self: Iter[tuple[T1, T2, T3, T4]],\n        func: Callable[[T1, T2, T3, T4], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5](\n        self: Iter[tuple[T1, T2, T3, T4, T5]],\n        func: Callable[[T1, T2, T3, T4, T5], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6]],\n        func: Callable[[T1, T2, T3, T4, T5, T6], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7, T8](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7, T8, T9](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]]: ...\n    def filter_star[U: Iterable[Any]](\n        self: Iter[U],\n        func: Callable[..., bool],\n    ) -&gt; Iter[U]:\n        \"\"\"Creates an `Iter` which uses a closure to determine if an element should be yielded, where each element is an iterable.\n\n        Unlike `.filter()`, which passes each element as a single argument, `.filter_star()` unpacks each element into positional arguments for the function.\n\n        In short, for each `element` in the sequence, it computes `func(*element)`.\n\n        This is useful after using methods like `zip`, `product`, or `enumerate` that yield tuples.\n\n        Args:\n            func (Callable[..., bool]): Function to evaluate unpacked elements.\n\n        Returns:\n            Iter[U]: An iterable of the items that satisfy the predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Seq([\"apple\", \"banana\", \"cherry\", \"date\"])\n        &gt;&gt;&gt; data.iter().enumerate().filter_star(lambda index, fruit: index % 2 == 0).map_star(lambda index, fruit: fruit.title()).collect()\n        Seq('Apple', 'Cherry')\n\n        ```\n        \"\"\"\n        return Iter(filter(lambda x: func(*x), self._inner))\n\n    @overload\n    def filter_false[U](self, func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]: ...\n    @overload\n    def filter_false(self, func: Callable[[T], bool]) -&gt; Iter[T]: ...\n    def filter_false[U](\n        self, func: Callable[[T], bool | TypeIs[U]]\n    ) -&gt; Iter[T] | Iter[U]:\n        \"\"\"Return elements for which func is false.\n\n        Args:\n            func (Callable[[T], bool]): Function to evaluate each item.\n\n        Returns:\n            Iter[T]: An iterable of the items that do not satisfy the predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).filter_false(lambda x: x &gt; 1).collect()\n        Seq(1,)\n\n        ```\n        \"\"\"\n        return Iter(itertools.filterfalse(func, self._inner))\n\n    def take_while(self, predicate: Callable[[T], bool]) -&gt; Iter[T]:\n        \"\"\"Take items while predicate holds.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to evaluate each item.\n\n        Returns:\n            Iter[T]: An iterable of the items taken while the predicate is true.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 0)).take_while(lambda x: x &gt; 0).collect()\n        Seq(1, 2)\n\n        ```\n        \"\"\"\n        return Iter(itertools.takewhile(predicate, self._inner))\n\n    def skip_while(self, predicate: Callable[[T], bool]) -&gt; Iter[T]:\n        \"\"\"Drop items while predicate holds.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to evaluate each item.\n\n        Returns:\n            Iter[T]: An iterable of the items after skipping those for which the predicate is true.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 0)).skip_while(lambda x: x &gt; 0).collect()\n        Seq(0,)\n\n        ```\n        \"\"\"\n        return Iter(itertools.dropwhile(predicate, self._inner))\n\n    def compress(self, *selectors: bool) -&gt; Iter[T]:\n        \"\"\"Filter elements using a boolean selector iterable.\n\n        Args:\n            *selectors (bool): Boolean values indicating which elements to keep.\n\n        Returns:\n            Iter[T]: An iterable of the items selected by the boolean selectors.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"ABCDEF\").compress(1, 0, 1, 0, 1, 1).collect()\n        Seq('A', 'C', 'E', 'F')\n\n        ```\n        \"\"\"\n        return Iter(itertools.compress(self._inner, selectors))\n\n    def unique(self, key: Callable[[T], Any] | None = None) -&gt; Iter[T]:\n        \"\"\"Return only unique elements of the iterable.\n\n        Args:\n            key (Callable[[T], Any] | None): Function to transform items before comparison. Defaults to None.\n\n        Returns:\n            Iter[T]: An iterable of the unique items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).unique().collect()\n        Seq(1, 2, 3)\n        &gt;&gt;&gt; pc.Iter([1, 2, 1, 3]).unique().collect()\n        Seq(1, 2, 3)\n\n        ```\n        Uniqueness can be defined by key keyword\n        ```python\n        &gt;&gt;&gt; pc.Iter([\"cat\", \"mouse\", \"dog\", \"hen\"]).unique(key=len).collect()\n        Seq('cat', 'mouse')\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.unique(self._inner, key=key))\n\n    def take(self, n: int) -&gt; Iter[T]:\n        \"\"\"Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner.\n\n        `Iter.take(n)` yields elements until n elements are yielded or the end of the iterator is reached (whichever happens first).\n\n        The returned iterator is either:\n\n        - A prefix of length n if the original iterator contains at least n elements\n        - All of the (fewer than n) elements of the original iterator if it contains fewer than n elements.\n\n        Args:\n            n (int): Number of elements to take.\n\n        Returns:\n            Iter[T]: An iterable of the first n items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = [1, 2, 3]\n        &gt;&gt;&gt; pc.Iter(data).take(2).collect()\n        Seq(1, 2)\n        &gt;&gt;&gt; pc.Iter(data).take(5).collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        return Iter(itertools.islice(self._inner, n))\n\n    def skip(self, n: int) -&gt; Iter[T]:\n        \"\"\"Drop first n elements.\n\n        Args:\n            n (int): Number of elements to skip.\n\n        Returns:\n            Iter[T]: An iterable of the items after skipping the first n items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 3)).skip(1).collect()\n        Seq(2, 3)\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.drop(n, self._inner))\n\n    def unique_justseen(self, key: Callable[[T], Any] | None = None) -&gt; Iter[T]:\n        \"\"\"Yields elements in order, ignoring serial duplicates.\n\n        Args:\n            key (Callable[[T], Any] | None): Function to transform items before comparison. Defaults to None.\n\n        Returns:\n            Iter[T]: An iterable of the unique items, preserving order.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"AAAABBBCCDAABBB\").unique_justseen().collect()\n        Seq('A', 'B', 'C', 'D', 'A', 'B')\n        &gt;&gt;&gt; pc.Iter(\"ABBCcAD\").unique_justseen(str.lower).collect()\n        Seq('A', 'B', 'C', 'A', 'D')\n\n        ```\n        \"\"\"\n        return Iter(mit.unique_justseen(self._inner, key=key))\n\n    def unique_in_window(\n        self,\n        n: int,\n        key: Callable[[T], Any] | None = None,\n    ) -&gt; Iter[T]:\n        \"\"\"Yield the items from iterable that haven't been seen recently.\n\n        The items in iterable must be hashable.\n\n        Args:\n            n (int): Size of the lookback window.\n            key (Callable[[T], Any] | None): Function to transform items before comparison. Defaults to None.\n\n        Returns:\n            Iter[T]: An iterable of the items that are unique within the specified window.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; iterable = [0, 1, 0, 2, 3, 0]\n        &gt;&gt;&gt; n = 3\n        &gt;&gt;&gt; pc.Iter(iterable).unique_in_window(n).collect()\n        Seq(0, 1, 2, 3, 0)\n\n        ```\n        The key function, if provided, will be used to determine uniqueness:\n        ```python\n        &gt;&gt;&gt; pc.Iter(\"abAcda\").unique_in_window(3, key=str.lower).collect()\n        Seq('a', 'b', 'c', 'd', 'a')\n\n        ```\n        \"\"\"\n        return Iter(mit.unique_in_window(self._inner, n, key=key))\n\n    def extract(self, indices: Iterable[int]) -&gt; Iter[T]:\n        \"\"\"Yield values at the specified indices.\n\n        - The iterable is consumed lazily and can be infinite.\n        - The indices are consumed immediately and must be finite.\n        - Raises IndexError if an index lies beyond the iterable.\n        - Raises ValueError for negative indices.\n\n        Args:\n            indices (Iterable[int]): Iterable of indices to extract values from.\n\n        Returns:\n            Iter[T]: An iterable of the extracted items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; text = \"abcdefghijklmnopqrstuvwxyz\"\n        &gt;&gt;&gt; pc.Iter(text).extract([7, 4, 11, 11, 14]).collect()\n        Seq('h', 'e', 'l', 'l', 'o')\n\n        ```\n        \"\"\"\n        return Iter(mit.extract(self._inner, indices))\n\n    def step_by(self, step: int) -&gt; Iter[T]:\n        \"\"\"Creates an `Iter` starting at the same point, but stepping by the given **step** at each iteration.\n\n        Note:\n            The first element of the iterator will always be returned, regardless of the **step** given.\n\n        Args:\n            step (int): Step size for selecting items.\n\n        Returns:\n            Iter[T]: An iterable of every nth item.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 4, 5]).step_by(2).collect()\n        Seq(0, 2, 4)\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.take_nth(step, self._inner))\n\n    def slice(\n        self,\n        start: int | None = None,\n        stop: int | None = None,\n        step: int | None = None,\n    ) -&gt; Iter[T]:\n        \"\"\"Return a slice of the iterable.\n\n        Args:\n            start (int | None): Starting index of the slice. Defaults to None.\n            stop (int | None): Ending index of the slice. Defaults to None.\n            step (int | None): Step size for the slice. Defaults to None.\n\n        Returns:\n            Iter[T]: An iterable of the sliced items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = (1, 2, 3, 4, 5)\n        &gt;&gt;&gt; pc.Iter(data).slice(1, 4).collect()\n        Seq(2, 3, 4)\n        &gt;&gt;&gt; pc.Iter(data).slice(step=2).collect()\n        Seq(1, 3, 5)\n\n        ```\n        \"\"\"\n        return Iter(itertools.islice(self._inner, start, stop, step))\n\n    def filter_map[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n        \"\"\"Creates an iterator that both filters and maps.\n\n        The returned iterator yields only the values for which the supplied closure returns Some(value).\n\n        `filter_map` can be used to make chains of `filter` and map more concise.\n\n        The example below shows how a `map().filter().map()` can be shortened to a single call to `filter_map`.\n\n        Args:\n            func (Callable[[T], Option[R]]): Function to apply to each item.\n\n        Returns:\n            Iter[R]: An iterable of the results where func returned `Some`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Result[int, str]:\n        ...     try:\n        ...         return pc.Ok(int(s))\n        ...     except ValueError:\n        ...         return pc.Err(f\"Invalid integer, got {s!r}\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = pc.Seq([\"1\", \"two\", \"NaN\", \"four\", \"5\"])\n        &gt;&gt;&gt; data.iter().filter_map(lambda s: _parse(s).ok()).collect()\n        Seq(1, 5)\n        &gt;&gt;&gt; # Equivalent to:\n        &gt;&gt;&gt; (\n        ...     data.iter()\n        ...    .map(lambda s: _parse(s).ok())\n        ...    .filter(lambda s: s.is_some())\n        ...    .map(lambda s: s.unwrap())\n        ...    .collect()\n        ... )\n        Seq(1, 5)\n\n        ```\n        \"\"\"\n\n        def _filter_map(data: Iterable[T]) -&gt; Iterator[R]:\n            for item in data:\n                res = func(item)\n                if res.is_some():\n                    yield res.unwrap()\n\n        return Iter(_filter_map(self._inner))\n\n    # joins and zips ------------------------------------------------------------\n    @overload\n    def zip[T1](\n        self,\n        iter1: Iterable[T1],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1]]: ...\n    @overload\n    def zip[T1, T2](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1, T2]]: ...\n    @overload\n    def zip[T1, T2, T3](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1, T2, T3]]: ...\n    @overload\n    def zip[T1, T2, T3, T4](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1, T2, T3, T4]]: ...\n    def zip(\n        self,\n        *others: Iterable[Any],\n        strict: bool = False,\n    ) -&gt; Iter[tuple[Any, ...]]:\n        \"\"\"Yields n-length tuples, where n is the number of iterables passed as positional arguments.\n\n        The i-th element in every tuple comes from the i-th iterable argument to `.zip()`.\n\n        This continues until the shortest argument is exhausted.\n\n        Note:\n            `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n            This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to zip with.\n            strict (bool): If `True` and one of the arguments is exhausted before the others, raise a ValueError. Defaults to `False`.\n\n        Returns:\n            Iter[tuple[Any, ...]]: An `Iter` of tuples containing elements from the zipped Iter and other iterables.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).zip([10, 20]).collect()\n        Seq((1, 10), (2, 20))\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).zip([1, 2, 3]).collect()\n        Seq(('a', 1), ('b', 2))\n\n        ```\n        \"\"\"\n        return Iter(zip(self._inner, *others, strict=strict))\n\n    @overload\n    def zip_longest[T2](\n        self, iter2: Iterable[T2], /\n    ) -&gt; Iter[tuple[Option[T], Option[T2]]]: ...\n    @overload\n    def zip_longest[T2, T3](\n        self, iter2: Iterable[T2], iter3: Iterable[T3], /\n    ) -&gt; Iter[tuple[Option[T], Option[T2], Option[T3]]]: ...\n    @overload\n    def zip_longest[T2, T3, T4](\n        self,\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        /,\n    ) -&gt; Iter[tuple[Option[T], Option[T2], Option[T3], Option[T4]]]: ...\n    @overload\n    def zip_longest[T2, T3, T4, T5](\n        self,\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        iter5: Iterable[T5],\n        /,\n    ) -&gt; Iter[\n        tuple[\n            Option[T],\n            Option[T2],\n            Option[T3],\n            Option[T4],\n            Option[T5],\n        ]\n    ]: ...\n    @overload\n    def zip_longest(\n        self,\n        iter2: Iterable[T],\n        iter3: Iterable[T],\n        iter4: Iterable[T],\n        iter5: Iterable[T],\n        iter6: Iterable[T],\n        /,\n        *iterables: Iterable[T],\n    ) -&gt; Iter[tuple[Option[T], ...]]: ...\n    def zip_longest(self, *others: Iterable[Any]) -&gt; Iter[tuple[Option[Any], ...]]:\n        \"\"\"Return a zip Iterator who yield a tuple where the i-th element comes from the i-th iterable argument.\n\n        Yield values until the longest iterable in the argument sequence is exhausted, and then it raises StopIteration.\n\n        The longest iterable determines the length of the returned iterator, and will return `Some[T]` until exhaustion.\n\n        When the shorter iterables are exhausted, they yield `NONE`.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to zip with.\n\n        Returns:\n            Iter[tuple[Option[Any], ...]]: An iterable of tuples containing optional elements from the zipped iterables.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).collect()\n        Seq((Some(1), Some(10)), (Some(2), NONE))\n        &gt;&gt;&gt; # Can be combined with try collect to filter out the NONE:\n        &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).map(lambda x: pc.Iter(x).try_collect()).collect()\n        Seq(Some(Vec(1, 10)), NONE)\n\n        ```\n        \"\"\"\n        from ._option import Option\n\n        return Iter(\n            tuple(Option(t) for t in tup)\n            for tup in itertools.zip_longest(self._inner, *others, fillvalue=None)\n        )\n\n    @overload\n    def product(self) -&gt; Iter[tuple[T]]: ...\n    @overload\n    def product[T1](self, iter1: Iterable[T1], /) -&gt; Iter[tuple[T, T1]]: ...\n    @overload\n    def product[T1, T2](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        /,\n    ) -&gt; Iter[tuple[T, T1, T2]]: ...\n    @overload\n    def product[T1, T2, T3](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        /,\n    ) -&gt; Iter[tuple[T, T1, T2, T3]]: ...\n    @overload\n    def product[T1, T2, T3, T4](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        /,\n    ) -&gt; Iter[tuple[T, T1, T2, T3, T4]]: ...\n\n    def product(self, *others: Iterable[Any]) -&gt; Iter[tuple[Any, ...]]:\n        \"\"\"Computes the Cartesian product with another iterable.\n\n        This is the declarative equivalent of nested for-loops.\n\n        It pairs every element from the source iterable with every element from the\n        other iterable.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to compute the Cartesian product with.\n\n        Returns:\n            Iter[tuple[Any, ...]]: An iterable of tuples containing elements from the Cartesian product.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; sizes = [\"S\", \"M\"]\n        &gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).product(sizes).collect()\n        Seq(('blue', 'S'), ('blue', 'M'), ('red', 'S'), ('red', 'M'))\n\n        ```\n        \"\"\"\n        return Iter(itertools.product(self._inner, *others))\n\n    def diff_at(\n        self,\n        *others: Iterable[T],\n        default: T | None = None,\n        key: Callable[[T], Any] | None = None,\n    ) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Return those items that differ between iterables.\n\n        Each output item is a tuple where the i-th element is from the i-th input iterable.\n\n        If an input iterable is exhausted before others, then the corresponding output items will be filled with *default*.\n\n        Args:\n            *others (Iterable[T]): Other iterables to compare with.\n            default (T | None): Value to use for missing elements. Defaults to None.\n            key (Callable[[T], Any] | None): Function to apply to each item for comparison. Defaults to None.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of tuples containing differing elements from the input iterables.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Seq([1, 2, 3])\n        &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100], default=None).collect()\n        Seq((3, 10), (None, 100))\n        &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100, 2, 6, 7], default=0).collect()\n        Seq((3, 10), (0, 100), (0, 2), (0, 6), (0, 7))\n\n        A key function may also be applied to each item to use during comparisons:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([\"apples\", \"bananas\"]).diff_at([\"Apples\", \"Oranges\"], key=str.lower).collect()\n        Seq(('bananas', 'Oranges'),)\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.diff(self._inner, *others, default=default, key=key))\n\n    def join_with[R, K](\n        self,\n        other: Iterable[R],\n        left_on: Callable[[T], K],\n        right_on: Callable[[R], K],\n        left_default: T | None = None,\n        right_default: R | None = None,\n    ) -&gt; Iter[tuple[T, R]]:\n        \"\"\"Perform a relational join with another iterable.\n\n        Args:\n            other (Iterable[R]): Iterable to join with.\n            left_on (Callable[[T], K]): Function to extract the join key from the left iterable.\n            right_on (Callable[[R], K]): Function to extract the join key from the right iterable.\n            left_default (T | None): Default value for missing elements in the left iterable. Defaults to None.\n            right_default (R | None): Default value for missing elements in the right iterable. Defaults to None.\n\n        Returns:\n            Iter[tuple[T, R]]: An iterator yielding tuples of joined elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; sizes = [\"S\", \"M\"]\n        &gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).join_with(sizes, left_on=lambda c: c, right_on=lambda s: s).collect()\n        Seq((None, 'S'), (None, 'M'), ('blue', None), ('red', None))\n\n        ```\n        \"\"\"\n        return Iter(\n            cz.itertoolz.join(\n                leftkey=left_on,\n                leftseq=self._inner,\n                rightkey=right_on,\n                rightseq=other,\n                left_default=left_default,\n                right_default=right_default,\n            )\n        )\n\n    # windows and partitions ------------------------------------------------------------\n    @overload\n    def map_windows[R](\n        self, length: Literal[1], func: Callable[[tuple[T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[2], func: Callable[[tuple[T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[3], func: Callable[[tuple[T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[4], func: Callable[[tuple[T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[5], func: Callable[[tuple[T, T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: int, func: Callable[[tuple[T, ...]], R]\n    ) -&gt; Iter[R]: ...\n    def map_windows[R](\n        self, length: int, func: Callable[[tuple[Any, ...]], R]\n    ) -&gt; Iter[R]:\n        \"\"\"Calls the given **func** for each contiguous window of size **length** over **self**.\n\n        The windows during mapping overlaps.\n\n        The provided function must have a signature matching the length of the window.\n\n        Args:\n            length (int): The length of each window.\n            func (Callable[[tuple[Any, ...]], R]): Function to apply to each window.\n\n        Returns:\n            Iter[R]: An iterator over the outputs of func.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n\n        &gt;&gt;&gt; pc.Iter(\"abcd\").map_windows(2, lambda xy: f\"{xy[0]}+{xy[1]}\").collect()\n        Seq('a+b', 'b+c', 'c+d')\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, lambda xy: xy).collect()\n        Seq((1, 2), (2, 3), (3, 4))\n        &gt;&gt;&gt; def moving_average(seq: tuple[int, ...]) -&gt; float:\n        ...     return float(sum(seq)) / len(seq)\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, moving_average).collect()\n        Seq(1.5, 2.5, 3.5)\n\n        ```\n        \"\"\"\n        return Iter(map(func, cz.itertoolz.sliding_window(length, self._inner)))\n\n    @overload\n    def partition(self, n: Literal[1], pad: None = None) -&gt; Iter[tuple[T]]: ...\n    @overload\n    def partition(self, n: Literal[2], pad: None = None) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def partition(self, n: Literal[3], pad: None = None) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def partition(self, n: Literal[4], pad: None = None) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def partition(\n        self,\n        n: Literal[5],\n        pad: None = None,\n    ) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    @overload\n    def partition(self, n: int, pad: int) -&gt; Iter[tuple[T, ...]]: ...\n    def partition(self, n: int, pad: int | None = None) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Partition sequence into tuples of length n.\n\n        Args:\n            n (int): Length of each partition.\n            pad (int | None): Value to pad the last partition if needed. Defaults to None.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition(2).collect()\n        Seq((1, 2), (3, 4))\n\n        ```\n        If the length of seq is not evenly divisible by n, the final tuple is dropped if pad is not specified, or filled to length n by pad:\n        ```python\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition(2).collect()\n        Seq((1, 2), (3, 4), (5, None))\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.partition(n, self._inner, pad=pad))\n\n    def partition_all(self, n: int) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Partition all elements of sequence into tuples of length at most n.\n\n        The final tuple may be shorter to accommodate extra elements.\n\n        Args:\n            n (int): Maximum length of each partition.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition_all(2).collect()\n        Seq((1, 2), (3, 4))\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition_all(2).collect()\n        Seq((1, 2), (3, 4), (5,))\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.partition_all(n, self._inner))\n\n    def partition_by(self, predicate: Callable[[T], bool]) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Partition the `iterable` into a sequence of `tuples` according to a predicate function.\n\n        Every time the output of `predicate` changes, a new `tuple` is started,\n        and subsequent items are collected into that `tuple`.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine partition boundaries.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"I have space\").partition_by(lambda c: c == \" \").collect()\n        Seq(('I',), (' ',), ('h', 'a', 'v', 'e'), (' ',), ('s', 'p', 'a', 'c', 'e'))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = [1, 2, 1, 99, 88, 33, 99, -1, 5]\n        &gt;&gt;&gt; pc.Iter(data).partition_by(lambda x: x &gt; 10).collect()\n        Seq((1, 2, 1), (99, 88, 33, 99), (-1, 5))\n\n        ```\n        \"\"\"\n        return Iter(cz.recipes.partitionby(predicate, self._inner))\n\n    def batch(self, n: int, *, strict: bool = False) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Batch elements into tuples of length n and return a new Iter.\n\n        - The last batch may be shorter than n.\n        - The data is consumed lazily, just enough to fill a batch.\n        - The result is yielded as soon as a batch is full or when the input iterable is exhausted.\n\n        Args:\n            n (int): Number of elements in each batch.\n            strict (bool): If `True`, raises a ValueError if the last batch is not of length n. Defaults to `False`.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of batched tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"ABCDEFG\").batch(3).collect()\n        Seq(('A', 'B', 'C'), ('D', 'E', 'F'), ('G',))\n\n        ```\n        \"\"\"\n        return Iter(itertools.batched(self._inner, n, strict=strict))\n\n    def cycle(self) -&gt; Iter[T]:\n        \"\"\"Repeat the sequence indefinitely.\n\n        **Warning** ‚ö†Ô∏è\n            This creates an infinite iterator.\n            Be sure to use Iter.take() or Iter.slice() to limit the number of items taken.\n\n        Returns:\n            Iter[T]: A new Iterable wrapper that cycles through the elements indefinitely.\n        ```python\n\n        Example:\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2)).cycle().take(5).collect()\n        Seq(1, 2, 1, 2, 1)\n\n        ```\n        \"\"\"\n        return Iter(itertools.cycle(self._inner))\n\n    def intersperse(self, element: T) -&gt; Iter[T]:\n        \"\"\"Creates a new iterator which places a copy of separator between adjacent items of the original iterator.\n\n        Args:\n            element (T): The element to interpose between items.\n\n        Returns:\n            Iter[T]: A new `Iter` with the element interposed.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Simple example with numbers\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).intersperse(0).collect()\n        Seq(1, 0, 2, 0, 3)\n        &gt;&gt;&gt; # Useful when chaining with other operations\n        &gt;&gt;&gt; pc.Iter([10, 20, 30]).intersperse(5).sum()\n        70\n        &gt;&gt;&gt; # Inserting separators between groups, then flattening\n        &gt;&gt;&gt; pc.Iter([[1, 2], [3, 4], [5, 6]]).intersperse([-1]).flatten().collect()\n        Seq(1, 2, -1, 3, 4, -1, 5, 6)\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.interpose(element, self._inner))\n\n    def random_sample(\n        self, probability: float, state: Random | int | None = None\n    ) -&gt; Iter[T]:\n        \"\"\"Return elements from a sequence with probability of prob.\n\n        Returns a lazy iterator of random items from seq.\n\n        random_sample considers each item independently and without replacement.\n\n        See below how the first time it returned 13 items and the next time it returned 6 items.\n\n        Args:\n            probability (float): The probability of including each element.\n            state (Random | int | None): Random state or seed for deterministic sampling.\n\n        Returns:\n            Iter[T]: A new Iterable wrapper with randomly sampled elements.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Iter(range(100)).collect()\n        &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n        Seq(6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95)\n        &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n        Seq(6, 44, 54, 61, 69, 94)\n        ```\n        Providing an integer seed for random_state will result in deterministic sampling.\n\n        Given the same seed it will return the same sample every time.\n        ```python\n        &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n        Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n        &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n        Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n        ```\n        random_state can also be any object with a method random that returns floats between 0.0 and 1.0 (exclusive).\n        ```python\n        &gt;&gt;&gt; from random import Random\n        &gt;&gt;&gt; randobj = Random(2016)\n        &gt;&gt;&gt; data.iter().random_sample(0.1, state=randobj).collect()\n        Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n        ```\n        \"\"\"\n        return Iter(\n            cz.itertoolz.random_sample(probability, self._inner, random_state=state)\n        )\n\n    def insert(self, value: T) -&gt; Iter[T]:\n        \"\"\"Prepend the **value** to the `Iter`.\n\n        This can be useful when you want to add an element at the beginning of an existing iterable sequence.\n\n        Use `.chain()` to add multiple elements (at the end of the `Iterator`).\n\n        Note:\n            This can be considered the equivalent as `list.append()`, but for `Iter`.\n            However, append add the value at the **end**, while insert add it at the **beginning**.\n\n        Args:\n            value (T): The value to prepend.\n\n        Returns:\n            Iter[T]: A new Iterable wrapper with the value prepended.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((2, 3)).insert(1).collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.cons(value, self._inner))\n\n    def peekable(self, n: int) -&gt; Peekable[T]:\n        \"\"\"Retrieve the next n elements from the `Iterator`, and return a tuple of the retrieved elements along with the original Iterator, unconsumed.\n\n        Args:\n            n (int): Number of items to peek.\n\n        Returns:\n            Peekable[T]: A `Peekable` object containing the peeked elements and the remaining iterator.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Iter([1, 2, 3]).peekable(2)\n        &gt;&gt;&gt; data.peek.collect()\n        Seq(1, 2)\n        &gt;&gt;&gt; data.values.collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        peeked, vals = cz.itertoolz.peekn(n, self._inner)\n        return Peekable(Iter(peeked), Iter(vals))\n\n    def interleave(self, *others: Iterable[T]) -&gt; Iter[T]:\n        \"\"\"Interleave multiple sequences element-wise.\n\n        Args:\n            *others (Iterable[T]): Other iterables to interleave.\n\n        Returns:\n            Iter[T]: A new Iterable wrapper with interleaved elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2)).interleave((3, 4)).collect()\n        Seq(1, 3, 2, 4)\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.interleave((self._inner, *others)))\n\n    def chain(self, *others: Iterable[T]) -&gt; Iter[T]:\n        \"\"\"Concatenate zero or more iterables, any of which may be infinite.\n\n        In other words, it links **self** and **others** together, in a chain. üîó\n\n        An infinite sequence will prevent the rest of the arguments from being included.\n\n        We use chain.from_iterable rather than chain(*seqs) so that seqs can be a generator.\n\n        Args:\n            *others (Iterable[T]): Other iterables to concatenate.\n\n        Returns:\n            Iter[T]: A new `Iter` which will first iterate over values from the first iterator and then over values from the **others** `Iterable`s.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2)).chain((3, 4), [5]).collect()\n        Seq(1, 2, 3, 4, 5)\n        &gt;&gt;&gt; pc.Iter((1, 2)).chain(pc.Iter.from_count(3)).take(5).collect()\n        Seq(1, 2, 3, 4, 5)\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.concat((self._inner, *others)))\n\n    def elements(self) -&gt; Iter[T]:\n        \"\"\"Iterator over elements repeating each as many times as its count.\n\n        Note:\n            if an element's count has been set to zero or is a negative\n            number, elements() will ignore it.\n\n        Returns:\n            Iter[T]: A new Iterable wrapper with elements repeated according to their counts.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"ABCABC\").elements().sort()\n        Vec('A', 'A', 'B', 'B', 'C', 'C')\n\n        ```\n        Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1\n        ```python\n        &gt;&gt;&gt; import math\n        &gt;&gt;&gt; data = [2, 2, 3, 3, 3, 17]\n        &gt;&gt;&gt; pc.Iter(data).elements().into(math.prod)\n        1836\n\n        ```\n        \"\"\"\n        from collections import Counter\n\n        return Iter(Counter(self._inner).elements())\n\n    def rev(self) -&gt; Iter[T]:\n        \"\"\"Return a new Iterable wrapper with elements in reverse order.\n\n        The result is a new iterable over the reversed sequence.\n\n        Note:\n            This method must consume the entire iterable to perform the reversal.\n\n        Returns:\n            Iter[T]: A new Iterable wrapper with elements in reverse order.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).rev().collect()\n        Seq(3, 2, 1)\n\n        ```\n        \"\"\"\n        return Iter(reversed(tuple(self._inner)))\n\n    def is_strictly_n(self, n: int) -&gt; Iter[Result[T, ValueError]]:\n        \"\"\"Yield`Ok[T]` as long as the iterable has exactly *n* items.\n\n        If it has fewer than *n* items, yield `Err[ValueError]` with the actual number of items.\n\n        If it has more than *n* items, yield `Err[ValueError]` with the number `n + 1`.\n\n        Note that the returned iterable must be consumed in order for the check to\n        be made.\n\n        Args:\n            n (int): The exact number of items expected.\n\n        Returns:\n            Iter[Result[T, ValueError]]: A new Iterable wrapper yielding results based on the item count.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = [\"a\", \"b\", \"c\", \"d\"]\n        &gt;&gt;&gt; n = 4\n        &gt;&gt;&gt; pc.Iter(data).is_strictly_n(n).collect()\n        Seq(Ok('a'), Ok('b'), Ok('c'), Ok('d'))\n        &gt;&gt;&gt; pc.Iter(\"ab\").is_strictly_n(3).collect()  # doctest: +NORMALIZE_WHITESPACE\n        Seq(Ok('a'), Ok('b'),\n        Err(ValueError('Too few items in iterable (got 2)')))\n        &gt;&gt;&gt; pc.Iter(\"abc\").is_strictly_n(2).collect()  # doctest: +NORMALIZE_WHITESPACE\n        Seq(Ok('a'), Ok('b'),\n        Err(ValueError('Too many items in iterable (got at least 3)')))\n\n        ```\n        You can easily combine this with `.map(lambda r: r.map_err(...))` to handle the errors as you wish.\n        ```python\n        &gt;&gt;&gt; def _my_err(e: ValueError) -&gt; str:\n        ...     return f\"custom error: {e}\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([1]).is_strictly_n(0).map(lambda r: r.map_err(_my_err)).collect()\n        Seq(Err('custom error: Too many items in iterable (got at least 1)'),)\n\n        ```\n        Or use `.filter_map(...)` to only keep the `Ok` values.\n        ```python\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).is_strictly_n(2).filter_map(lambda r: r.ok()).collect()\n        Seq(1, 2)\n\n        ```\n        \"\"\"\n        from ._result import Err, Ok\n\n        def _strictly_n_(data: Iterator[T]) -&gt; Iterator[Result[T, ValueError]]:\n            sent = 0\n            for item in itertools.islice(data, n):\n                yield Ok(item)\n                sent += 1\n\n            if sent &lt; n:\n                e = ValueError(f\"Too few items in iterable (got {sent})\")\n                yield Err(e)\n\n            for _ in data:\n                e = ValueError(f\"Too many items in iterable (got at least {n + 1})\")\n                yield Err(e)\n\n        return Iter(_strictly_n_(self._inner))\n\n    def enumerate(self, start: int = 0) -&gt; Iter[tuple[int, T]]:\n        \"\"\"Return a `Iter` of (index, value) pairs.\n\n        Each value in the iterable is paired with its index, starting from 0.\n\n        Note:\n            `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n            This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n        Args:\n            start (int): The starting index. Defaults to 0.\n\n        Returns:\n            Iter[tuple[int, T]]: An iterable of (index, value) pairs.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().collect()\n        Seq((0, 'a'), (1, 'b'))\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().map_star(lambda idx, val: (idx, val.upper())).collect()\n        Seq((0, 'A'), (1, 'B'))\n\n        ```\n        \"\"\"\n        return Iter(enumerate(self._inner, start))\n\n    @overload\n    def combinations(self, r: Literal[2]) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def combinations(self, r: Literal[3]) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def combinations(self, r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def combinations(self, r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    def combinations(self, r: int) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Return all combinations of length r.\n\n        Args:\n            r (int): Length of each combination.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of combinations.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations(2).collect()\n        Seq((1, 2), (1, 3), (2, 3))\n\n        ```\n        \"\"\"\n        return Iter(itertools.combinations(self._inner, r))\n\n    @overload\n    def permutations(self, r: Literal[2]) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def permutations(self, r: Literal[3]) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def permutations(self, r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def permutations(self, r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    def permutations(self, r: int | None = None) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Return all permutations of length r.\n\n        Args:\n            r (int | None): Length of each permutation. Defaults to the length of the iterable.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of permutations.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).permutations(2).collect()\n        Seq((1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2))\n\n        ```\n        \"\"\"\n        return Iter(itertools.permutations(self._inner, r))\n\n    @overload\n    def combinations_with_replacement(self, r: Literal[2]) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def combinations_with_replacement(self, r: Literal[3]) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def combinations_with_replacement(\n        self,\n        r: Literal[4],\n    ) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def combinations_with_replacement(\n        self,\n        r: Literal[5],\n    ) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    def combinations_with_replacement(self, r: int) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Return all combinations with replacement of length r.\n\n        Args:\n            r (int): Length of each combination.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of combinations with replacement.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations_with_replacement(2).collect()\n        Seq((1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3))\n\n        ```\n        \"\"\"\n        return Iter(itertools.combinations_with_replacement(self._inner, r))\n\n    def pairwise(self) -&gt; Iter[tuple[T, T]]:\n        \"\"\"Return an iterator over pairs of consecutive elements.\n\n        Returns:\n            Iter[tuple[T, T]]: An iterable of pairs of consecutive elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).pairwise().collect()\n        Seq((1, 2), (2, 3))\n\n        ```\n        \"\"\"\n        return Iter(itertools.pairwise(self._inner))\n\n    @overload\n    def map_juxt[R1, R2](\n        self,\n        func1: Callable[[T], R1],\n        func2: Callable[[T], R2],\n        /,\n    ) -&gt; Iter[tuple[R1, R2]]: ...\n    @overload\n    def map_juxt[R1, R2, R3](\n        self,\n        func1: Callable[[T], R1],\n        func2: Callable[[T], R2],\n        func3: Callable[[T], R3],\n        /,\n    ) -&gt; Iter[tuple[R1, R2, R3]]: ...\n    @overload\n    def map_juxt[R1, R2, R3, R4](\n        self,\n        func1: Callable[[T], R1],\n        func2: Callable[[T], R2],\n        func3: Callable[[T], R3],\n        func4: Callable[[T], R4],\n        /,\n    ) -&gt; Iter[tuple[R1, R2, R3, R4]]: ...\n    def map_juxt(self, *funcs: Callable[[T], object]) -&gt; Iter[tuple[object, ...]]:\n        \"\"\"Apply several functions to each item.\n\n        Returns a new Iter where each item is a tuple of the results of applying each function to the original item.\n\n        Args:\n            *funcs (Callable[[T], object]): Functions to apply to each item.\n\n        Returns:\n            Iter[tuple[object, ...]]: An iterable of tuples containing the results of each function.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n        ...     return n % 2 == 0\n        &gt;&gt;&gt; def is_positive(n: int) -&gt; bool:\n        ...     return n &gt; 0\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([1, -2, 3]).map_juxt(is_even, is_positive).collect()\n        Seq((False, True), (True, False), (False, True))\n\n        ```\n        \"\"\"\n        return Iter(map(cz.functoolz.juxt(*funcs), self._inner))\n\n    def adjacent(\n        self,\n        predicate: Callable[[T], bool],\n        distance: int = 1,\n    ) -&gt; Iter[tuple[bool, T]]:\n        \"\"\"Return an iterable over (bool, item) tuples.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine if an item satisfies the condition.\n            distance (int): Number of places to consider as adjacent. Defaults to 1.\n\n        Returns:\n            Iter[tuple[bool, T]]: An iterable of (bool, item) tuples.\n\n        The output is a sequence of tuples where the item is drawn from iterable.\n\n        The bool indicates whether that item satisfies the predicate or is adjacent to an item that does.\n\n        For example, to find whether items are adjacent to a 3:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(range(6)).adjacent(lambda x: x == 3).collect()\n        Seq((False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5))\n\n        ```\n        Set distance to change what counts as adjacent.\n        For example, to find whether items are two places away from a 3:\n        ```python\n        &gt;&gt;&gt; pc.Iter(range(6)).adjacent(lambda x: x == 3, distance=2).collect()\n        Seq((False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5))\n\n        ```\n\n        This is useful for contextualizing the results of a search function.\n\n        For example, a code comparison tool might want to identify lines that have changed, but also surrounding lines to give the viewer of the diff context.\n\n        The predicate function will only be called once for each item in the iterable.\n\n        See also groupby_transform, which can be used with this function to group ranges of items with the same bool value.\n\n        \"\"\"\n        return Iter(mit.adjacent(predicate, self._inner, distance=distance))\n\n    def classify_unique(self) -&gt; Iter[tuple[T, bool, bool]]:\n        \"\"\"Classify each element in terms of its uniqueness.\n\n        For each element in the input iterable, return a 3-tuple consisting of:\n\n        - The element itself\n        - False if the element is equal to the one preceding it in the input, True otherwise (i.e. the equivalent of unique_justseen)\n        - False if this element has been seen anywhere in the input before, True otherwise (i.e. the equivalent of unique_everseen)\n\n        This function is analogous to unique_everseen and is subject to the same performance considerations.\n\n        Returns:\n            Iter[tuple[T, bool, bool]]: An iterable of (element, is_new, is_unique) tuples.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"otto\").classify_unique().collect()\n        ... # doctest: +NORMALIZE_WHITESPACE\n        Seq(('o', True,  True),\n        ('t', True,  True),\n        ('t', False, False),\n        ('o', True,  False))\n\n        ```\n        \"\"\"\n        return Iter(mit.classify_unique(self._inner))\n\n    def with_position(self) -&gt; Iter[tuple[Position, T]]:\n        \"\"\"Return an iterable over (`Position`, `T`) tuples.\n\n        The `Position` indicates whether the item `T` is the first, middle, last, or only element in the iterable.\n\n        Returns:\n            Iter[tuple[Position, T]]: An iterable of (`Position`, item) tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).with_position().collect()\n        Seq(('first', 'a'), ('middle', 'b'), ('last', 'c'))\n        &gt;&gt;&gt; pc.Iter([\"a\"]).with_position().collect()\n        Seq(('only', 'a'),)\n\n        ```\n        \"\"\"\n\n        def gen(data: Iterator[T]) -&gt; Iterator[tuple[Position, T]]:\n            try:\n                first = next(data)\n            except StopIteration:\n                return\n\n            try:\n                second = next(data)\n            except StopIteration:\n                yield (\"only\", first)\n                return\n            yield (\"first\", first)\n\n            current: T = second\n            for nxt in self._inner:\n                yield (\"middle\", current)\n                current = nxt\n            yield (\"last\", current)\n\n        return Iter(gen(self._inner))\n\n    @overload\n    def group_by(self, key: None = None) -&gt; Iter[tuple[T, Iter[T]]]: ...\n    @overload\n    def group_by[K](self, key: Callable[[T], K]) -&gt; Iter[tuple[K, Iter[T]]]: ...\n    @overload\n    def group_by[K](\n        self, key: Callable[[T], K] | None = None\n    ) -&gt; Iter[tuple[K, Iter[T]] | tuple[T, Iter[T]]]: ...\n    def group_by(\n        self, key: Callable[[T], Any] | None = None\n    ) -&gt; Iter[tuple[Any | T, Iter[T]]]:\n        \"\"\"Make an `Iter` that returns consecutive keys and groups from the iterable.\n\n        Args:\n            key (Callable[[T], Any] | None): Function to compute the key for grouping. Defaults to None.\n\n        Returns:\n            Iter[tuple[Any | T, Iter[T]]]: An `Iter` of `(key, value)` tuples.\n\n        The values yielded are `(K, Iter[T])` tuples, where the first element is the group key and the second element is an `Iter` of type `T` over the group values.\n\n        The **key** is a function computing a key value for each element.\n\n        If not specified or is None, **key** defaults to an identity function and returns the element unchanged.\n\n        The `Iter` needs to already be sorted on the same key function.\n\n        This is due to the fact that it generates a new `Group` every time the value of the **key** function changes.\n\n        That behavior differs from SQL's `GROUP BY` which aggregates common elements regardless of their input order.\n\n        **Warning** ‚ö†Ô∏è\n            **You MUST materialize the second element of the tuple **immediately** when iterating over groups!\n\n            Because `.group_by()` uses Python's `itertools.groupby` under the hood, each group's iterator shares internal state.\n            When you advance to the next group, the previous group's iterator becomes invalid and will yield empty results.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Example 1: Group even and odd numbers\n        &gt;&gt;&gt; (\n        ... pc.Iter.from_count() # create an infinite iterator of integers\n        ... .take(8) # take the first 8\n        ... .map(lambda x: (x % 2 == 0, x)) # map to (is_even, value)\n        ... .sort(key=lambda x: x[0]) # sort by is_even\n        ... .iter() # Since sort collect to a Vec, we need to convert back to Iter\n        ... .group_by(lambda x: x[0]) # group by is_even\n        ... .map_star(lambda g, vals: (g, vals.map_star(lambda _, y: y).into(list))) # extract values from groups, discarding keys, and materializing them to lists\n        ... .collect() # collect the result\n        ... .into(dict) # convert to dict\n        ... )\n        {False: [1, 3, 5, 7], True: [0, 2, 4, 6]}\n        &gt;&gt;&gt; # Example 2: Group by a common key, already sorted\n        &gt;&gt;&gt; data = [\n        ...     {\"name\": \"Alice\", \"gender\": \"F\"},\n        ...     {\"name\": \"Bob\", \"gender\": \"M\"},\n        ...     {\"name\": \"Charlie\", \"gender\": \"M\"},\n        ...     {\"name\": \"Dan\", \"gender\": \"M\"},\n        ... ]\n        &gt;&gt;&gt; (\n        ... pc.Iter(data)\n        ... .group_by(lambda x: x[\"gender\"]) # group by the gender key\n        ... .map_star(lambda g, vals: (g, vals.length())) # get the length of each group\n        ... .collect()\n        ... )\n        Seq(('F', 1), ('M', 3))\n        &gt;&gt;&gt; # Example 3: Incorrect usage with LATE materialization:\n        &gt;&gt;&gt; groups = pc.Iter([\"a1\", \"a2\", \"b1\"]).group_by(lambda x: x[0]).collect()\n        &gt;&gt;&gt; # Now iterate - TOO LATE! The group iterators are consumed\n        &gt;&gt;&gt; for g in groups:\n        ...     print(g[1].collect())  # ‚ùå Empty!\n        Seq()\n        Seq()\n        &gt;&gt;&gt; # Example 4: Correct usage with intermediate materialization:\n        &gt;&gt;&gt; groups = (\n        ...     pc.Iter([\"a1\", \"a2\", \"b1\"])\n        ...     .group_by(lambda x: x[0])\n        ...     .map_star(lambda g, vals: (g, vals.collect()))  # ‚úÖ Materialize NOW\n        ...     .collect()\n        ...     .iter()\n        ...     .for_each(lambda x: print(f\"{x[0]}: {x[1]}\"))\n        ... )\n        a: Seq('a1', 'a2')\n        b: Seq('b1',)\n\n        ```\n        \"\"\"\n        return Iter((x, Iter(y)) for x, y in itertools.groupby(self._inner, key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.accumulate","level":2,"title":"<code>accumulate(func, initial=None)</code>","text":"<p>Return an <code>Iter</code> of accumulated binary function results.</p> <p>In principle, <code>.accumulate()</code> is similar to <code>.fold()</code> if you provide it with the same binary function.</p> <p>However, instead of returning the final accumulated result, it returns an <code>Iter</code> that yields the current value <code>T</code> of the accumulator for each iteration.</p> <p>In other words, the last element yielded by <code>.accumulate()</code> is what would have been returned by <code>.fold()</code> if it had been used instead.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>A binary function to apply cumulatively.</p> required <code>initial</code> <code>T | None</code> <p>Optional initial value to start the accumulation. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new Iterable wrapper with accumulated results.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a + b, 0).collect()\nSeq(0, 1, 3, 6)\n&gt;&gt;&gt; # The final accumulated result is the same as fold:\n&gt;&gt;&gt; pc.Iter((1,2,3)).fold(0, lambda a, b: a + b)\n6\n&gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a * b).collect()\nSeq(1, 2, 6)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def accumulate(\n    self, func: Callable[[T, T], T], initial: T | None = None\n) -&gt; Iter[T]:\n    \"\"\"Return an `Iter` of accumulated binary function results.\n\n    In principle, `.accumulate()` is similar to `.fold()` if you provide it with the same binary function.\n\n    However, instead of returning the final accumulated result, it returns an `Iter` that yields the current value `T` of the accumulator for each iteration.\n\n    In other words, the last element yielded by `.accumulate()` is what would have been returned by `.fold()` if it had been used instead.\n\n    Args:\n        func (Callable[[T, T], T]): A binary function to apply cumulatively.\n        initial (T | None): Optional initial value to start the accumulation. Defaults to None.\n\n    Returns:\n        Iter[T]: A new Iterable wrapper with accumulated results.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a + b, 0).collect()\n    Seq(0, 1, 3, 6)\n    &gt;&gt;&gt; # The final accumulated result is the same as fold:\n    &gt;&gt;&gt; pc.Iter((1,2,3)).fold(0, lambda a, b: a + b)\n    6\n    &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a * b).collect()\n    Seq(1, 2, 6)\n\n\n    ```\n    \"\"\"\n    return Iter(itertools.accumulate(self._inner, func, initial=initial))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.adjacent","level":2,"title":"<code>adjacent(predicate, distance=1)</code>","text":"<p>Return an iterable over (bool, item) tuples.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine if an item satisfies the condition.</p> required <code>distance</code> <code>int</code> <p>Number of places to consider as adjacent. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Iter[tuple[bool, T]]</code> <p>Iter[tuple[bool, T]]: An iterable of (bool, item) tuples.</p> <p>The output is a sequence of tuples where the item is drawn from iterable.</p> <p>The bool indicates whether that item satisfies the predicate or is adjacent to an item that does.</p> <p>For example, to find whether items are adjacent to a 3: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(range(6)).adjacent(lambda x: x == 3).collect()\nSeq((False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5))\n</code></pre> Set distance to change what counts as adjacent. For example, to find whether items are two places away from a 3: <pre><code>&gt;&gt;&gt; pc.Iter(range(6)).adjacent(lambda x: x == 3, distance=2).collect()\nSeq((False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5))\n</code></pre></p> <p>This is useful for contextualizing the results of a search function.</p> <p>For example, a code comparison tool might want to identify lines that have changed, but also surrounding lines to give the viewer of the diff context.</p> <p>The predicate function will only be called once for each item in the iterable.</p> <p>See also groupby_transform, which can be used with this function to group ranges of items with the same bool value.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def adjacent(\n    self,\n    predicate: Callable[[T], bool],\n    distance: int = 1,\n) -&gt; Iter[tuple[bool, T]]:\n    \"\"\"Return an iterable over (bool, item) tuples.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine if an item satisfies the condition.\n        distance (int): Number of places to consider as adjacent. Defaults to 1.\n\n    Returns:\n        Iter[tuple[bool, T]]: An iterable of (bool, item) tuples.\n\n    The output is a sequence of tuples where the item is drawn from iterable.\n\n    The bool indicates whether that item satisfies the predicate or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a 3:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(range(6)).adjacent(lambda x: x == 3).collect()\n    Seq((False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5))\n\n    ```\n    Set distance to change what counts as adjacent.\n    For example, to find whether items are two places away from a 3:\n    ```python\n    &gt;&gt;&gt; pc.Iter(range(6)).adjacent(lambda x: x == 3, distance=2).collect()\n    Seq((False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5))\n\n    ```\n\n    This is useful for contextualizing the results of a search function.\n\n    For example, a code comparison tool might want to identify lines that have changed, but also surrounding lines to give the viewer of the diff context.\n\n    The predicate function will only be called once for each item in the iterable.\n\n    See also groupby_transform, which can be used with this function to group ranges of items with the same bool value.\n\n    \"\"\"\n    return Iter(mit.adjacent(predicate, self._inner, distance=distance))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.all","level":2,"title":"<code>all(predicate=None)</code>","text":"<p>Tests if every element of the iterator matches a predicate.</p> <p><code>Iter.all()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if they all return true, then so does <code>Iter.all()</code>.</p> <p>If any of them return false, it returns false.</p> <p>An empty iterator returns true.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements match the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, True]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 0]).all()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if every element of the iterator matches a predicate.\n\n    `Iter.all()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if they all return true, then so does `Iter.all()`.\n\n    If any of them return false, it returns false.\n\n    An empty iterator returns true.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if all elements match the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, True]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 0]).all()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return all(self._inner)\n    return all(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.all_equal","level":2,"title":"<code>all_equal(key=None)</code>","text":"<p>Return True if all items are equal.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\nTrue\n</code></pre> A function that accepts a single argument and returns a transformed version of each input item can be specified with key: <pre><code>&gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_equal[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Return True if all items are equal.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all items are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\n    True\n\n    ```\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with key:\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\n    True\n\n    ```\n    \"\"\"\n    return mit.all_equal(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.all_unique","level":2,"title":"<code>all_unique(key=None)</code>","text":"<p>Returns True if all the elements of iterable are unique.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements are unique, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\nFalse\n</code></pre> If a key function is specified, it will be used to make comparisons. <pre><code>&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\nTrue\n&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\nFalse\n</code></pre> The function returns as soon as the first non-unique element is encountered.</p> <p>Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_unique[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Returns True if all the elements of iterable are unique.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\n    False\n\n    ```\n    If a key function is specified, it will be used to make comparisons.\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\n    True\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\n    False\n\n    ```\n    The function returns as soon as the first non-unique element is encountered.\n\n    Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items\n\n    \"\"\"\n    return mit.all_unique(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.any","level":2,"title":"<code>any(predicate=None)</code>","text":"<p>Tests if any element of the iterator matches a predicate.</p> <p><code>Iter.any()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if any of them return true, then so does <code>Iter.any()</code>.</p> <p>If they all return false, it returns false.</p> <p>An empty iterator returns false.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any element matches the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([0, 1]).any()\nTrue\n&gt;&gt;&gt; pc.Seq(range(0)).any()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def any(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if any element of the iterator matches a predicate.\n\n    `Iter.any()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if any of them return true, then so does `Iter.any()`.\n\n    If they all return false, it returns false.\n\n    An empty iterator returns false.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if any element matches the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([0, 1]).any()\n    True\n    &gt;&gt;&gt; pc.Seq(range(0)).any()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return any(self._inner)\n    return any(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.argmax","level":2,"title":"<code>argmax(key=None)</code>","text":"<p>Index of the first occurrence of a maximum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the maximum value.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n7\n&gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n3\n</code></pre> For example, identify the best machine learning model: <pre><code>&gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n&gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n&gt;&gt;&gt; # Most accurate model\n&gt;&gt;&gt; models.nth(accuracy.argmax())\n'knn'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Best accuracy\n&gt;&gt;&gt; accuracy.into(max)\n84\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmax[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a maximum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the maximum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n    7\n    &gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n    3\n\n    ```\n    For example, identify the best machine learning model:\n    ```python\n    &gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n    &gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n    &gt;&gt;&gt; # Most accurate model\n    &gt;&gt;&gt; models.nth(accuracy.argmax())\n    'knn'\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Best accuracy\n    &gt;&gt;&gt; accuracy.into(max)\n    84\n\n    ```\n    \"\"\"\n    return mit.argmax(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.argmin","level":2,"title":"<code>argmin(key=None)</code>","text":"<p>Index of the first occurrence of a minimum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the minimum value.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n4\n&gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n3\n</code></pre> <p>For example, look up a label corresponding to the position of a value that minimizes a cost function: <pre><code>&gt;&gt;&gt; def cost(x):\n...     \"Days for a wound to heal given a subject's age.\"\n...     return x**2 - 20 * x + 150\n&gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n&gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n&gt;&gt;&gt; # Fastest healing family member\n&gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n'bart'\n&gt;&gt;&gt; # Age with fastest healing\n&gt;&gt;&gt; ages.into(min, key=cost)\n10\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmin[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a minimum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the minimum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n    4\n    &gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n    3\n\n    ```\n\n    For example, look up a label corresponding to the position of a value that minimizes a cost function:\n    ```python\n    &gt;&gt;&gt; def cost(x):\n    ...     \"Days for a wound to heal given a subject's age.\"\n    ...     return x**2 - 20 * x + 150\n    &gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n    &gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n    &gt;&gt;&gt; # Fastest healing family member\n    &gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n    'bart'\n    &gt;&gt;&gt; # Age with fastest healing\n    &gt;&gt;&gt; ages.into(min, key=cost)\n    10\n\n    ```\n    \"\"\"\n    return mit.argmin(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.array_chunks","level":2,"title":"<code>array_chunks(size)</code>","text":"<p>Yield subiterators (chunks) that each yield a fixed number elements, determined by size.</p> <p>The last chunk will be shorter if there are not enough elements.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of elements in each chunk.</p> required <p>Returns:</p> Type Description <code>Iter[Iter[T]]</code> <p>Iter[Iter[T]]: An iterable of iterators, each yielding n elements.</p> <p>If the sub-iterables are read in order, the elements of iterable won't be stored in memory.</p> <p>If they are read out of order, :func:<code>itertools.tee</code> is used to cache elements as necessary. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; all_chunks = pc.Iter.from_count().array_chunks(4)\n&gt;&gt;&gt; c_1, c_2, c_3 = all_chunks.next(), all_chunks.next(), all_chunks.next()\n&gt;&gt;&gt; c_2.unwrap().collect()  # c_1's elements have been cached; c_3's haven't been\nSeq(4, 5, 6, 7)\n&gt;&gt;&gt; c_1.unwrap().collect()\nSeq(0, 1, 2, 3)\n&gt;&gt;&gt; c_3.unwrap().collect()\nSeq(8, 9, 10, 11)\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\nSeq(Seq(1, 2, 3), Seq(4, 5, 6))\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6, 7, 8]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\nSeq(Seq(1, 2, 3), Seq(4, 5, 6), Seq(7, 8))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def array_chunks(self, size: int) -&gt; Iter[Iter[T]]:\n    \"\"\"Yield subiterators (chunks) that each yield a fixed number elements, determined by size.\n\n    The last chunk will be shorter if there are not enough elements.\n\n    Args:\n        size (int): Number of elements in each chunk.\n\n    Returns:\n        Iter[Iter[T]]: An iterable of iterators, each yielding n elements.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; all_chunks = pc.Iter.from_count().array_chunks(4)\n    &gt;&gt;&gt; c_1, c_2, c_3 = all_chunks.next(), all_chunks.next(), all_chunks.next()\n    &gt;&gt;&gt; c_2.unwrap().collect()  # c_1's elements have been cached; c_3's haven't been\n    Seq(4, 5, 6, 7)\n    &gt;&gt;&gt; c_1.unwrap().collect()\n    Seq(0, 1, 2, 3)\n    &gt;&gt;&gt; c_3.unwrap().collect()\n    Seq(8, 9, 10, 11)\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n    Seq(Seq(1, 2, 3), Seq(4, 5, 6))\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6, 7, 8]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n    Seq(Seq(1, 2, 3), Seq(4, 5, 6), Seq(7, 8))\n\n    ```\n    \"\"\"\n    from collections import deque\n    from contextlib import suppress\n\n    def _chunks(data: Iterable[T], size: int) -&gt; Iterator[Iter[T]]:\n        def _ichunk(\n            iterator: Iterator[T], n: int\n        ) -&gt; tuple[Iterator[T], Callable[[int], int]]:\n            cache: deque[T] = deque()\n            chunk = itertools.islice(iterator, n)\n\n            def generator() -&gt; Iterator[T]:\n                with suppress(StopIteration):\n                    while True:\n                        if cache:\n                            yield cache.popleft()\n                        else:\n                            yield next(chunk)\n\n            def materialize_next(n: int) -&gt; int:\n                to_cache = n - len(cache)\n\n                # materialize up to n\n                if to_cache &gt; 0:\n                    cache.extend(itertools.islice(chunk, to_cache))\n\n                # return number materialized up to n\n                return min(n, len(cache))\n\n            return (generator(), materialize_next)\n\n        iterator = iter(data)\n        while True:\n            # Create new chunk\n            chunk, materialize_next = _ichunk(iterator, size)\n\n            # Check to see whether we're at the end of the source iterable\n            if not materialize_next(size):\n                return\n\n            yield self.__class__(chunk)\n            materialize_next(size)\n\n    return Iter(_chunks(self._inner, size))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.batch","level":2,"title":"<code>batch(n, *, strict=False)</code>","text":"<p>Batch elements into tuples of length n and return a new Iter.</p> <ul> <li>The last batch may be shorter than n.</li> <li>The data is consumed lazily, just enough to fill a batch.</li> <li>The result is yielded as soon as a batch is full or when the input iterable is exhausted.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements in each batch.</p> required <code>strict</code> <code>bool</code> <p>If <code>True</code>, raises a ValueError if the last batch is not of length n. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of batched tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"ABCDEFG\").batch(3).collect()\nSeq(('A', 'B', 'C'), ('D', 'E', 'F'), ('G',))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def batch(self, n: int, *, strict: bool = False) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Batch elements into tuples of length n and return a new Iter.\n\n    - The last batch may be shorter than n.\n    - The data is consumed lazily, just enough to fill a batch.\n    - The result is yielded as soon as a batch is full or when the input iterable is exhausted.\n\n    Args:\n        n (int): Number of elements in each batch.\n        strict (bool): If `True`, raises a ValueError if the last batch is not of length n. Defaults to `False`.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of batched tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"ABCDEFG\").batch(3).collect()\n    Seq(('A', 'B', 'C'), ('D', 'E', 'F'), ('G',))\n\n    ```\n    \"\"\"\n    return Iter(itertools.batched(self._inner, n, strict=strict))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.chain","level":2,"title":"<code>chain(*others)</code>","text":"<p>Concatenate zero or more iterables, any of which may be infinite.</p> <p>In other words, it links self and others together, in a chain. üîó</p> <p>An infinite sequence will prevent the rest of the arguments from being included.</p> <p>We use chain.from_iterable rather than chain(*seqs) so that seqs can be a generator.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to concatenate.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new <code>Iter</code> which will first iterate over values from the first iterator and then over values from the others <code>Iterable</code>s.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2)).chain((3, 4), [5]).collect()\nSeq(1, 2, 3, 4, 5)\n&gt;&gt;&gt; pc.Iter((1, 2)).chain(pc.Iter.from_count(3)).take(5).collect()\nSeq(1, 2, 3, 4, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def chain(self, *others: Iterable[T]) -&gt; Iter[T]:\n    \"\"\"Concatenate zero or more iterables, any of which may be infinite.\n\n    In other words, it links **self** and **others** together, in a chain. üîó\n\n    An infinite sequence will prevent the rest of the arguments from being included.\n\n    We use chain.from_iterable rather than chain(*seqs) so that seqs can be a generator.\n\n    Args:\n        *others (Iterable[T]): Other iterables to concatenate.\n\n    Returns:\n        Iter[T]: A new `Iter` which will first iterate over values from the first iterator and then over values from the **others** `Iterable`s.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2)).chain((3, 4), [5]).collect()\n    Seq(1, 2, 3, 4, 5)\n    &gt;&gt;&gt; pc.Iter((1, 2)).chain(pc.Iter.from_count(3)).take(5).collect()\n    Seq(1, 2, 3, 4, 5)\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.concat((self._inner, *others)))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.classify_unique","level":2,"title":"<code>classify_unique()</code>","text":"<p>Classify each element in terms of its uniqueness.</p> <p>For each element in the input iterable, return a 3-tuple consisting of:</p> <ul> <li>The element itself</li> <li>False if the element is equal to the one preceding it in the input, True otherwise (i.e. the equivalent of unique_justseen)</li> <li>False if this element has been seen anywhere in the input before, True otherwise (i.e. the equivalent of unique_everseen)</li> </ul> <p>This function is analogous to unique_everseen and is subject to the same performance considerations.</p> <p>Returns:</p> Type Description <code>Iter[tuple[T, bool, bool]]</code> <p>Iter[tuple[T, bool, bool]]: An iterable of (element, is_new, is_unique) tuples.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"otto\").classify_unique().collect()\n... # doctest: +NORMALIZE_WHITESPACE\nSeq(('o', True,  True),\n('t', True,  True),\n('t', False, False),\n('o', True,  False))\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def classify_unique(self) -&gt; Iter[tuple[T, bool, bool]]:\n    \"\"\"Classify each element in terms of its uniqueness.\n\n    For each element in the input iterable, return a 3-tuple consisting of:\n\n    - The element itself\n    - False if the element is equal to the one preceding it in the input, True otherwise (i.e. the equivalent of unique_justseen)\n    - False if this element has been seen anywhere in the input before, True otherwise (i.e. the equivalent of unique_everseen)\n\n    This function is analogous to unique_everseen and is subject to the same performance considerations.\n\n    Returns:\n        Iter[tuple[T, bool, bool]]: An iterable of (element, is_new, is_unique) tuples.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"otto\").classify_unique().collect()\n    ... # doctest: +NORMALIZE_WHITESPACE\n    Seq(('o', True,  True),\n    ('t', True,  True),\n    ('t', False, False),\n    ('o', True,  False))\n\n    ```\n    \"\"\"\n    return Iter(mit.classify_unique(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.collect","level":2,"title":"<code>collect(collector=Seq[T])</code>","text":"<p>Transforms an <code>Iter</code> into a collection.</p> <p>The most basic pattern in which collect() is used is to turn one collection into another.</p> <p>You take a collection, call <code>iter()</code> on it, do a bunch of transformations, and then <code>collect()</code> at the end.</p> <p>You can specify the target collection type by providing a collector function or type.</p> <p>This can be any <code>Callable</code> that takes an <code>Iterator[T]</code> and returns a <code>Collection[T]</code> of those types.</p> Note <p>This can be tought as <code>.into()</code> with a default value (<code>Seq[T]</code>), and a different constraint (<code>Collection[Any]</code>). However, the runtime behavior is identical in both cases: pass self to the provided function, return the result.</p> <p>Parameters:</p> Name Type Description Default <code>collector</code> <code>Callable[[Iterator[T]], R]</code> <p>Function|type that defines the target collection. Defaults to <code>Seq[T]</code>. <code>R</code> is constrained to a <code>Collection</code>.</p> <code>Seq[T]</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>A materialized collection containing the collected elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(range(5)).collect()\nSeq(0, 1, 2, 3, 4)\n&gt;&gt;&gt; iterator = pc.Iter((1, 2, 3))\n&gt;&gt;&gt; iterator._inner.__class__.__name__\n'tuple_iterator'\n&gt;&gt;&gt; mapped = iterator.map(lambda x: x * 2)\n&gt;&gt;&gt; mapped._inner.__class__.__name__\n'map'\n&gt;&gt;&gt; mapped.collect()\nSeq(2, 4, 6)\n&gt;&gt;&gt; # iterator is now exhausted\n&gt;&gt;&gt; iterator.collect()\nSeq()\n&gt;&gt;&gt; pc.Iter(range(5)).collect(list)\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; pc.Iter(range(5)).collect(pc.Vec)\nVec(0, 1, 2, 3, 4)\n&gt;&gt;&gt; iterator = pc.Iter([1, 2, 3])\n&gt;&gt;&gt; iterator._inner.__class__.__name__\n'list_iterator'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def collect[R: Collection[Any]](\n    self, collector: Callable[[Iterator[T]], R] = Seq[T]\n) -&gt; R:\n    \"\"\"Transforms an `Iter` into a collection.\n\n    The most basic pattern in which collect() is used is to turn one collection into another.\n\n    You take a collection, call `iter()` on it, do a bunch of transformations, and then `collect()` at the end.\n\n    You can specify the target collection type by providing a **collector** function or type.\n\n    This can be any `Callable` that takes an `Iterator[T]` and returns a `Collection[T]` of those types.\n\n    Note:\n        This can be tought as `.into()` with a default value (`Seq[T]`), and a different constraint (`Collection[Any]`).\n        However, the runtime behavior is identical in both cases: pass **self** to the provided function, return the result.\n\n    Args:\n        collector (Callable[[Iterator[T]], R]): Function|type that defines the target collection. Defaults to `Seq[T]`. `R` is constrained to a `Collection`.\n\n    Returns:\n        R: A materialized collection containing the collected elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(range(5)).collect()\n    Seq(0, 1, 2, 3, 4)\n    &gt;&gt;&gt; iterator = pc.Iter((1, 2, 3))\n    &gt;&gt;&gt; iterator._inner.__class__.__name__\n    'tuple_iterator'\n    &gt;&gt;&gt; mapped = iterator.map(lambda x: x * 2)\n    &gt;&gt;&gt; mapped._inner.__class__.__name__\n    'map'\n    &gt;&gt;&gt; mapped.collect()\n    Seq(2, 4, 6)\n    &gt;&gt;&gt; # iterator is now exhausted\n    &gt;&gt;&gt; iterator.collect()\n    Seq()\n    &gt;&gt;&gt; pc.Iter(range(5)).collect(list)\n    [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; pc.Iter(range(5)).collect(pc.Vec)\n    Vec(0, 1, 2, 3, 4)\n    &gt;&gt;&gt; iterator = pc.Iter([1, 2, 3])\n    &gt;&gt;&gt; iterator._inner.__class__.__name__\n    'list_iterator'\n\n    ```\n    \"\"\"\n    return collector(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.combination_index","level":2,"title":"<code>combination_index(r)</code>","text":"<p>Computes the index of the first element, without computing the previous combinations.</p> <p>The subsequences of iterable that are of length r can be ordered lexicographically.</p> <p>ValueError will be raised if the given element isn't one of the combinations of iterable.</p> <p>Equivalent to list(combinations(iterable, r)).index(element).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>Iterable[T]</code> <p>The combination to find the index of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the combination.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n10\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combination_index(self, r: Iterable[T]) -&gt; int:\n    \"\"\"Computes the index of the first element, without computing the previous combinations.\n\n    The subsequences of iterable that are of length r can be ordered lexicographically.\n\n\n    ValueError will be raised if the given element isn't one of the combinations of iterable.\n\n    Equivalent to list(combinations(iterable, r)).index(element).\n\n    Args:\n        r (Iterable[T]): The combination to find the index of.\n\n    Returns:\n        int: The index of the combination.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n    10\n\n    ```\n    \"\"\"\n    return mit.combination_index(r, self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.combinations","level":2,"title":"<code>combinations(r)</code>","text":"<pre><code>combinations(r: Literal[2]) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>combinations(r: Literal[3]) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>combinations(r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>combinations(r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre> <p>Return all combinations of length r.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Length of each combination.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of combinations.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations(2).collect()\nSeq((1, 2), (1, 3), (2, 3))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combinations(self, r: int) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Return all combinations of length r.\n\n    Args:\n        r (int): Length of each combination.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of combinations.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations(2).collect()\n    Seq((1, 2), (1, 3), (2, 3))\n\n    ```\n    \"\"\"\n    return Iter(itertools.combinations(self._inner, r))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.combinations_with_replacement","level":2,"title":"<code>combinations_with_replacement(r)</code>","text":"<pre><code>combinations_with_replacement(\n    r: Literal[2],\n) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>combinations_with_replacement(\n    r: Literal[3],\n) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>combinations_with_replacement(\n    r: Literal[4],\n) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>combinations_with_replacement(\n    r: Literal[5],\n) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre> <p>Return all combinations with replacement of length r.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Length of each combination.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of combinations with replacement.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations_with_replacement(2).collect()\nSeq((1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combinations_with_replacement(self, r: int) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Return all combinations with replacement of length r.\n\n    Args:\n        r (int): Length of each combination.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of combinations with replacement.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations_with_replacement(2).collect()\n    Seq((1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3))\n\n    ```\n    \"\"\"\n    return Iter(itertools.combinations_with_replacement(self._inner, r))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.compress","level":2,"title":"<code>compress(*selectors)</code>","text":"<p>Filter elements using a boolean selector iterable.</p> <p>Parameters:</p> Name Type Description Default <code>*selectors</code> <code>bool</code> <p>Boolean values indicating which elements to keep.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the items selected by the boolean selectors.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"ABCDEF\").compress(1, 0, 1, 0, 1, 1).collect()\nSeq('A', 'C', 'E', 'F')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def compress(self, *selectors: bool) -&gt; Iter[T]:\n    \"\"\"Filter elements using a boolean selector iterable.\n\n    Args:\n        *selectors (bool): Boolean values indicating which elements to keep.\n\n    Returns:\n        Iter[T]: An iterable of the items selected by the boolean selectors.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"ABCDEF\").compress(1, 0, 1, 0, 1, 1).collect()\n    Seq('A', 'C', 'E', 'F')\n\n    ```\n    \"\"\"\n    return Iter(itertools.compress(self._inner, selectors))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.cycle","level":2,"title":"<code>cycle()</code>","text":"<p>Repeat the sequence indefinitely.</p> <p>Warning ‚ö†Ô∏è     This creates an infinite iterator.     Be sure to use Iter.take() or Iter.slice() to limit the number of items taken.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new Iterable wrapper that cycles through the elements indefinitely.</p> <pre><code>Example:\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2)).cycle().take(5).collect()\nSeq(1, 2, 1, 2, 1)\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def cycle(self) -&gt; Iter[T]:\n    \"\"\"Repeat the sequence indefinitely.\n\n    **Warning** ‚ö†Ô∏è\n        This creates an infinite iterator.\n        Be sure to use Iter.take() or Iter.slice() to limit the number of items taken.\n\n    Returns:\n        Iter[T]: A new Iterable wrapper that cycles through the elements indefinitely.\n    ```python\n\n    Example:\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2)).cycle().take(5).collect()\n    Seq(1, 2, 1, 2, 1)\n\n    ```\n    \"\"\"\n    return Iter(itertools.cycle(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.diff_at","level":2,"title":"<code>diff_at(*others, default=None, key=None)</code>","text":"<p>Return those items that differ between iterables.</p> <p>Each output item is a tuple where the i-th element is from the i-th input iterable.</p> <p>If an input iterable is exhausted before others, then the corresponding output items will be filled with default.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to compare with.</p> <code>()</code> <code>default</code> <code>T | None</code> <p>Value to use for missing elements. Defaults to None.</p> <code>None</code> <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to apply to each item for comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of tuples containing differing elements from the input iterables.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Seq([1, 2, 3])\n&gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100], default=None).collect()\nSeq((3, 10), (None, 100))\n&gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100, 2, 6, 7], default=0).collect()\nSeq((3, 10), (0, 100), (0, 2), (0, 6), (0, 7))\n\nA key function may also be applied to each item to use during comparisons:\n```python\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([\"apples\", \"bananas\"]).diff_at([\"Apples\", \"Oranges\"], key=str.lower).collect()\nSeq(('bananas', 'Oranges'),)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def diff_at(\n    self,\n    *others: Iterable[T],\n    default: T | None = None,\n    key: Callable[[T], Any] | None = None,\n) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Return those items that differ between iterables.\n\n    Each output item is a tuple where the i-th element is from the i-th input iterable.\n\n    If an input iterable is exhausted before others, then the corresponding output items will be filled with *default*.\n\n    Args:\n        *others (Iterable[T]): Other iterables to compare with.\n        default (T | None): Value to use for missing elements. Defaults to None.\n        key (Callable[[T], Any] | None): Function to apply to each item for comparison. Defaults to None.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of tuples containing differing elements from the input iterables.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Seq([1, 2, 3])\n    &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100], default=None).collect()\n    Seq((3, 10), (None, 100))\n    &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100, 2, 6, 7], default=0).collect()\n    Seq((3, 10), (0, 100), (0, 2), (0, 6), (0, 7))\n\n    A key function may also be applied to each item to use during comparisons:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([\"apples\", \"bananas\"]).diff_at([\"Apples\", \"Oranges\"], key=str.lower).collect()\n    Seq(('bananas', 'Oranges'),)\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.diff(self._inner, *others, default=default, key=key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.elements","level":2,"title":"<code>elements()</code>","text":"<p>Iterator over elements repeating each as many times as its count.</p> Note <p>if an element's count has been set to zero or is a negative number, elements() will ignore it.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new Iterable wrapper with elements repeated according to their counts.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"ABCABC\").elements().sort()\nVec('A', 'A', 'B', 'B', 'C', 'C')\n</code></pre> Knuth's example for prime factors of 1836:  22 * 33 * 17**1 <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; data = [2, 2, 3, 3, 3, 17]\n&gt;&gt;&gt; pc.Iter(data).elements().into(math.prod)\n1836\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def elements(self) -&gt; Iter[T]:\n    \"\"\"Iterator over elements repeating each as many times as its count.\n\n    Note:\n        if an element's count has been set to zero or is a negative\n        number, elements() will ignore it.\n\n    Returns:\n        Iter[T]: A new Iterable wrapper with elements repeated according to their counts.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"ABCABC\").elements().sort()\n    Vec('A', 'A', 'B', 'B', 'C', 'C')\n\n    ```\n    Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1\n    ```python\n    &gt;&gt;&gt; import math\n    &gt;&gt;&gt; data = [2, 2, 3, 3, 3, 17]\n    &gt;&gt;&gt; pc.Iter(data).elements().into(math.prod)\n    1836\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return Iter(Counter(self._inner).elements())\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.empty","level":2,"title":"<code>empty()</code>  <code>classmethod</code>","text":"<p>Create an empty <code>Iter</code>.</p> <p>Make sure to specify the type when calling this method, e.g., <code>Iter[int].empty()</code>.</p> <p>Otherwise, <code>T</code> will be inferred as <code>Any</code>.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new empty Iter instance.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter.empty().collect()\nSeq()\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@classmethod\ndef empty(cls) -&gt; Self:\n    \"\"\"Create an empty `Iter`.\n\n    Make sure to specify the type when calling this method, e.g., `Iter[int].empty()`.\n\n    Otherwise, `T` will be inferred as `Any`.\n\n    Returns:\n        Self: A new empty Iter instance.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter.empty().collect()\n    Seq()\n\n    ```\n    \"\"\"\n    return cls(())\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.enumerate","level":2,"title":"<code>enumerate(start=0)</code>","text":"<p>Return a <code>Iter</code> of (index, value) pairs.</p> <p>Each value in the iterable is paired with its index, starting from 0.</p> Note <p><code>Iter.map_star</code> can then be used for subsequent operations on the index and value, in a destructuring manner. This keep the code clean and readable, without index access like <code>[0]</code> and <code>[1]</code> for inline lambdas.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The starting index. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>Iter[tuple[int, T]]</code> <p>Iter[tuple[int, T]]: An iterable of (index, value) pairs.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().collect()\nSeq((0, 'a'), (1, 'b'))\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().map_star(lambda idx, val: (idx, val.upper())).collect()\nSeq((0, 'A'), (1, 'B'))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def enumerate(self, start: int = 0) -&gt; Iter[tuple[int, T]]:\n    \"\"\"Return a `Iter` of (index, value) pairs.\n\n    Each value in the iterable is paired with its index, starting from 0.\n\n    Note:\n        `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n        This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n    Args:\n        start (int): The starting index. Defaults to 0.\n\n    Returns:\n        Iter[tuple[int, T]]: An iterable of (index, value) pairs.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().collect()\n    Seq((0, 'a'), (1, 'b'))\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().map_star(lambda idx, val: (idx, val.upper())).collect()\n    Seq((0, 'A'), (1, 'B'))\n\n    ```\n    \"\"\"\n    return Iter(enumerate(self._inner, start))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Check if two Iterables are equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\nFalse\n&gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def eq(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\n    False\n    &gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\n    True\n\n    ```\n    \"\"\"\n    return tuple(self._inner) == tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.extract","level":2,"title":"<code>extract(indices)</code>","text":"<p>Yield values at the specified indices.</p> <ul> <li>The iterable is consumed lazily and can be infinite.</li> <li>The indices are consumed immediately and must be finite.</li> <li>Raises IndexError if an index lies beyond the iterable.</li> <li>Raises ValueError for negative indices.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>indices</code> <code>Iterable[int]</code> <p>Iterable of indices to extract values from.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the extracted items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; text = \"abcdefghijklmnopqrstuvwxyz\"\n&gt;&gt;&gt; pc.Iter(text).extract([7, 4, 11, 11, 14]).collect()\nSeq('h', 'e', 'l', 'l', 'o')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def extract(self, indices: Iterable[int]) -&gt; Iter[T]:\n    \"\"\"Yield values at the specified indices.\n\n    - The iterable is consumed lazily and can be infinite.\n    - The indices are consumed immediately and must be finite.\n    - Raises IndexError if an index lies beyond the iterable.\n    - Raises ValueError for negative indices.\n\n    Args:\n        indices (Iterable[int]): Iterable of indices to extract values from.\n\n    Returns:\n        Iter[T]: An iterable of the extracted items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; text = \"abcdefghijklmnopqrstuvwxyz\"\n    &gt;&gt;&gt; pc.Iter(text).extract([7, 4, 11, 11, 14]).collect()\n    Seq('h', 'e', 'l', 'l', 'o')\n\n    ```\n    \"\"\"\n    return Iter(mit.extract(self._inner, indices))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter","level":2,"title":"<code>filter(func)</code>","text":"<pre><code>filter(func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]\n</code></pre><pre><code>filter(func: Callable[[T], bool]) -&gt; Iter[T]\n</code></pre> <p>Creates an <code>Iter</code> which uses a closure to determine if an element should be yielded.</p> <p>Given an element the closure must return true or false.</p> <p>The returned <code>Iter</code> will yield only the elements for which the closure returns true.</p> <p>The closure can return a <code>TypeIs</code> to narrow the type of the returned iterable.</p> <p>This won't have any runtime effect, but allows for better type inference.</p> Note <p><code>Iter.filter(f).next()</code> is equivalent to <code>Iter.find(f)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool | TypeIs[U]]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Iter[T] | Iter[U]</code> <p>Iter[T] | Iter[U]: An iterable of the items that satisfy the predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = (1, 2, 3)\n&gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).collect()\nSeq(2, 3)\n&gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).next()\nSome(2)\n&gt;&gt;&gt; pc.Iter(data).find(lambda x: x &gt; 1)\nSome(2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter[U](self, func: Callable[[T], bool | TypeIs[U]]) -&gt; Iter[T] | Iter[U]:\n    \"\"\"Creates an `Iter` which uses a closure to determine if an element should be yielded.\n\n    Given an element the closure must return true or false.\n\n    The returned `Iter` will yield only the elements for which the closure returns true.\n\n    The closure can return a `TypeIs` to narrow the type of the returned iterable.\n\n    This won't have any runtime effect, but allows for better type inference.\n\n    Note:\n        `Iter.filter(f).next()` is equivalent to `Iter.find(f)`.\n\n    Args:\n        func (Callable[[T], bool | TypeIs[U]]): Function to evaluate each item.\n\n    Returns:\n        Iter[T] | Iter[U]: An iterable of the items that satisfy the predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = (1, 2, 3)\n    &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).collect()\n    Seq(2, 3)\n    &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).next()\n    Some(2)\n    &gt;&gt;&gt; pc.Iter(data).find(lambda x: x &gt; 1)\n    Some(2)\n\n    ```\n    \"\"\"\n    return Iter(filter(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter_false","level":2,"title":"<code>filter_false(func)</code>","text":"<pre><code>filter_false(func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]\n</code></pre><pre><code>filter_false(func: Callable[[T], bool]) -&gt; Iter[T]\n</code></pre> <p>Return elements for which func is false.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Iter[T] | Iter[U]</code> <p>Iter[T]: An iterable of the items that do not satisfy the predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).filter_false(lambda x: x &gt; 1).collect()\nSeq(1,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter_false[U](\n    self, func: Callable[[T], bool | TypeIs[U]]\n) -&gt; Iter[T] | Iter[U]:\n    \"\"\"Return elements for which func is false.\n\n    Args:\n        func (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Iter[T]: An iterable of the items that do not satisfy the predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).filter_false(lambda x: x &gt; 1).collect()\n    Seq(1,)\n\n    ```\n    \"\"\"\n    return Iter(itertools.filterfalse(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter_map","level":2,"title":"<code>filter_map(func)</code>","text":"<p>Creates an iterator that both filters and maps.</p> <p>The returned iterator yields only the values for which the supplied closure returns Some(value).</p> <p><code>filter_map</code> can be used to make chains of <code>filter</code> and map more concise.</p> <p>The example below shows how a <code>map().filter().map()</code> can be shortened to a single call to <code>filter_map</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Option[R]]</code> <p>Function to apply to each item.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterable of the results where func returned <code>Some</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _parse(s: str) -&gt; pc.Result[int, str]:\n...     try:\n...         return pc.Ok(int(s))\n...     except ValueError:\n...         return pc.Err(f\"Invalid integer, got {s!r}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = pc.Seq([\"1\", \"two\", \"NaN\", \"four\", \"5\"])\n&gt;&gt;&gt; data.iter().filter_map(lambda s: _parse(s).ok()).collect()\nSeq(1, 5)\n&gt;&gt;&gt; # Equivalent to:\n&gt;&gt;&gt; (\n...     data.iter()\n...    .map(lambda s: _parse(s).ok())\n...    .filter(lambda s: s.is_some())\n...    .map(lambda s: s.unwrap())\n...    .collect()\n... )\nSeq(1, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter_map[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n    \"\"\"Creates an iterator that both filters and maps.\n\n    The returned iterator yields only the values for which the supplied closure returns Some(value).\n\n    `filter_map` can be used to make chains of `filter` and map more concise.\n\n    The example below shows how a `map().filter().map()` can be shortened to a single call to `filter_map`.\n\n    Args:\n        func (Callable[[T], Option[R]]): Function to apply to each item.\n\n    Returns:\n        Iter[R]: An iterable of the results where func returned `Some`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Result[int, str]:\n    ...     try:\n    ...         return pc.Ok(int(s))\n    ...     except ValueError:\n    ...         return pc.Err(f\"Invalid integer, got {s!r}\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = pc.Seq([\"1\", \"two\", \"NaN\", \"four\", \"5\"])\n    &gt;&gt;&gt; data.iter().filter_map(lambda s: _parse(s).ok()).collect()\n    Seq(1, 5)\n    &gt;&gt;&gt; # Equivalent to:\n    &gt;&gt;&gt; (\n    ...     data.iter()\n    ...    .map(lambda s: _parse(s).ok())\n    ...    .filter(lambda s: s.is_some())\n    ...    .map(lambda s: s.unwrap())\n    ...    .collect()\n    ... )\n    Seq(1, 5)\n\n    ```\n    \"\"\"\n\n    def _filter_map(data: Iterable[T]) -&gt; Iterator[R]:\n        for item in data:\n            res = func(item)\n            if res.is_some():\n                yield res.unwrap()\n\n    return Iter(_filter_map(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter_star","level":2,"title":"<code>filter_star(func)</code>","text":"<pre><code>filter_star(\n    func: Callable[[Any], bool],\n) -&gt; Iter[tuple[Any]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2], bool],\n) -&gt; Iter[tuple[T1, T2]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3], bool],\n) -&gt; Iter[tuple[T1, T2, T3]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]]\n</code></pre><pre><code>filter_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9], bool\n    ],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]]\n</code></pre><pre><code>filter_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], bool\n    ],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]]\n</code></pre> <p>Creates an <code>Iter</code> which uses a closure to determine if an element should be yielded, where each element is an iterable.</p> <p>Unlike <code>.filter()</code>, which passes each element as a single argument, <code>.filter_star()</code> unpacks each element into positional arguments for the function.</p> <p>In short, for each <code>element</code> in the sequence, it computes <code>func(*element)</code>.</p> <p>This is useful after using methods like <code>zip</code>, <code>product</code>, or <code>enumerate</code> that yield tuples.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., bool]</code> <p>Function to evaluate unpacked elements.</p> required <p>Returns:</p> Type Description <code>Iter[U]</code> <p>Iter[U]: An iterable of the items that satisfy the predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Seq([\"apple\", \"banana\", \"cherry\", \"date\"])\n&gt;&gt;&gt; data.iter().enumerate().filter_star(lambda index, fruit: index % 2 == 0).map_star(lambda index, fruit: fruit.title()).collect()\nSeq('Apple', 'Cherry')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter_star[U: Iterable[Any]](\n    self: Iter[U],\n    func: Callable[..., bool],\n) -&gt; Iter[U]:\n    \"\"\"Creates an `Iter` which uses a closure to determine if an element should be yielded, where each element is an iterable.\n\n    Unlike `.filter()`, which passes each element as a single argument, `.filter_star()` unpacks each element into positional arguments for the function.\n\n    In short, for each `element` in the sequence, it computes `func(*element)`.\n\n    This is useful after using methods like `zip`, `product`, or `enumerate` that yield tuples.\n\n    Args:\n        func (Callable[..., bool]): Function to evaluate unpacked elements.\n\n    Returns:\n        Iter[U]: An iterable of the items that satisfy the predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Seq([\"apple\", \"banana\", \"cherry\", \"date\"])\n    &gt;&gt;&gt; data.iter().enumerate().filter_star(lambda index, fruit: index % 2 == 0).map_star(lambda index, fruit: fruit.title()).collect()\n    Seq('Apple', 'Cherry')\n\n    ```\n    \"\"\"\n    return Iter(filter(lambda x: func(*x), self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.find","level":2,"title":"<code>find(predicate)</code>","text":"<p>Searches for an element of an iterator that satisfies a <code>predicate</code>.</p> <p>Takes a closure that returns true or false as <code>predicate</code>, and applies it to each element of the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The first element satisfying the predicate. <code>Some(value)</code> if found, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n...     return x &gt; 5\n&gt;&gt;&gt;\n&gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n...     return x &gt; 9\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\nSome(6)\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n'missing'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def find(self, predicate: Callable[[T], bool]) -&gt; Option[T]:\n    \"\"\"Searches for an element of an iterator that satisfies a `predicate`.\n\n    Takes a closure that returns true or false as `predicate`, and applies it to each element of the iterator.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Option[T]: The first element satisfying the predicate. `Some(value)` if found, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n    ...     return x &gt; 5\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n    ...     return x &gt; 9\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\n    Some(6)\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n    'missing'\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(next(filter(predicate, self._inner), None))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.find_map","level":2,"title":"<code>find_map(func)</code>","text":"<p>Applies function to the elements of the <code>Iterator</code> and returns the first Some(R) result.</p> <p><code>Iter.find_map(f)</code> is equivalent to <code>Iter.filter_map(f).next()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Option[R]]</code> <p>Function to apply to each element, returning an <code>Option[R]</code>.</p> required <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: The first <code>Some(R)</code> result from applying <code>func</code>, or <code>NONE</code> if no such result is found.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _parse(s: str) -&gt; pc.Option[int]:\n...     try:\n...         return pc.Some(int(s))\n...     except ValueError:\n...         return pc.NONE\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([\"lol\", \"NaN\", \"2\", \"5\"]).find_map(_parse)\nSome(2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def find_map[R](self, func: Callable[[T], Option[R]]) -&gt; Option[R]:\n    \"\"\"Applies function to the elements of the `Iterator` and returns the first Some(R) result.\n\n    `Iter.find_map(f)` is equivalent to `Iter.filter_map(f).next()`.\n\n    Args:\n        func (Callable[[T], Option[R]]): Function to apply to each element, returning an `Option[R]`.\n\n    Returns:\n        Option[R]: The first `Some(R)` result from applying `func`, or `NONE` if no such result is found.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Option[int]:\n    ...     try:\n    ...         return pc.Some(int(s))\n    ...     except ValueError:\n    ...         return pc.NONE\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([\"lol\", \"NaN\", \"2\", \"5\"]).find_map(_parse)\n    Some(2)\n\n    ```\n    \"\"\"\n    return self.filter_map(func).next()\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.first","level":2,"title":"<code>first()</code>","text":"<p>Return the first element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The first element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9]).first()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def first(self) -&gt; T:\n    \"\"\"Return the first element.\n\n    Returns:\n        T: The first element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9]).first()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.first(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.flat_map","level":2,"title":"<code>flat_map(func)</code>","text":"<p>Creates an iterator that applies a function to each element of the original iterator and flattens the result.</p> <p>This is useful when the func you want to pass to <code>.map()</code> itself returns an iterable, and you want to avoid having nested iterables in the output.</p> <p>This is equivalent to calling <code>.map(func).flatten()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Iterable[R]]</code> <p>Function to apply to each element.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterable of flattened transformed elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).flat_map(lambda x: range(x)).collect()\nSeq(0, 0, 1, 0, 1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def flat_map[R](self, func: Callable[[T], Iterable[R]]) -&gt; Iter[R]:\n    \"\"\"Creates an iterator that applies a function to each element of the original iterator and flattens the result.\n\n    This is useful when the **func** you want to pass to `.map()` itself returns an iterable, and you want to avoid having nested iterables in the output.\n\n    This is equivalent to calling `.map(func).flatten()`.\n\n    Args:\n        func (Callable[[T], Iterable[R]]): Function to apply to each element.\n\n    Returns:\n        Iter[R]: An iterable of flattened transformed elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).flat_map(lambda x: range(x)).collect()\n    Seq(0, 0, 1, 0, 1, 2)\n\n    ```\n    \"\"\"\n    return Iter(itertools.chain.from_iterable(map(func, self._inner)))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.flatten","level":2,"title":"<code>flatten()</code>","text":"<pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[int]\n</code></pre> <p>Flatten one level of nesting and return a new Iterable wrapper.</p> <p>This is a shortcut for <code>.apply(itertools.chain.from_iterable)</code>.</p> <p>Returns:</p> Type Description <code>Iter[Any]</code> <p>Iter[Any]: An iterable of flattened elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([[1, 2], [3]]).flatten().collect()\nSeq(1, 2, 3)\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def flatten[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Any]:\n    \"\"\"Flatten one level of nesting and return a new Iterable wrapper.\n\n    This is a shortcut for `.apply(itertools.chain.from_iterable)`.\n\n    Returns:\n        Iter[Any]: An iterable of flattened elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([[1, 2], [3]]).flatten().collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Iter(itertools.chain.from_iterable(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.fold","level":2,"title":"<code>fold(init, func)</code>","text":"<p>Fold every element into an accumulator by applying an operation, returning the final result.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>B</code> <p>Initial value for the accumulator.</p> required <code>func</code> <code>Callable[[B, T], B]</code> <p>Function that takes the accumulator and current element, returning the new accumulator value.</p> required <p>Returns:</p> Name Type Description <code>B</code> <code>B</code> <p>The final accumulated value.</p> Note <p>This is similar to <code>reduce()</code> but with an initial value, making it equivalent to Python's <code>functools.reduce()</code> with an initializer.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n6\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n16\n&gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n'abc'\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def fold[B](self, init: B, func: Callable[[B, T], B]) -&gt; B:\n    \"\"\"Fold every element into an accumulator by applying an operation, returning the final result.\n\n    Args:\n        init (B): Initial value for the accumulator.\n        func (Callable[[B, T], B]): Function that takes the accumulator and current element,\n            returning the new accumulator value.\n\n    Returns:\n        B: The final accumulated value.\n\n    Note:\n        This is similar to `reduce()` but with an initial value, making it equivalent to\n        Python's `functools.reduce()` with an initializer.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n    6\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n    16\n    &gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n    'abc'\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner, init)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.for_each","level":2,"title":"<code>for_each(func, *args, **kwargs)</code>","text":"<p>Consume the Iterator by applying a function to each element in the iterable.</p> <p>Is a terminal operation, and is useful for functions that have side effects, or when you want to force evaluation of a lazy iterable.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[T, P], Any]</code> <p>Function to apply to each element.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This is a terminal operation with no return value.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).iter().for_each(lambda x: print(x + 1))\n2\n3\n4\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def for_each[**P](\n    self,\n    func: Callable[Concatenate[T, P], Any],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; None:\n    \"\"\"Consume the Iterator by applying a function to each element in the iterable.\n\n    Is a terminal operation, and is useful for functions that have side effects,\n    or when you want to force evaluation of a lazy iterable.\n\n    Args:\n        func (Callable[Concatenate[T, P], Any]): Function to apply to each element.\n        *args (P.args): Positional arguments for the function.\n        **kwargs (P.kwargs): Keyword arguments for the function.\n\n    Returns:\n        None: This is a terminal operation with no return value.\n\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).iter().for_each(lambda x: print(x + 1))\n    2\n    3\n    4\n\n    ```\n    \"\"\"\n    for v in self._inner:\n        func(v, *args, **kwargs)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.for_each_star","level":2,"title":"<code>for_each_star(func)</code>","text":"<pre><code>for_each_star(func: Callable[[Any], R]) -&gt; None\n</code></pre><pre><code>for_each_star(func: Callable[[T1, T2], R]) -&gt; None\n</code></pre><pre><code>for_each_star(func: Callable[[T1, T2, T3], R]) -&gt; None\n</code></pre><pre><code>for_each_star(func: Callable[[T1, T2, T3, T4], R]) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R\n    ],\n) -&gt; None\n</code></pre> <p>Consume the <code>Iterator</code> by applying a function to each unpacked item in the iterable.</p> <p>Is a terminal operation, and is useful for functions that have side effects, or when you want to force evaluation of a lazy iterable.</p> <p>Each item yielded by the iterator is expected to be an iterable itself (e.g., a tuple or list), and its elements are unpacked as arguments to the provided function.</p> <p>This is often used after methods like <code>zip()</code> or <code>enumerate()</code> that yield tuples.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>Function to apply to each unpacked element.</p> required <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([(1, 2), (3, 4)]).for_each_star(lambda x, y: print(x + y))\n3\n7\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def for_each_star[U: Iterable[Any], R](\n    self: Iter[U],\n    func: Callable[..., R],\n) -&gt; None:\n    \"\"\"Consume the `Iterator` by applying a function to each unpacked item in the iterable.\n\n    Is a terminal operation, and is useful for functions that have side effects,\n    or when you want to force evaluation of a lazy iterable.\n\n    Each item yielded by the iterator is expected to be an iterable itself (e.g., a tuple or list),\n    and its elements are unpacked as arguments to the provided function.\n\n    This is often used after methods like `zip()` or `enumerate()` that yield tuples.\n\n    Args:\n        func (Callable[..., R]): Function to apply to each unpacked element.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([(1, 2), (3, 4)]).for_each_star(lambda x, y: print(x + y))\n    3\n    7\n\n    ```\n    \"\"\"\n    for item in self._inner:\n        func(*item)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.from_count","level":2,"title":"<code>from_count(start=0, step=1)</code>  <code>staticmethod</code>","text":"<p>Create an infinite <code>Iterator</code> of evenly spaced values.</p> <p>Warning ‚ö†Ô∏è     This creates an infinite iterator.     Be sure to use <code>Iter.take()</code> or <code>Iter.slice()</code> to limit the number of items taken.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>Starting value of the sequence. Defaults to 0.</p> <code>0</code> <code>step</code> <code>int</code> <p>Difference between consecutive values. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>Iter[int]</code> <p>Iter[int]: An iterator generating the sequence.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter.from_count(10, 2).take(3).collect()\nSeq(10, 12, 14)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef from_count(start: int = 0, step: int = 1) -&gt; Iter[int]:\n    \"\"\"Create an infinite `Iterator` of evenly spaced values.\n\n    **Warning** ‚ö†Ô∏è\n        This creates an infinite iterator.\n        Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n    Args:\n        start (int): Starting value of the sequence. Defaults to 0.\n        step (int): Difference between consecutive values. Defaults to 1.\n\n    Returns:\n        Iter[int]: An iterator generating the sequence.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter.from_count(10, 2).take(3).collect()\n    Seq(10, 12, 14)\n\n    ```\n    \"\"\"\n    return Iter(itertools.count(start, step))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.from_fn","level":2,"title":"<code>from_fn(f)</code>  <code>staticmethod</code>","text":"<p>Create an <code>Iter</code> from a nullary generator function.</p> <p>The callable must return:</p> <ul> <li><code>Some(value)</code> to yield a value</li> <li><code>NONE</code> to stop</li> </ul> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], Option[R]]</code> <p>Callable that returns the next item wrapped in <code>Option</code>.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator yielding values produced by f.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; counter = 0\n&gt;&gt;&gt; def gen() -&gt; pc.Option[int]:\n...     global counter\n...     counter += 1\n...     return pc.Some(counter) if counter &lt; 6 else pc.NONE\n&gt;&gt;&gt; pc.Iter.from_fn(gen).collect()\nSeq(1, 2, 3, 4, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef from_fn[R](f: Callable[[], Option[R]]) -&gt; Iter[R]:\n    \"\"\"Create an `Iter` from a nullary generator function.\n\n    The callable must return:\n\n    - `Some(value)` to yield a value\n    - `NONE` to stop\n\n\n    Args:\n        f (Callable[[], Option[R]]): Callable that returns the next item wrapped in `Option`.\n\n    Returns:\n        Iter[R]: An iterator yielding values produced by **f**.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; counter = 0\n    &gt;&gt;&gt; def gen() -&gt; pc.Option[int]:\n    ...     global counter\n    ...     counter += 1\n    ...     return pc.Some(counter) if counter &lt; 6 else pc.NONE\n    &gt;&gt;&gt; pc.Iter.from_fn(gen).collect()\n    Seq(1, 2, 3, 4, 5)\n\n    ```\n    \"\"\"\n\n    def _from_fn() -&gt; Iterator[R]:\n        while True:\n            item = f()\n            if item.is_none():\n                return\n            yield item.unwrap()\n\n    return Iter(_from_fn())\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.ge","level":2,"title":"<code>ge(other)</code>","text":"<p>Check if this Iterable is greater than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ge(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.group_by","level":2,"title":"<code>group_by(key=None)</code>","text":"<pre><code>group_by(key: None = None) -&gt; Iter[tuple[T, Iter[T]]]\n</code></pre><pre><code>group_by(key: Callable[[T], K]) -&gt; Iter[tuple[K, Iter[T]]]\n</code></pre><pre><code>group_by(\n    key: Callable[[T], K] | None = None,\n) -&gt; Iter[tuple[K, Iter[T]] | tuple[T, Iter[T]]]\n</code></pre> <p>Make an <code>Iter</code> that returns consecutive keys and groups from the iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to compute the key for grouping. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[Any | T, Iter[T]]]</code> <p>Iter[tuple[Any | T, Iter[T]]]: An <code>Iter</code> of <code>(key, value)</code> tuples.</p> <p>The values yielded are <code>(K, Iter[T])</code> tuples, where the first element is the group key and the second element is an <code>Iter</code> of type <code>T</code> over the group values.</p> <p>The key is a function computing a key value for each element.</p> <p>If not specified or is None, key defaults to an identity function and returns the element unchanged.</p> <p>The <code>Iter</code> needs to already be sorted on the same key function.</p> <p>This is due to the fact that it generates a new <code>Group</code> every time the value of the key function changes.</p> <p>That behavior differs from SQL's <code>GROUP BY</code> which aggregates common elements regardless of their input order.</p> <p>Warning ‚ö†Ô∏è     You MUST materialize the second element of the tuple immediately** when iterating over groups!</p> <pre><code>Because `.group_by()` uses Python's `itertools.groupby` under the hood, each group's iterator shares internal state.\nWhen you advance to the next group, the previous group's iterator becomes invalid and will yield empty results.\n</code></pre> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Example 1: Group even and odd numbers\n&gt;&gt;&gt; (\n... pc.Iter.from_count() # create an infinite iterator of integers\n... .take(8) # take the first 8\n... .map(lambda x: (x % 2 == 0, x)) # map to (is_even, value)\n... .sort(key=lambda x: x[0]) # sort by is_even\n... .iter() # Since sort collect to a Vec, we need to convert back to Iter\n... .group_by(lambda x: x[0]) # group by is_even\n... .map_star(lambda g, vals: (g, vals.map_star(lambda _, y: y).into(list))) # extract values from groups, discarding keys, and materializing them to lists\n... .collect() # collect the result\n... .into(dict) # convert to dict\n... )\n{False: [1, 3, 5, 7], True: [0, 2, 4, 6]}\n&gt;&gt;&gt; # Example 2: Group by a common key, already sorted\n&gt;&gt;&gt; data = [\n...     {\"name\": \"Alice\", \"gender\": \"F\"},\n...     {\"name\": \"Bob\", \"gender\": \"M\"},\n...     {\"name\": \"Charlie\", \"gender\": \"M\"},\n...     {\"name\": \"Dan\", \"gender\": \"M\"},\n... ]\n&gt;&gt;&gt; (\n... pc.Iter(data)\n... .group_by(lambda x: x[\"gender\"]) # group by the gender key\n... .map_star(lambda g, vals: (g, vals.length())) # get the length of each group\n... .collect()\n... )\nSeq(('F', 1), ('M', 3))\n&gt;&gt;&gt; # Example 3: Incorrect usage with LATE materialization:\n&gt;&gt;&gt; groups = pc.Iter([\"a1\", \"a2\", \"b1\"]).group_by(lambda x: x[0]).collect()\n&gt;&gt;&gt; # Now iterate - TOO LATE! The group iterators are consumed\n&gt;&gt;&gt; for g in groups:\n...     print(g[1].collect())  # ‚ùå Empty!\nSeq()\nSeq()\n&gt;&gt;&gt; # Example 4: Correct usage with intermediate materialization:\n&gt;&gt;&gt; groups = (\n...     pc.Iter([\"a1\", \"a2\", \"b1\"])\n...     .group_by(lambda x: x[0])\n...     .map_star(lambda g, vals: (g, vals.collect()))  # ‚úÖ Materialize NOW\n...     .collect()\n...     .iter()\n...     .for_each(lambda x: print(f\"{x[0]}: {x[1]}\"))\n... )\na: Seq('a1', 'a2')\nb: Seq('b1',)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def group_by(\n    self, key: Callable[[T], Any] | None = None\n) -&gt; Iter[tuple[Any | T, Iter[T]]]:\n    \"\"\"Make an `Iter` that returns consecutive keys and groups from the iterable.\n\n    Args:\n        key (Callable[[T], Any] | None): Function to compute the key for grouping. Defaults to None.\n\n    Returns:\n        Iter[tuple[Any | T, Iter[T]]]: An `Iter` of `(key, value)` tuples.\n\n    The values yielded are `(K, Iter[T])` tuples, where the first element is the group key and the second element is an `Iter` of type `T` over the group values.\n\n    The **key** is a function computing a key value for each element.\n\n    If not specified or is None, **key** defaults to an identity function and returns the element unchanged.\n\n    The `Iter` needs to already be sorted on the same key function.\n\n    This is due to the fact that it generates a new `Group` every time the value of the **key** function changes.\n\n    That behavior differs from SQL's `GROUP BY` which aggregates common elements regardless of their input order.\n\n    **Warning** ‚ö†Ô∏è\n        **You MUST materialize the second element of the tuple **immediately** when iterating over groups!\n\n        Because `.group_by()` uses Python's `itertools.groupby` under the hood, each group's iterator shares internal state.\n        When you advance to the next group, the previous group's iterator becomes invalid and will yield empty results.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Example 1: Group even and odd numbers\n    &gt;&gt;&gt; (\n    ... pc.Iter.from_count() # create an infinite iterator of integers\n    ... .take(8) # take the first 8\n    ... .map(lambda x: (x % 2 == 0, x)) # map to (is_even, value)\n    ... .sort(key=lambda x: x[0]) # sort by is_even\n    ... .iter() # Since sort collect to a Vec, we need to convert back to Iter\n    ... .group_by(lambda x: x[0]) # group by is_even\n    ... .map_star(lambda g, vals: (g, vals.map_star(lambda _, y: y).into(list))) # extract values from groups, discarding keys, and materializing them to lists\n    ... .collect() # collect the result\n    ... .into(dict) # convert to dict\n    ... )\n    {False: [1, 3, 5, 7], True: [0, 2, 4, 6]}\n    &gt;&gt;&gt; # Example 2: Group by a common key, already sorted\n    &gt;&gt;&gt; data = [\n    ...     {\"name\": \"Alice\", \"gender\": \"F\"},\n    ...     {\"name\": \"Bob\", \"gender\": \"M\"},\n    ...     {\"name\": \"Charlie\", \"gender\": \"M\"},\n    ...     {\"name\": \"Dan\", \"gender\": \"M\"},\n    ... ]\n    &gt;&gt;&gt; (\n    ... pc.Iter(data)\n    ... .group_by(lambda x: x[\"gender\"]) # group by the gender key\n    ... .map_star(lambda g, vals: (g, vals.length())) # get the length of each group\n    ... .collect()\n    ... )\n    Seq(('F', 1), ('M', 3))\n    &gt;&gt;&gt; # Example 3: Incorrect usage with LATE materialization:\n    &gt;&gt;&gt; groups = pc.Iter([\"a1\", \"a2\", \"b1\"]).group_by(lambda x: x[0]).collect()\n    &gt;&gt;&gt; # Now iterate - TOO LATE! The group iterators are consumed\n    &gt;&gt;&gt; for g in groups:\n    ...     print(g[1].collect())  # ‚ùå Empty!\n    Seq()\n    Seq()\n    &gt;&gt;&gt; # Example 4: Correct usage with intermediate materialization:\n    &gt;&gt;&gt; groups = (\n    ...     pc.Iter([\"a1\", \"a2\", \"b1\"])\n    ...     .group_by(lambda x: x[0])\n    ...     .map_star(lambda g, vals: (g, vals.collect()))  # ‚úÖ Materialize NOW\n    ...     .collect()\n    ...     .iter()\n    ...     .for_each(lambda x: print(f\"{x[0]}: {x[1]}\"))\n    ... )\n    a: Seq('a1', 'a2')\n    b: Seq('b1',)\n\n    ```\n    \"\"\"\n    return Iter((x, Iter(y)) for x, y in itertools.groupby(self._inner, key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.gt","level":2,"title":"<code>gt(other)</code>","text":"<p>Check if this Iterable is greater than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def gt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.insert","level":2,"title":"<code>insert(value)</code>","text":"<p>Prepend the value to the <code>Iter</code>.</p> <p>This can be useful when you want to add an element at the beginning of an existing iterable sequence.</p> <p>Use <code>.chain()</code> to add multiple elements (at the end of the <code>Iterator</code>).</p> Note <p>This can be considered the equivalent as <code>list.append()</code>, but for <code>Iter</code>. However, append add the value at the end, while insert add it at the beginning.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to prepend.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new Iterable wrapper with the value prepended.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((2, 3)).insert(1).collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def insert(self, value: T) -&gt; Iter[T]:\n    \"\"\"Prepend the **value** to the `Iter`.\n\n    This can be useful when you want to add an element at the beginning of an existing iterable sequence.\n\n    Use `.chain()` to add multiple elements (at the end of the `Iterator`).\n\n    Note:\n        This can be considered the equivalent as `list.append()`, but for `Iter`.\n        However, append add the value at the **end**, while insert add it at the **beginning**.\n\n    Args:\n        value (T): The value to prepend.\n\n    Returns:\n        Iter[T]: A new Iterable wrapper with the value prepended.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((2, 3)).insert(1).collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.cons(value, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.interleave","level":2,"title":"<code>interleave(*others)</code>","text":"<p>Interleave multiple sequences element-wise.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to interleave.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new Iterable wrapper with interleaved elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2)).interleave((3, 4)).collect()\nSeq(1, 3, 2, 4)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def interleave(self, *others: Iterable[T]) -&gt; Iter[T]:\n    \"\"\"Interleave multiple sequences element-wise.\n\n    Args:\n        *others (Iterable[T]): Other iterables to interleave.\n\n    Returns:\n        Iter[T]: A new Iterable wrapper with interleaved elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2)).interleave((3, 4)).collect()\n    Seq(1, 3, 2, 4)\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.interleave((self._inner, *others)))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.intersperse","level":2,"title":"<code>intersperse(element)</code>","text":"<p>Creates a new iterator which places a copy of separator between adjacent items of the original iterator.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>T</code> <p>The element to interpose between items.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new <code>Iter</code> with the element interposed.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Simple example with numbers\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).intersperse(0).collect()\nSeq(1, 0, 2, 0, 3)\n&gt;&gt;&gt; # Useful when chaining with other operations\n&gt;&gt;&gt; pc.Iter([10, 20, 30]).intersperse(5).sum()\n70\n&gt;&gt;&gt; # Inserting separators between groups, then flattening\n&gt;&gt;&gt; pc.Iter([[1, 2], [3, 4], [5, 6]]).intersperse([-1]).flatten().collect()\nSeq(1, 2, -1, 3, 4, -1, 5, 6)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def intersperse(self, element: T) -&gt; Iter[T]:\n    \"\"\"Creates a new iterator which places a copy of separator between adjacent items of the original iterator.\n\n    Args:\n        element (T): The element to interpose between items.\n\n    Returns:\n        Iter[T]: A new `Iter` with the element interposed.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Simple example with numbers\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).intersperse(0).collect()\n    Seq(1, 0, 2, 0, 3)\n    &gt;&gt;&gt; # Useful when chaining with other operations\n    &gt;&gt;&gt; pc.Iter([10, 20, 30]).intersperse(5).sum()\n    70\n    &gt;&gt;&gt; # Inserting separators between groups, then flattening\n    &gt;&gt;&gt; pc.Iter([[1, 2], [3, 4], [5, 6]]).intersperse([-1]).flatten().collect()\n    Seq(1, 2, -1, 3, 4, -1, 5, 6)\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.interpose(element, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.is_sorted","level":2,"title":"<code>is_sorted(key=None, *, reverse=False, strict=False)</code>","text":"<p>Returns True if the items of iterable are in sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to check for descending order. Defaults to False.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Whether to enforce strict sorting (no equal elements). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if items are sorted according to the criteria, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\nTrue\n&gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\nFalse\n\nIf strict, tests for strict sorting, that is, returns False if equal elements are found:\n```python\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\nFalse\n</code></pre></p> <p>The function returns False after encountering the first out-of-order item.</p> <p>This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).</p> <p>If there are no out-of-order items, the iterable is exhausted.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_sorted[U](\n    self,\n    key: Callable[[T], U] | None = None,\n    *,\n    reverse: bool = False,\n    strict: bool = False,\n) -&gt; bool:\n    \"\"\"Returns True if the items of iterable are in sorted order.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n        reverse (bool): Whether to check for descending order. Defaults to False.\n        strict (bool): Whether to enforce strict sorting (no equal elements). Defaults to False.\n\n    Returns:\n        bool: True if items are sorted according to the criteria, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\n    True\n    &gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\n    False\n\n    If strict, tests for strict sorting, that is, returns False if equal elements are found:\n    ```python\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\n    False\n\n    ```\n\n    The function returns False after encountering the first out-of-order item.\n\n    This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).\n\n    If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n    return mit.is_sorted(self._inner, key=key, reverse=reverse, strict=strict)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.is_strictly_n","level":2,"title":"<code>is_strictly_n(n)</code>","text":"<p>Yield<code>Ok[T]</code> as long as the iterable has exactly n items.</p> <p>If it has fewer than n items, yield <code>Err[ValueError]</code> with the actual number of items.</p> <p>If it has more than n items, yield <code>Err[ValueError]</code> with the number <code>n + 1</code>.</p> <p>Note that the returned iterable must be consumed in order for the check to be made.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The exact number of items expected.</p> required <p>Returns:</p> Type Description <code>Iter[Result[T, ValueError]]</code> <p>Iter[Result[T, ValueError]]: A new Iterable wrapper yielding results based on the item count.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [\"a\", \"b\", \"c\", \"d\"]\n&gt;&gt;&gt; n = 4\n&gt;&gt;&gt; pc.Iter(data).is_strictly_n(n).collect()\nSeq(Ok('a'), Ok('b'), Ok('c'), Ok('d'))\n&gt;&gt;&gt; pc.Iter(\"ab\").is_strictly_n(3).collect()  # doctest: +NORMALIZE_WHITESPACE\nSeq(Ok('a'), Ok('b'),\nErr(ValueError('Too few items in iterable (got 2)')))\n&gt;&gt;&gt; pc.Iter(\"abc\").is_strictly_n(2).collect()  # doctest: +NORMALIZE_WHITESPACE\nSeq(Ok('a'), Ok('b'),\nErr(ValueError('Too many items in iterable (got at least 3)')))\n</code></pre> You can easily combine this with <code>.map(lambda r: r.map_err(...))</code> to handle the errors as you wish. <pre><code>&gt;&gt;&gt; def _my_err(e: ValueError) -&gt; str:\n...     return f\"custom error: {e}\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([1]).is_strictly_n(0).map(lambda r: r.map_err(_my_err)).collect()\nSeq(Err('custom error: Too many items in iterable (got at least 1)'),)\n</code></pre> Or use <code>.filter_map(...)</code> to only keep the <code>Ok</code> values. <pre><code>&gt;&gt;&gt; pc.Iter([1, 2, 3]).is_strictly_n(2).filter_map(lambda r: r.ok()).collect()\nSeq(1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_strictly_n(self, n: int) -&gt; Iter[Result[T, ValueError]]:\n    \"\"\"Yield`Ok[T]` as long as the iterable has exactly *n* items.\n\n    If it has fewer than *n* items, yield `Err[ValueError]` with the actual number of items.\n\n    If it has more than *n* items, yield `Err[ValueError]` with the number `n + 1`.\n\n    Note that the returned iterable must be consumed in order for the check to\n    be made.\n\n    Args:\n        n (int): The exact number of items expected.\n\n    Returns:\n        Iter[Result[T, ValueError]]: A new Iterable wrapper yielding results based on the item count.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [\"a\", \"b\", \"c\", \"d\"]\n    &gt;&gt;&gt; n = 4\n    &gt;&gt;&gt; pc.Iter(data).is_strictly_n(n).collect()\n    Seq(Ok('a'), Ok('b'), Ok('c'), Ok('d'))\n    &gt;&gt;&gt; pc.Iter(\"ab\").is_strictly_n(3).collect()  # doctest: +NORMALIZE_WHITESPACE\n    Seq(Ok('a'), Ok('b'),\n    Err(ValueError('Too few items in iterable (got 2)')))\n    &gt;&gt;&gt; pc.Iter(\"abc\").is_strictly_n(2).collect()  # doctest: +NORMALIZE_WHITESPACE\n    Seq(Ok('a'), Ok('b'),\n    Err(ValueError('Too many items in iterable (got at least 3)')))\n\n    ```\n    You can easily combine this with `.map(lambda r: r.map_err(...))` to handle the errors as you wish.\n    ```python\n    &gt;&gt;&gt; def _my_err(e: ValueError) -&gt; str:\n    ...     return f\"custom error: {e}\"\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([1]).is_strictly_n(0).map(lambda r: r.map_err(_my_err)).collect()\n    Seq(Err('custom error: Too many items in iterable (got at least 1)'),)\n\n    ```\n    Or use `.filter_map(...)` to only keep the `Ok` values.\n    ```python\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).is_strictly_n(2).filter_map(lambda r: r.ok()).collect()\n    Seq(1, 2)\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    def _strictly_n_(data: Iterator[T]) -&gt; Iterator[Result[T, ValueError]]:\n        sent = 0\n        for item in itertools.islice(data, n):\n            yield Ok(item)\n            sent += 1\n\n        if sent &lt; n:\n            e = ValueError(f\"Too few items in iterable (got {sent})\")\n            yield Err(e)\n\n        for _ in data:\n            e = ValueError(f\"Too many items in iterable (got at least {n + 1})\")\n            yield Err(e)\n\n    return Iter(_strictly_n_(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.iter","level":2,"title":"<code>iter()</code>","text":"<p>Get an iterator over the <code>Iterable</code>.</p> <p>Call this to switch to lazy evaluation.</p> <p>Calling this method on an <code>Iter</code> instance has no effect.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> over the <code>Iterable</code>.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Get an iterator over the `Iterable`.\n\n    Call this to switch to lazy evaluation.\n\n    Calling this method on an `Iter` instance has no effect.\n\n    Returns:\n        Iter[T]: An `Iterator` over the `Iterable`.\n    \"\"\"\n    return Iter(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.join","level":2,"title":"<code>join(sep)</code>","text":"<p>Join all elements of the <code>Iterable</code> into a single <code>string</code>, with a specified separator.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>str</code> <p>Separator to use between elements.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The joined string.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n'a-b-c'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def join(self: BaseIter[str], sep: str) -&gt; str:\n    \"\"\"Join all elements of the `Iterable` into a single `string`, with a specified separator.\n\n    Args:\n        sep (str): Separator to use between elements.\n\n    Returns:\n        str: The joined string.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n    'a-b-c'\n\n    ```\n    \"\"\"\n    return sep.join(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.join_with","level":2,"title":"<code>join_with(other, left_on, right_on, left_default=None, right_default=None)</code>","text":"<p>Perform a relational join with another iterable.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[R]</code> <p>Iterable to join with.</p> required <code>left_on</code> <code>Callable[[T], K]</code> <p>Function to extract the join key from the left iterable.</p> required <code>right_on</code> <code>Callable[[R], K]</code> <p>Function to extract the join key from the right iterable.</p> required <code>left_default</code> <code>T | None</code> <p>Default value for missing elements in the left iterable. Defaults to None.</p> <code>None</code> <code>right_default</code> <code>R | None</code> <p>Default value for missing elements in the right iterable. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, R]]</code> <p>Iter[tuple[T, R]]: An iterator yielding tuples of joined elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; sizes = [\"S\", \"M\"]\n&gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).join_with(sizes, left_on=lambda c: c, right_on=lambda s: s).collect()\nSeq((None, 'S'), (None, 'M'), ('blue', None), ('red', None))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def join_with[R, K](\n    self,\n    other: Iterable[R],\n    left_on: Callable[[T], K],\n    right_on: Callable[[R], K],\n    left_default: T | None = None,\n    right_default: R | None = None,\n) -&gt; Iter[tuple[T, R]]:\n    \"\"\"Perform a relational join with another iterable.\n\n    Args:\n        other (Iterable[R]): Iterable to join with.\n        left_on (Callable[[T], K]): Function to extract the join key from the left iterable.\n        right_on (Callable[[R], K]): Function to extract the join key from the right iterable.\n        left_default (T | None): Default value for missing elements in the left iterable. Defaults to None.\n        right_default (R | None): Default value for missing elements in the right iterable. Defaults to None.\n\n    Returns:\n        Iter[tuple[T, R]]: An iterator yielding tuples of joined elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; sizes = [\"S\", \"M\"]\n    &gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).join_with(sizes, left_on=lambda c: c, right_on=lambda s: s).collect()\n    Seq((None, 'S'), (None, 'M'), ('blue', None), ('red', None))\n\n    ```\n    \"\"\"\n    return Iter(\n        cz.itertoolz.join(\n            leftkey=left_on,\n            leftseq=self._inner,\n            rightkey=right_on,\n            rightseq=other,\n            left_default=left_default,\n            right_default=right_default,\n        )\n    )\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.last","level":2,"title":"<code>last()</code>","text":"<p>Return the last element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The last element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def last(self) -&gt; T:\n    \"\"\"Return the last element.\n\n    Returns:\n        T: The last element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.last(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.le","level":2,"title":"<code>le(other)</code>","text":"<p>Check if this Iterable is less than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def le(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.length","level":2,"title":"<code>length()</code>","text":"<p>Return the length of the Iterable.</p> <p>Like the builtin len but works on lazy sequences.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The count of elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).length()\n2\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def length(self) -&gt; int:\n    \"\"\"Return the length of the Iterable.\n\n    Like the builtin len but works on lazy sequences.\n\n    Returns:\n        int: The count of elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).length()\n    2\n\n    ```\n    \"\"\"\n    return cz.itertoolz.count(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.lt","level":2,"title":"<code>lt(other)</code>","text":"<p>Check if this Iterable is less than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def lt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map","level":2,"title":"<code>map(func)</code>","text":"<p>Apply a function to each element of the iterable.</p> <p>If you are good at thinking in types, you can think of map() like this:     If you have an iterator that gives you elements of some type A, and you want an iterator of some other type B, you can use map(),     passing a closure that takes an A and returns a B.</p> <p>map() is conceptually similar to a for loop.</p> <p>However, as map() is lazy, it is best used when you are already working with other iterators.</p> <p>If you are doing some sort of looping for a side effect, it is considered more idiomatic to use <code>for_each</code> than map().</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], R]</code> <p>Function to apply to each element.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator of transformed elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).map(lambda x: x + 1).collect()\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map[R](self, func: Callable[[T], R]) -&gt; Iter[R]:\n    \"\"\"Apply a function to each element of the iterable.\n\n    If you are good at thinking in types, you can think of map() like this:\n        If you have an iterator that gives you elements of some type A, and you want an iterator of some other type B, you can use map(),\n        passing a closure that takes an A and returns a B.\n\n    map() is conceptually similar to a for loop.\n\n    However, as map() is lazy, it is best used when you are already working with other iterators.\n\n    If you are doing some sort of looping for a side effect, it is considered more idiomatic to use `for_each` than map().\n\n    Args:\n        func (Callable[[T], R]): Function to apply to each element.\n\n    Returns:\n        Iter[R]: An iterator of transformed elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).map(lambda x: x + 1).collect()\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Iter(map(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_juxt","level":2,"title":"<code>map_juxt(*funcs)</code>","text":"<pre><code>map_juxt(\n    func1: Callable[[T], R1], func2: Callable[[T], R2]\n) -&gt; Iter[tuple[R1, R2]]\n</code></pre><pre><code>map_juxt(\n    func1: Callable[[T], R1],\n    func2: Callable[[T], R2],\n    func3: Callable[[T], R3],\n) -&gt; Iter[tuple[R1, R2, R3]]\n</code></pre><pre><code>map_juxt(\n    func1: Callable[[T], R1],\n    func2: Callable[[T], R2],\n    func3: Callable[[T], R3],\n    func4: Callable[[T], R4],\n) -&gt; Iter[tuple[R1, R2, R3, R4]]\n</code></pre> <p>Apply several functions to each item.</p> <p>Returns a new Iter where each item is a tuple of the results of applying each function to the original item.</p> <p>Parameters:</p> Name Type Description Default <code>*funcs</code> <code>Callable[[T], object]</code> <p>Functions to apply to each item.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[tuple[object, ...]]</code> <p>Iter[tuple[object, ...]]: An iterable of tuples containing the results of each function.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n...     return n % 2 == 0\n&gt;&gt;&gt; def is_positive(n: int) -&gt; bool:\n...     return n &gt; 0\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([1, -2, 3]).map_juxt(is_even, is_positive).collect()\nSeq((False, True), (True, False), (False, True))\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_juxt(self, *funcs: Callable[[T], object]) -&gt; Iter[tuple[object, ...]]:\n    \"\"\"Apply several functions to each item.\n\n    Returns a new Iter where each item is a tuple of the results of applying each function to the original item.\n\n    Args:\n        *funcs (Callable[[T], object]): Functions to apply to each item.\n\n    Returns:\n        Iter[tuple[object, ...]]: An iterable of tuples containing the results of each function.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n    ...     return n % 2 == 0\n    &gt;&gt;&gt; def is_positive(n: int) -&gt; bool:\n    ...     return n &gt; 0\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([1, -2, 3]).map_juxt(is_even, is_positive).collect()\n    Seq((False, True), (True, False), (False, True))\n\n    ```\n    \"\"\"\n    return Iter(map(cz.functoolz.juxt(*funcs), self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_star","level":2,"title":"<code>map_star(func)</code>","text":"<pre><code>map_star(func: Callable[[Any], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2, T3], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2, T3, T4], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R\n    ],\n) -&gt; Iter[R]\n</code></pre> <p>Applies a function to each element.where each element is an iterable.</p> <p>Unlike <code>.map()</code>, which passes each element as a single argument, <code>.starmap()</code> unpacks each element into positional arguments for the function.</p> <p>In short, for each <code>element</code> in the sequence, it computes <code>func(*element)</code>.</p> <ul> <li>Use map_star when the performance matters (it is faster).</li> <li>Use map with unpacking when readability matters (the types can be inferred).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>Function to apply to unpacked elements.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterable of results from applying the function to unpacked elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def make_sku(color: str, size: str) -&gt; str:\n...     return f\"{color}-{size}\"\n&gt;&gt;&gt; data = pc.Seq([\"blue\", \"red\"])\n&gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map_star(make_sku).collect()\nSeq('blue-S', 'blue-M', 'red-S', 'red-M')\n&gt;&gt;&gt; # This is equivalent to:\n&gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map(lambda x: make_sku(*x)).collect()\nSeq('blue-S', 'blue-M', 'red-S', 'red-M')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_star[U: Iterable[Any], R](\n    self: Iter[U],\n    func: Callable[..., R],\n) -&gt; Iter[R]:\n    \"\"\"Applies a function to each element.where each element is an iterable.\n\n    Unlike `.map()`, which passes each element as a single argument,\n    `.starmap()` unpacks each element into positional arguments for the function.\n\n    In short, for each `element` in the sequence, it computes `func(*element)`.\n\n    - Use map_star when the performance matters (it is faster).\n    - Use map with unpacking when readability matters (the types can be inferred).\n\n    Args:\n        func (Callable[..., R]): Function to apply to unpacked elements.\n\n    Returns:\n        Iter[R]: An iterable of results from applying the function to unpacked elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def make_sku(color: str, size: str) -&gt; str:\n    ...     return f\"{color}-{size}\"\n    &gt;&gt;&gt; data = pc.Seq([\"blue\", \"red\"])\n    &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map_star(make_sku).collect()\n    Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n    &gt;&gt;&gt; # This is equivalent to:\n    &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map(lambda x: make_sku(*x)).collect()\n    Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n\n    ```\n    \"\"\"\n    return Iter(itertools.starmap(func, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_while","level":2,"title":"<code>map_while(func)</code>","text":"<p>Creates an iterator that both yields elements based on a predicate and maps.</p> <p><code>map_while()</code> takes a closure as an argument. It will call this closure on each element of the iterator, and yield elements while it returns <code>Some(_)</code>.</p> <p>After <code>NONE</code> is returned, <code>map_while()</code> stops and the rest of the elements are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Option[R]]</code> <p>Function to apply to each element that returns <code>Option[R]</code>.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator of transformed elements until <code>NONE</code> is encountered.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def checked_div(x: int) -&gt; pc.Option[int]:\n...     return pc.Some(16 // x) if x != 0 else pc.NONE\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = pc.Iter([-1, 4, 0, 1])\n&gt;&gt;&gt; data.map_while(checked_div).collect()\nSeq(-16, 4)\n&gt;&gt;&gt; data = pc.Iter([0, 1, 2, -3, 4, 5, -6])\n&gt;&gt;&gt; # Convert to positive ints, stop at first negative\n&gt;&gt;&gt; data.map_while(lambda x: pc.Some(x) if x &gt;= 0 else pc.NONE).collect()\nSeq(0, 1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_while[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n    \"\"\"Creates an iterator that both yields elements based on a predicate and maps.\n\n    `map_while()` takes a closure as an argument. It will call this closure on each element of\n    the iterator, and yield elements while it returns `Some(_)`.\n\n    After `NONE` is returned, `map_while()` stops and the rest of the elements are ignored.\n\n    Args:\n        func (Callable[[T], Option[R]]): Function to apply to each element that returns `Option[R]`.\n\n    Returns:\n        Iter[R]: An iterator of transformed elements until `NONE` is encountered.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def checked_div(x: int) -&gt; pc.Option[int]:\n    ...     return pc.Some(16 // x) if x != 0 else pc.NONE\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = pc.Iter([-1, 4, 0, 1])\n    &gt;&gt;&gt; data.map_while(checked_div).collect()\n    Seq(-16, 4)\n    &gt;&gt;&gt; data = pc.Iter([0, 1, 2, -3, 4, 5, -6])\n    &gt;&gt;&gt; # Convert to positive ints, stop at first negative\n    &gt;&gt;&gt; data.map_while(lambda x: pc.Some(x) if x &gt;= 0 else pc.NONE).collect()\n    Seq(0, 1, 2)\n\n    ```\n    \"\"\"\n\n    def _gen() -&gt; Generator[R]:\n        for opt in map(func, self._inner):\n            if opt.is_none():\n                return\n            yield opt.unwrap()\n\n    return Iter(_gen())\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_windows","level":2,"title":"<code>map_windows(length, func)</code>","text":"<pre><code>map_windows(\n    length: Literal[1], func: Callable[[tuple[T]], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[2], func: Callable[[tuple[T, T]], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[3], func: Callable[[tuple[T, T, T]], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[4],\n    func: Callable[[tuple[T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[5],\n    func: Callable[[tuple[T, T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: int, func: Callable[[tuple[T, ...]], R]\n) -&gt; Iter[R]\n</code></pre> <p>Calls the given func for each contiguous window of size length over self.</p> <p>The windows during mapping overlaps.</p> <p>The provided function must have a signature matching the length of the window.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of each window.</p> required <code>func</code> <code>Callable[[tuple[Any, ...]], R]</code> <p>Function to apply to each window.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator over the outputs of func.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n\n&gt;&gt;&gt; pc.Iter(\"abcd\").map_windows(2, lambda xy: f\"{xy[0]}+{xy[1]}\").collect()\nSeq('a+b', 'b+c', 'c+d')\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, lambda xy: xy).collect()\nSeq((1, 2), (2, 3), (3, 4))\n&gt;&gt;&gt; def moving_average(seq: tuple[int, ...]) -&gt; float:\n...     return float(sum(seq)) / len(seq)\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, moving_average).collect()\nSeq(1.5, 2.5, 3.5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_windows[R](\n    self, length: int, func: Callable[[tuple[Any, ...]], R]\n) -&gt; Iter[R]:\n    \"\"\"Calls the given **func** for each contiguous window of size **length** over **self**.\n\n    The windows during mapping overlaps.\n\n    The provided function must have a signature matching the length of the window.\n\n    Args:\n        length (int): The length of each window.\n        func (Callable[[tuple[Any, ...]], R]): Function to apply to each window.\n\n    Returns:\n        Iter[R]: An iterator over the outputs of func.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n\n    &gt;&gt;&gt; pc.Iter(\"abcd\").map_windows(2, lambda xy: f\"{xy[0]}+{xy[1]}\").collect()\n    Seq('a+b', 'b+c', 'c+d')\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, lambda xy: xy).collect()\n    Seq((1, 2), (2, 3), (3, 4))\n    &gt;&gt;&gt; def moving_average(seq: tuple[int, ...]) -&gt; float:\n    ...     return float(sum(seq)) / len(seq)\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, moving_average).collect()\n    Seq(1.5, 2.5, 3.5)\n\n    ```\n    \"\"\"\n    return Iter(map(func, cz.itertoolz.sliding_window(length, self._inner)))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.max","level":2,"title":"<code>max()</code>","text":"<p>Return the maximum of the <code>Iterable</code>.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>max_by()</code> instead.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The maximum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n3\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the maximum of the `Iterable`.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `max_by()` instead.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Returns:\n        U: The maximum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n    3\n\n    ```\n    \"\"\"\n    return max(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.max_by","level":2,"title":"<code>max_by(*, key)</code>","text":"<p>Return the maximum element using a custom key function.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the maximum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=4, y='c')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=3, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the maximum element using a custom **key** function.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the maximum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=4, y='c')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=3, y='b')\n\n    ```\n    \"\"\"\n    return max(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.min","level":2,"title":"<code>min()</code>","text":"<p>Return the minimum of the sequence.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>min_by()</code> instead.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The minimum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n1\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the minimum of the sequence.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `min_by()` instead.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Returns:\n        U: The minimum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n    1\n\n    ```\n    \"\"\"\n    return min(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.min_by","level":2,"title":"<code>min_by(*, key)</code>","text":"<p>Return the minimum element using a custom key function.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the minimum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the minimum element using a custom **key** function.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the minimum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n\n    ```\n    \"\"\"\n    return min(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.most_common","level":2,"title":"<code>most_common(n=None)</code>","text":"<p>Return the n most common elements and their counts.</p> <p>If n is None, then all elements are returned.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of most common elements to return. Defaults to None (all elements).</p> <code>None</code> <p>Returns:</p> Type Description <code>Vec[tuple[T, int]]</code> <p>Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\nVec((3, 3), (1, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def most_common(self, n: int | None = None) -&gt; Vec[tuple[T, int]]:\n    \"\"\"Return the n most common elements and their counts.\n\n    If n is None, then all elements are returned.\n\n    Args:\n        n (int | None): Number of most common elements to return. Defaults to None (all elements).\n\n    Returns:\n        Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\n    Vec((3, 3), (1, 2))\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return Vec(Counter(self._inner).most_common(n))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.ne","level":2,"title":"<code>ne(other)</code>","text":"<p>Check if two Iterables are not equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are not equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ne(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are not equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are not equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) != tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.next","level":2,"title":"<code>next()</code>","text":"<p>Return the next element in the iterator.</p> Note <p>The actual <code>.__next__()</code> method is conform to the Python <code>Iterator</code> Protocol, and is what will be actually called if you iterate over the <code>Iter</code> instance.</p> <p><code>Iter.next()</code> is a convenience method that wraps the result in an <code>Option</code> to handle exhaustion gracefully, for custom use cases.</p> <p>Not only for typing, but for performance reasons, and coherence (iter(<code>Iter</code>) and iter(<code>Iter._inner</code>) wouldn't behave consistently otherwise).</p> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The next element in the iterator. <code>Some[T]</code>, or <code>NONE</code> if the iterator is exhausted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; it = pc.Seq([1, 2, 3]).iter()\n&gt;&gt;&gt; it.next().unwrap()\n1\n&gt;&gt;&gt; it.next().unwrap()\n2\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def next(self) -&gt; Option[T]:\n    \"\"\"Return the next element in the iterator.\n\n    Note:\n        The actual `.__next__()` method is conform to the Python `Iterator` Protocol, and is what will be actually called if you iterate over the `Iter` instance.\n\n        `Iter.next()` is a convenience method that wraps the result in an `Option` to handle exhaustion gracefully, for custom use cases.\n\n        Not only for typing, but for performance reasons, and coherence (iter(`Iter`) and iter(`Iter._inner`) wouldn't behave consistently otherwise).\n\n    Returns:\n        Option[T]: The next element in the iterator. `Some[T]`, or `NONE` if the iterator is exhausted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; it = pc.Seq([1, 2, 3]).iter()\n    &gt;&gt;&gt; it.next().unwrap()\n    1\n    &gt;&gt;&gt; it.next().unwrap()\n    2\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(next(self, None))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.nth","level":2,"title":"<code>nth(index)</code>","text":"<p>Return the nth item at index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the item to retrieve.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The item at the specified index.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n20\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def nth(self, index: int) -&gt; T:\n    \"\"\"Return the nth item at index.\n\n    Args:\n        index (int): The index of the item to retrieve.\n\n    Returns:\n        T: The item at the specified index.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n    20\n\n    ```\n    \"\"\"\n    return cz.itertoolz.nth(index, self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.once","level":2,"title":"<code>once(value)</code>  <code>staticmethod</code>","text":"<p>Create an <code>Iter</code> that yields a single value.</p> <p>If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like <code>Iter([value])</code>.</p> <p>This can be considered the equivalent of <code>.insert()</code> but as a constructor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The single value to yield.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>Iter[V]: An iterator yielding the specified value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter.once(42).collect()\nSeq(42,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef once[V](value: V) -&gt; Iter[V]:\n    \"\"\"Create an `Iter` that yields a single value.\n\n    If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n    This can be considered the equivalent of `.insert()` but as a constructor.\n\n    Args:\n        value (V): The single value to yield.\n\n    Returns:\n        Iter[V]: An iterator yielding the specified value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter.once(42).collect()\n    Seq(42,)\n\n    ```\n    \"\"\"\n    return Iter((value,))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.once_with","level":2,"title":"<code>once_with(func, *args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create an <code>Iter</code>  that lazily generates a value exactly once by invoking the provided closure.</p> <p>If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like <code>Iter([value])</code>.</p> <p>This can be considered the equivalent of <code>.insert()</code> but as a constructor.</p> <p>Unlike <code>.once()</code>, this function will lazily generate the value on request.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The single value to yield.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator yielding the specified value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter.once(42).collect()\nSeq(42,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef once_with[**P, R](\n    func: Callable[P, R], *args: P.args, **kwargs: P.kwargs\n) -&gt; Iter[R]:\n    \"\"\"Create an `Iter`  that lazily generates a value exactly once by invoking the provided closure.\n\n    If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n    This can be considered the equivalent of `.insert()` but as a constructor.\n\n    Unlike `.once()`, this function will lazily generate the value on request.\n\n    Args:\n        func (Callable[P, R]): The single value to yield.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Iter[R]: An iterator yielding the specified value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter.once(42).collect()\n    Seq(42,)\n\n    ```\n    \"\"\"\n    return Iter(func(*args, **kwargs) for _ in range(1))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.pairwise","level":2,"title":"<code>pairwise()</code>","text":"<p>Return an iterator over pairs of consecutive elements.</p> <p>Returns:</p> Type Description <code>Iter[tuple[T, T]]</code> <p>Iter[tuple[T, T]]: An iterable of pairs of consecutive elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).pairwise().collect()\nSeq((1, 2), (2, 3))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def pairwise(self) -&gt; Iter[tuple[T, T]]:\n    \"\"\"Return an iterator over pairs of consecutive elements.\n\n    Returns:\n        Iter[tuple[T, T]]: An iterable of pairs of consecutive elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).pairwise().collect()\n    Seq((1, 2), (2, 3))\n\n    ```\n    \"\"\"\n    return Iter(itertools.pairwise(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.partition","level":2,"title":"<code>partition(n, pad=None)</code>","text":"<pre><code>partition(\n    n: Literal[1], pad: None = None\n) -&gt; Iter[tuple[T]]\n</code></pre><pre><code>partition(\n    n: Literal[2], pad: None = None\n) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>partition(\n    n: Literal[3], pad: None = None\n) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>partition(\n    n: Literal[4], pad: None = None\n) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>partition(\n    n: Literal[5], pad: None = None\n) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre><pre><code>partition(n: int, pad: int) -&gt; Iter[tuple[T, ...]]\n</code></pre> <p>Partition sequence into tuples of length n.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Length of each partition.</p> required <code>pad</code> <code>int | None</code> <p>Value to pad the last partition if needed. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of partitioned tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition(2).collect()\nSeq((1, 2), (3, 4))\n</code></pre> If the length of seq is not evenly divisible by n, the final tuple is dropped if pad is not specified, or filled to length n by pad: <pre><code>&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition(2).collect()\nSeq((1, 2), (3, 4), (5, None))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def partition(self, n: int, pad: int | None = None) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Partition sequence into tuples of length n.\n\n    Args:\n        n (int): Length of each partition.\n        pad (int | None): Value to pad the last partition if needed. Defaults to None.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition(2).collect()\n    Seq((1, 2), (3, 4))\n\n    ```\n    If the length of seq is not evenly divisible by n, the final tuple is dropped if pad is not specified, or filled to length n by pad:\n    ```python\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition(2).collect()\n    Seq((1, 2), (3, 4), (5, None))\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.partition(n, self._inner, pad=pad))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.partition_all","level":2,"title":"<code>partition_all(n)</code>","text":"<p>Partition all elements of sequence into tuples of length at most n.</p> <p>The final tuple may be shorter to accommodate extra elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Maximum length of each partition.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of partitioned tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition_all(2).collect()\nSeq((1, 2), (3, 4))\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition_all(2).collect()\nSeq((1, 2), (3, 4), (5,))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def partition_all(self, n: int) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Partition all elements of sequence into tuples of length at most n.\n\n    The final tuple may be shorter to accommodate extra elements.\n\n    Args:\n        n (int): Maximum length of each partition.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition_all(2).collect()\n    Seq((1, 2), (3, 4))\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition_all(2).collect()\n    Seq((1, 2), (3, 4), (5,))\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.partition_all(n, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.partition_by","level":2,"title":"<code>partition_by(predicate)</code>","text":"<p>Partition the <code>iterable</code> into a sequence of <code>tuples</code> according to a predicate function.</p> <p>Every time the output of <code>predicate</code> changes, a new <code>tuple</code> is started, and subsequent items are collected into that <code>tuple</code>.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine partition boundaries.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of partitioned tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"I have space\").partition_by(lambda c: c == \" \").collect()\nSeq(('I',), (' ',), ('h', 'a', 'v', 'e'), (' ',), ('s', 'p', 'a', 'c', 'e'))\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = [1, 2, 1, 99, 88, 33, 99, -1, 5]\n&gt;&gt;&gt; pc.Iter(data).partition_by(lambda x: x &gt; 10).collect()\nSeq((1, 2, 1), (99, 88, 33, 99), (-1, 5))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def partition_by(self, predicate: Callable[[T], bool]) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Partition the `iterable` into a sequence of `tuples` according to a predicate function.\n\n    Every time the output of `predicate` changes, a new `tuple` is started,\n    and subsequent items are collected into that `tuple`.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine partition boundaries.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"I have space\").partition_by(lambda c: c == \" \").collect()\n    Seq(('I',), (' ',), ('h', 'a', 'v', 'e'), (' ',), ('s', 'p', 'a', 'c', 'e'))\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = [1, 2, 1, 99, 88, 33, 99, -1, 5]\n    &gt;&gt;&gt; pc.Iter(data).partition_by(lambda x: x &gt; 10).collect()\n    Seq((1, 2, 1), (99, 88, 33, 99), (-1, 5))\n\n    ```\n    \"\"\"\n    return Iter(cz.recipes.partitionby(predicate, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.peekable","level":2,"title":"<code>peekable(n)</code>","text":"<p>Retrieve the next n elements from the <code>Iterator</code>, and return a tuple of the retrieved elements along with the original Iterator, unconsumed.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of items to peek.</p> required <p>Returns:</p> Type Description <code>Peekable[T]</code> <p>Peekable[T]: A <code>Peekable</code> object containing the peeked elements and the remaining iterator.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Iter([1, 2, 3]).peekable(2)\n&gt;&gt;&gt; data.peek.collect()\nSeq(1, 2)\n&gt;&gt;&gt; data.values.collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def peekable(self, n: int) -&gt; Peekable[T]:\n    \"\"\"Retrieve the next n elements from the `Iterator`, and return a tuple of the retrieved elements along with the original Iterator, unconsumed.\n\n    Args:\n        n (int): Number of items to peek.\n\n    Returns:\n        Peekable[T]: A `Peekable` object containing the peeked elements and the remaining iterator.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Iter([1, 2, 3]).peekable(2)\n    &gt;&gt;&gt; data.peek.collect()\n    Seq(1, 2)\n    &gt;&gt;&gt; data.values.collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    peeked, vals = cz.itertoolz.peekn(n, self._inner)\n    return Peekable(Iter(peeked), Iter(vals))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.permutations","level":2,"title":"<code>permutations(r=None)</code>","text":"<pre><code>permutations(r: Literal[2]) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>permutations(r: Literal[3]) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>permutations(r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>permutations(r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre> <p>Return all permutations of length r.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int | None</code> <p>Length of each permutation. Defaults to the length of the iterable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of permutations.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).permutations(2).collect()\nSeq((1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def permutations(self, r: int | None = None) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Return all permutations of length r.\n\n    Args:\n        r (int | None): Length of each permutation. Defaults to the length of the iterable.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of permutations.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).permutations(2).collect()\n    Seq((1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2))\n\n    ```\n    \"\"\"\n    return Iter(itertools.permutations(self._inner, r))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.product","level":2,"title":"<code>product(*others)</code>","text":"<pre><code>product() -&gt; Iter[tuple[T]]\n</code></pre><pre><code>product(iter1: Iterable[T1]) -&gt; Iter[tuple[T, T1]]\n</code></pre><pre><code>product(\n    iter1: Iterable[T1], iter2: Iterable[T2]\n) -&gt; Iter[tuple[T, T1, T2]]\n</code></pre><pre><code>product(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n) -&gt; Iter[tuple[T, T1, T2, T3]]\n</code></pre><pre><code>product(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n) -&gt; Iter[tuple[T, T1, T2, T3, T4]]\n</code></pre> <p>Computes the Cartesian product with another iterable.</p> <p>This is the declarative equivalent of nested for-loops.</p> <p>It pairs every element from the source iterable with every element from the other iterable.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to compute the Cartesian product with.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[tuple[Any, ...]]</code> <p>Iter[tuple[Any, ...]]: An iterable of tuples containing elements from the Cartesian product.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; sizes = [\"S\", \"M\"]\n&gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).product(sizes).collect()\nSeq(('blue', 'S'), ('blue', 'M'), ('red', 'S'), ('red', 'M'))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def product(self, *others: Iterable[Any]) -&gt; Iter[tuple[Any, ...]]:\n    \"\"\"Computes the Cartesian product with another iterable.\n\n    This is the declarative equivalent of nested for-loops.\n\n    It pairs every element from the source iterable with every element from the\n    other iterable.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to compute the Cartesian product with.\n\n    Returns:\n        Iter[tuple[Any, ...]]: An iterable of tuples containing elements from the Cartesian product.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; sizes = [\"S\", \"M\"]\n    &gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).product(sizes).collect()\n    Seq(('blue', 'S'), ('blue', 'M'), ('red', 'S'), ('red', 'M'))\n\n    ```\n    \"\"\"\n    return Iter(itertools.product(self._inner, *others))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.random_sample","level":2,"title":"<code>random_sample(probability, state=None)</code>","text":"<p>Return elements from a sequence with probability of prob.</p> <p>Returns a lazy iterator of random items from seq.</p> <p>random_sample considers each item independently and without replacement.</p> <p>See below how the first time it returned 13 items and the next time it returned 6 items.</p> <p>Parameters:</p> Name Type Description Default <code>probability</code> <code>float</code> <p>The probability of including each element.</p> required <code>state</code> <code>Random | int | None</code> <p>Random state or seed for deterministic sampling.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new Iterable wrapper with randomly sampled elements.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Iter(range(100)).collect()\n&gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\nSeq(6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95)\n&gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\nSeq(6, 44, 54, 61, 69, 94)\n</code></pre> Providing an integer seed for random_state will result in deterministic sampling.</p> <p>Given the same seed it will return the same sample every time. <pre><code>&gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\nSeq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n&gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\nSeq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n</code></pre> random_state can also be any object with a method random that returns floats between 0.0 and 1.0 (exclusive). <pre><code>&gt;&gt;&gt; from random import Random\n&gt;&gt;&gt; randobj = Random(2016)\n&gt;&gt;&gt; data.iter().random_sample(0.1, state=randobj).collect()\nSeq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def random_sample(\n    self, probability: float, state: Random | int | None = None\n) -&gt; Iter[T]:\n    \"\"\"Return elements from a sequence with probability of prob.\n\n    Returns a lazy iterator of random items from seq.\n\n    random_sample considers each item independently and without replacement.\n\n    See below how the first time it returned 13 items and the next time it returned 6 items.\n\n    Args:\n        probability (float): The probability of including each element.\n        state (Random | int | None): Random state or seed for deterministic sampling.\n\n    Returns:\n        Iter[T]: A new Iterable wrapper with randomly sampled elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Iter(range(100)).collect()\n    &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n    Seq(6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95)\n    &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n    Seq(6, 44, 54, 61, 69, 94)\n    ```\n    Providing an integer seed for random_state will result in deterministic sampling.\n\n    Given the same seed it will return the same sample every time.\n    ```python\n    &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n    Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n    &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n    Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n    ```\n    random_state can also be any object with a method random that returns floats between 0.0 and 1.0 (exclusive).\n    ```python\n    &gt;&gt;&gt; from random import Random\n    &gt;&gt;&gt; randobj = Random(2016)\n    &gt;&gt;&gt; data.iter().random_sample(0.1, state=randobj).collect()\n    Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n    ```\n    \"\"\"\n    return Iter(\n        cz.itertoolz.random_sample(probability, self._inner, random_state=state)\n    )\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.reduce","level":2,"title":"<code>reduce(func)</code>","text":"<p>Apply a function of two arguments cumulatively to the items of an iterable, from left to right.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>Function to apply cumulatively to the items of the iterable.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Single value resulting from cumulative reduction.</p> <p>This effectively reduces the iterable to a single value.</p> <p>If initial is present, it is placed before the items of the iterable in the calculation.</p> <p>It then serves as a default when the iterable is empty. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n6\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def reduce(self, func: Callable[[T, T], T]) -&gt; T:\n    \"\"\"Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    Args:\n        func (Callable[[T, T], T]): Function to apply cumulatively to the items of the iterable.\n\n    Returns:\n        T: Single value resulting from cumulative reduction.\n\n    This effectively reduces the iterable to a single value.\n\n    If initial is present, it is placed before the items of the iterable in the calculation.\n\n    It then serves as a default when the iterable is empty.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n    6\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.repeat","level":2,"title":"<code>repeat(n, factory=tuple)</code>","text":"<p>Repeat the entire iterable n times (as elements).</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of repetitions.</p> required <code>factory</code> <code>Callable[[Iterable[T]], Sequence[T]]</code> <p>Factory to create the repeated Sequence (default: tuple).</p> <code>tuple</code> <p>Returns:</p> Type Description <code>Iter[Iterable[T]]</code> <p>Iter[Iterable[T]]: An iterable of repeated sequences.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).repeat(2).collect()\nSeq((1, 2), (1, 2))\n&gt;&gt;&gt; pc.Iter([1, 2]).repeat(3, list).collect()\nSeq([1, 2], [1, 2], [1, 2])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def repeat(\n    self,\n    n: int,\n    factory: Callable[[Iterable[T]], Sequence[T]] = tuple,\n) -&gt; Iter[Iterable[T]]:\n    \"\"\"Repeat the entire iterable n times (as elements).\n\n    Args:\n        n (int): Number of repetitions.\n        factory (Callable[[Iterable[T]], Sequence[T]]): Factory to create the repeated Sequence (default: tuple).\n\n    Returns:\n        Iter[Iterable[T]]: An iterable of repeated sequences.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).repeat(2).collect()\n    Seq((1, 2), (1, 2))\n    &gt;&gt;&gt; pc.Iter([1, 2]).repeat(3, list).collect()\n    Seq([1, 2], [1, 2], [1, 2])\n\n    ```\n    \"\"\"\n    return Iter(itertools.repeat(factory(self._inner), n))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.rev","level":2,"title":"<code>rev()</code>","text":"<p>Return a new Iterable wrapper with elements in reverse order.</p> <p>The result is a new iterable over the reversed sequence.</p> Note <p>This method must consume the entire iterable to perform the reversal.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: A new Iterable wrapper with elements in reverse order.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).rev().collect()\nSeq(3, 2, 1)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def rev(self) -&gt; Iter[T]:\n    \"\"\"Return a new Iterable wrapper with elements in reverse order.\n\n    The result is a new iterable over the reversed sequence.\n\n    Note:\n        This method must consume the entire iterable to perform the reversal.\n\n    Returns:\n        Iter[T]: A new Iterable wrapper with elements in reverse order.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).rev().collect()\n    Seq(3, 2, 1)\n\n    ```\n    \"\"\"\n    return Iter(reversed(tuple(self._inner)))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.scan","level":2,"title":"<code>scan(initial, func)</code>","text":"<p>Transform elements by sharing state between iterations.</p> <p><code>scan</code> takes two arguments:     - an initial value which seeds the internal state     - a func with two arguments</p> <p>The first being a reference to the internal state and the second an iterator element.</p> <p>The func can assign to the internal state to share state between iterations.</p> <p>On iteration, the func will be applied to each element of the iterator and the return value from the func, an Option, is returned by the next method.</p> <p>Thus the func can return <code>Some(value)</code> to yield value, or None to end the iteration.</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>U</code> <p>Initial state.</p> required <code>func</code> <code>Callable[[U, T], Option[U]]</code> <p>Function that takes the current state and an item, and returns an Option.</p> required <p>Returns:</p> Type Description <code>Iter[U]</code> <p>Iter[U]: An iterable of the yielded values.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def accumulate_until_limit(state: int, item: int) -&gt; pc.Option[int]:\n...     new_state = state + item\n...     match new_state:\n...         case _ if new_state &lt;= 10:\n...             return pc.Some(new_state)\n...         case _:\n...             return pc.NONE\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).scan(0, accumulate_until_limit).collect()\nSeq(1, 3, 6, 10)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def scan[U](self, initial: U, func: Callable[[U, T], Option[U]]) -&gt; Iter[U]:\n    \"\"\"Transform elements by sharing state between iterations.\n\n    `scan` takes two arguments:\n        - an **initial** value which seeds the internal state\n        - a **func** with two arguments\n\n    The first being a reference to the internal state and the second an iterator element.\n\n    The **func** can assign to the internal state to share state between iterations.\n\n    On iteration, the **func** will be applied to each element of the iterator and the return value from the func, an Option, is returned by the next method.\n\n    Thus the **func** can return `Some(value)` to yield value, or None to end the iteration.\n\n    Args:\n        initial (U): Initial state.\n        func (Callable[[U, T], Option[U]]): Function that takes the current state and an item, and returns an Option.\n\n    Returns:\n        Iter[U]: An iterable of the yielded values.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def accumulate_until_limit(state: int, item: int) -&gt; pc.Option[int]:\n    ...     new_state = state + item\n    ...     match new_state:\n    ...         case _ if new_state &lt;= 10:\n    ...             return pc.Some(new_state)\n    ...         case _:\n    ...             return pc.NONE\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).scan(0, accumulate_until_limit).collect()\n    Seq(1, 3, 6, 10)\n\n    ```\n    \"\"\"\n\n    def gen(data: Iterable[T]) -&gt; Iterator[U]:\n        current: U = initial\n        for item in data:\n            res = func(current, item)\n            if res.is_none():\n                break\n            current = res.unwrap()\n            yield res.unwrap()\n\n    return Iter(gen(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.second","level":2,"title":"<code>second()</code>","text":"<p>Return the second element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The second element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9, 8]).second()\n8\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def second(self) -&gt; T:\n    \"\"\"Return the second element.\n\n    Returns:\n        T: The second element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9, 8]).second()\n    8\n\n    ```\n    \"\"\"\n    return cz.itertoolz.second(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.skip","level":2,"title":"<code>skip(n)</code>","text":"<p>Drop first n elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to skip.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the items after skipping the first n items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 3)).skip(1).collect()\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def skip(self, n: int) -&gt; Iter[T]:\n    \"\"\"Drop first n elements.\n\n    Args:\n        n (int): Number of elements to skip.\n\n    Returns:\n        Iter[T]: An iterable of the items after skipping the first n items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 3)).skip(1).collect()\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.drop(n, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.skip_while","level":2,"title":"<code>skip_while(predicate)</code>","text":"<p>Drop items while predicate holds.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the items after skipping those for which the predicate is true.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 0)).skip_while(lambda x: x &gt; 0).collect()\nSeq(0,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def skip_while(self, predicate: Callable[[T], bool]) -&gt; Iter[T]:\n    \"\"\"Drop items while predicate holds.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Iter[T]: An iterable of the items after skipping those for which the predicate is true.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 0)).skip_while(lambda x: x &gt; 0).collect()\n    Seq(0,)\n\n    ```\n    \"\"\"\n    return Iter(itertools.dropwhile(predicate, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.slice","level":2,"title":"<code>slice(start=None, stop=None, step=None)</code>","text":"<p>Return a slice of the iterable.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int | None</code> <p>Starting index of the slice. Defaults to None.</p> <code>None</code> <code>stop</code> <code>int | None</code> <p>Ending index of the slice. Defaults to None.</p> <code>None</code> <code>step</code> <code>int | None</code> <p>Step size for the slice. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the sliced items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; pc.Iter(data).slice(1, 4).collect()\nSeq(2, 3, 4)\n&gt;&gt;&gt; pc.Iter(data).slice(step=2).collect()\nSeq(1, 3, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def slice(\n    self,\n    start: int | None = None,\n    stop: int | None = None,\n    step: int | None = None,\n) -&gt; Iter[T]:\n    \"\"\"Return a slice of the iterable.\n\n    Args:\n        start (int | None): Starting index of the slice. Defaults to None.\n        stop (int | None): Ending index of the slice. Defaults to None.\n        step (int | None): Step size for the slice. Defaults to None.\n\n    Returns:\n        Iter[T]: An iterable of the sliced items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = (1, 2, 3, 4, 5)\n    &gt;&gt;&gt; pc.Iter(data).slice(1, 4).collect()\n    Seq(2, 3, 4)\n    &gt;&gt;&gt; pc.Iter(data).slice(step=2).collect()\n    Seq(1, 3, 5)\n\n    ```\n    \"\"\"\n    return Iter(itertools.islice(self._inner, start, stop, step))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.sort","level":2,"title":"<code>sort(*, key=None, reverse=False)</code>","text":"<pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Vec[U]\n</code></pre><pre><code>sort(\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]],\n    reverse: bool = False,\n) -&gt; Vec[T]\n</code></pre><pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Never\n</code></pre> <p>Sort the elements of the sequence.</p> Note <p>This method must consume the entire iterable to perform the sort. The result is a new <code>Vec</code> over the sorted sequence.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsRichComparison[Any]] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in descending order. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Vec[Any]</code> <p>Vec[Any]: A <code>Vec</code> with elements sorted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\nVec(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sort(\n    self,\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n    reverse: bool = False,\n) -&gt; Vec[Any]:\n    \"\"\"Sort the elements of the sequence.\n\n    Note:\n        This method must consume the entire iterable to perform the sort.\n        The result is a new `Vec` over the sorted sequence.\n\n    Args:\n        key (Callable[[T], SupportsRichComparison[Any]] | None): Function to extract a comparison key from each element. Defaults to None.\n        reverse (bool): Whether to sort in descending order. Defaults to False.\n\n    Returns:\n        Vec[Any]: A `Vec` with elements sorted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\n    Vec(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Vec(sorted(self._inner, reverse=reverse, key=key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_after","level":2,"title":"<code>split_after(predicate, max_split=-1)</code>","text":"<p>Yield iterator of items from iterable, where each iterator ends with an item where <code>predicate</code> returns True.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine the split points.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform. Defaults to -1 (no limit).</p> <code>-1</code> <p>Returns:</p> Type Description <code>Iter[Iter[T]]</code> <p>Iter[Iter[T]]: An iterable of lists of items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"one1two2\").split_after(str.isdigit).map(list).collect()\nSeq(['o', 'n', 'e', '1'], ['t', 'w', 'o', '2'])\n\n&gt;&gt;&gt; def cond(n: int) -&gt; bool:\n...     return n % 3 == 0\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(range(10)).split_after(cond).map(list).collect()\nSeq([0], [1, 2, 3], [4, 5, 6], [7, 8, 9])\n&gt;&gt;&gt; pc.Iter(range(10)).split_after(cond, max_split=2).map(list).collect()\nSeq([0], [1, 2, 3], [4, 5, 6, 7, 8, 9])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_after(\n    self,\n    predicate: Callable[[T], bool],\n    max_split: int = -1,\n) -&gt; Iter[Iter[T]]:\n    \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine the split points.\n        max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n\n    Returns:\n        Iter[Iter[T]]: An iterable of lists of items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"one1two2\").split_after(str.isdigit).map(list).collect()\n    Seq(['o', 'n', 'e', '1'], ['t', 'w', 'o', '2'])\n\n    &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n    ...     return n % 3 == 0\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond).map(list).collect()\n    Seq([0], [1, 2, 3], [4, 5, 6], [7, 8, 9])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond, max_split=2).map(list).collect()\n    Seq([0], [1, 2, 3], [4, 5, 6, 7, 8, 9])\n\n    ```\n    \"\"\"\n\n    def _split_after(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n        \"\"\"Credits: more_itertools.split_after.\"\"\"\n        if max_split == 0:\n            yield self.__class__(data)\n            return\n\n        buf: list[T] = []\n        for item in data:\n            buf.append(item)\n            if predicate(item) and buf:\n                yield self.__class__(buf)\n                if max_split == 1:\n                    buf = list(data)\n                    if buf:\n                        yield self.__class__(buf)\n                    return\n                buf = []\n                max_split -= 1\n        if buf:\n            yield self.__class__(buf)\n\n    return Iter(_split_after(self._inner, max_split))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_at","level":2,"title":"<code>split_at(predicate, max_split=-1, *, keep_separator=False)</code>","text":"<p>Yield iterators of items from iterable, where each iterator is delimited by an item where <code>predicate</code> returns True.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine the split points.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform. Defaults to -1 (no limit).</p> <code>-1</code> <code>keep_separator</code> <code>bool</code> <p>Whether to include the separator in the output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iter[Iter[T]]</code> <p>Iter[Iter[T]]: An iterator of iterators, each containing a segment of the original iterable.</p> <p>By default, the delimiting items are not included in the output.</p> <p>To include them, set keep_separator to <code>True</code>. At most max_split splits are done.</p> <p>If max_split is not specified or -1, then there is no limit on the number of splits.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _to_res(x: pc.Iter[pc.Iter[str]]) -&gt; pc.Seq[pc.Seq[str]]:\n...     return x.map(lambda x: x.into(list)).collect()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(lambda x: x == \"b\").into(_to_res)\nSeq(['a'], ['c', 'd', 'c'], ['a'])\n&gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1).into(_to_res)\nSeq([0], [2], [4], [6], [8], [])\n&gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1, max_split=2).into(_to_res)\nSeq([0], [2], [4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt;\n&gt;&gt;&gt; def cond(x: str) -&gt; bool:\n...     return x == \"b\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(cond, keep_separator=True).into(_to_res)\nSeq(['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a'])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_at(\n    self,\n    predicate: Callable[[T], bool],\n    max_split: int = -1,\n    *,\n    keep_separator: bool = False,\n) -&gt; Iter[Iter[T]]:\n    \"\"\"Yield iterators of items from iterable, where each iterator is delimited by an item where `predicate` returns True.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine the split points.\n        max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n        keep_separator (bool): Whether to include the separator in the output. Defaults to False.\n\n    Returns:\n        Iter[Iter[T]]: An iterator of iterators, each containing a segment of the original iterable.\n\n    By default, the delimiting items are not included in the output.\n\n    To include them, set *keep_separator* to `True`.\n    At most *max_split* splits are done.\n\n    If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _to_res(x: pc.Iter[pc.Iter[str]]) -&gt; pc.Seq[pc.Seq[str]]:\n    ...     return x.map(lambda x: x.into(list)).collect()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(lambda x: x == \"b\").into(_to_res)\n    Seq(['a'], ['c', 'd', 'c'], ['a'])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1).into(_to_res)\n    Seq([0], [2], [4], [6], [8], [])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1, max_split=2).into(_to_res)\n    Seq([0], [2], [4, 5, 6, 7, 8, 9])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def cond(x: str) -&gt; bool:\n    ...     return x == \"b\"\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(cond, keep_separator=True).into(_to_res)\n    Seq(['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a'])\n\n    ```\n    \"\"\"\n\n    def _split_at(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n        \"\"\"Credits: more_itertools.split_at.\"\"\"\n        if max_split == 0:\n            yield self\n            return\n\n        buf: list[T] = []\n        for item in data:\n            if predicate(item):\n                yield self.__class__(buf)\n                if keep_separator:\n                    yield self.__class__((item,))\n                if max_split == 1:\n                    yield self.__class__(data)\n                    return\n                buf = []\n                max_split -= 1\n            else:\n                buf.append(item)\n        yield self.__class__(buf)\n\n    return Iter(_split_at(self._inner, max_split))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_before","level":2,"title":"<code>split_before(predicate, max_split=-1)</code>","text":"<p>Yield iterator of items from iterable, where each iterator ends with an item where <code>predicate</code> returns True.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine the split points.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform. Defaults to -1 (no limit).</p> <code>-1</code> <p>Returns:</p> Type Description <code>Iter[Iter[T]]</code> <p>Iter[Iter[T]]: An iterable of lists of items.</p> <p>At most max_split are done.</p> <p>If max_split is not specified or -1, then there is no limit on the number of splits:</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"abcdcba\").split_before(lambda x: x == \"b\").map(list).collect()\nSeq(['a'], ['b', 'c', 'd', 'c'], ['b', 'a'])\n&gt;&gt;&gt;\n&gt;&gt;&gt; def cond(n: int) -&gt; bool:\n...     return n % 2 == 1\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(range(10)).split_before(cond).map(list).collect()\nSeq([0], [1, 2], [3, 4], [5, 6], [7, 8], [9])\n&gt;&gt;&gt; pc.Iter(range(10)).split_before(cond, max_split=2).map(list).collect()\nSeq([0], [1, 2], [3, 4, 5, 6, 7, 8, 9])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_before(\n    self,\n    predicate: Callable[[T], bool],\n    max_split: int = -1,\n) -&gt; Iter[Iter[T]]:\n    \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine the split points.\n        max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n\n    Returns:\n        Iter[Iter[T]]: An iterable of lists of items.\n\n\n    At most *max_split* are done.\n\n\n    If *max_split* is not specified or -1, then there is no limit on the number of splits:\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_before(lambda x: x == \"b\").map(list).collect()\n    Seq(['a'], ['b', 'c', 'd', 'c'], ['b', 'a'])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n    ...     return n % 2 == 1\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond).map(list).collect()\n    Seq([0], [1, 2], [3, 4], [5, 6], [7, 8], [9])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond, max_split=2).map(list).collect()\n    Seq([0], [1, 2], [3, 4, 5, 6, 7, 8, 9])\n\n    ```\n    \"\"\"\n\n    def _split_before(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n        \"\"\"Credits: more_itertools.split_before.\"\"\"\n        if max_split == 0:\n            yield self.__class__(data)\n            return\n\n        buf: list[T] = []\n        for item in data:\n            if predicate(item) and buf:\n                yield self.__class__(buf)\n                if max_split == 1:\n                    yield self.__class__([item, *data])\n                    return\n                buf = []\n                max_split -= 1\n            buf.append(item)\n        if buf:\n            yield self.__class__(buf)\n\n    return Iter(_split_before(self._inner, max_split))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_into","level":2,"title":"<code>split_into(*sizes)</code>","text":"<p>Yield a list of sequential items from iterable of length 'n' for each integer 'n' in sizes.</p> <p>Parameters:</p> Name Type Description Default <code>*sizes</code> <code>Option[int]</code> <p><code>Some</code> integers specifying the sizes of each chunk. Use <code>NONE</code> for the remainder.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[Iter[T]]</code> <p>Iter[Iter[T]]: An iterator of iterators, each containing a chunk of the original iterable.</p> <p>If the sum of sizes is smaller than the length of iterable, then the remaining items of iterable will not be returned.</p> <p>If the sum of sizes is larger than the length of iterable:</p> <ul> <li>fewer items will be returned in the iteration that overruns the iterable</li> <li>further lists will be empty</li> </ul> <p>When a <code>NONE</code> object is encountered in sizes, the returned list will contain items up to the end of iterable the same way that itertools.slice does.</p> <p>split_into can be useful for grouping a series of items where the sizes of the groups are not uniform.</p> <p>An example would be where in a row from a table:</p> <ul> <li>multiple columns represent elements of the same feature (e.g. a point represented by x,y,z)</li> <li>the format is not the same for all columns.</li> </ul> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _get_results(x: pc.Iter[pc.Iter[int]]) -&gt; pc.Seq[pc.Seq[int]]:\n...    return x.map(lambda x: x.collect()).collect()\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(1), pc.Some(2), pc.Some(3)).into(_get_results)\nSeq(Seq(1,), Seq(2, 3), Seq(4, 5, 6))\n&gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3)).into(_get_results)\nSeq(Seq(1, 2), Seq(3, 4, 5))\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).split_into(pc.Some(1), pc.Some(2), pc.Some(3), pc.Some(4)).into(_get_results)\nSeq(Seq(1,), Seq(2, 3), Seq(4,), Seq())\n&gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n&gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3), pc.NONE).into(_get_results)\nSeq(Seq(1, 2), Seq(3, 4, 5), Seq(6, 7, 8, 9, 0))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_into(self, *sizes: Option[int]) -&gt; Iter[Iter[T]]:\n    \"\"\"Yield a list of sequential items from iterable of length 'n' for each integer 'n' in sizes.\n\n    Args:\n        *sizes (Option[int]): `Some` integers specifying the sizes of each chunk. Use `NONE` for the remainder.\n\n    Returns:\n        Iter[Iter[T]]: An iterator of iterators, each containing a chunk of the original iterable.\n\n    If the sum of sizes is smaller than the length of iterable, then the remaining items of iterable will not be returned.\n\n    If the sum of sizes is larger than the length of iterable:\n\n    - fewer items will be returned in the iteration that overruns the iterable\n    - further lists will be empty\n\n    When a `NONE` object is encountered in sizes, the returned list will contain items up to the end of iterable the same way that itertools.slice does.\n\n    split_into can be useful for grouping a series of items where the sizes of the groups are not uniform.\n\n    An example would be where in a row from a table:\n\n    - multiple columns represent elements of the same feature (e.g. a point represented by x,y,z)\n    - the format is not the same for all columns.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _get_results(x: pc.Iter[pc.Iter[int]]) -&gt; pc.Seq[pc.Seq[int]]:\n    ...    return x.map(lambda x: x.collect()).collect()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6]\n    &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(1), pc.Some(2), pc.Some(3)).into(_get_results)\n    Seq(Seq(1,), Seq(2, 3), Seq(4, 5, 6))\n    &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3)).into(_get_results)\n    Seq(Seq(1, 2), Seq(3, 4, 5))\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).split_into(pc.Some(1), pc.Some(2), pc.Some(3), pc.Some(4)).into(_get_results)\n    Seq(Seq(1,), Seq(2, 3), Seq(4,), Seq())\n    &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n    &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3), pc.NONE).into(_get_results)\n    Seq(Seq(1, 2), Seq(3, 4, 5), Seq(6, 7, 8, 9, 0))\n\n    ```\n    \"\"\"\n\n    def _split_into(data: Iterator[T]) -&gt; Iterator[Iter[T]]:\n        \"\"\"Credits: more_itertools.split_into.\"\"\"\n        for size in sizes:\n            if size.is_none():\n                yield self.__class__(data)\n                return\n            else:\n                yield self.__class__(itertools.islice(data, size.unwrap()))\n\n    return Iter(_split_into(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_when","level":2,"title":"<code>split_when(predicate, max_split=-1)</code>","text":"<p>Split iterable into pieces based on the output of a predicate function.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T, T], bool]</code> <p>Function that takes successive pairs of items and returns True if the iterable should be split.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform. Defaults to -1 (no limit).</p> <code>-1</code> <p>Returns:</p> Type Description <code>Iter[Iter[T]]</code> <p>Iter[Iter[T]]: An iterator of iterators of items.</p> <p>At most max_split splits are done.</p> <p>If max_split is not specified or -1, then there is no limit on the number of splits.</p> <p>The example below shows how to find runs of increasing numbers, by splitting the iterable when element i is larger than element i + 1.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Seq([1, 2, 3, 3, 2, 5, 2, 4, 2])\n&gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y).map(lambda x: x.collect()).collect()\nSeq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4), Seq(2,))\n&gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y, max_split=2).map(lambda x: x.collect()).collect()\nSeq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_when(\n    self,\n    predicate: Callable[[T, T], bool],\n    max_split: int = -1,\n) -&gt; Iter[Iter[T]]:\n    \"\"\"Split iterable into pieces based on the output of a predicate function.\n\n    Args:\n        predicate (Callable[[T, T], bool]): Function that takes successive pairs of items and returns True if the iterable should be split.\n        max_split (int): Maximum number of splits to perform. Defaults to -1 (no limit).\n\n    Returns:\n        Iter[Iter[T]]: An iterator of iterators of items.\n\n    At most *max_split* splits are done.\n\n    If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n    The example below shows how to find runs of increasing numbers, by splitting the iterable when element i is larger than element i + 1.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Seq([1, 2, 3, 3, 2, 5, 2, 4, 2])\n    &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y).map(lambda x: x.collect()).collect()\n    Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4), Seq(2,))\n    &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y, max_split=2).map(lambda x: x.collect()).collect()\n    Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4, 2))\n\n    ```\n    \"\"\"\n\n    def _split_when(data: Iterator[T], max_split: int) -&gt; Iterator[Iter[T]]:\n        \"\"\"Credits: more_itertools.split_when.\"\"\"\n        if max_split == 0:\n            yield self\n            return\n        try:\n            cur_item = next(data)\n        except StopIteration:\n            return\n\n        buf = [cur_item]\n        for next_item in data:\n            if predicate(cur_item, next_item):\n                yield Iter(buf)\n                if max_split == 1:\n                    yield Iter((next_item, *data))\n                    return\n                buf = []\n                max_split -= 1\n\n            buf.append(next_item)\n            cur_item = next_item\n\n        yield Iter(buf)\n\n    return Iter(_split_when(self._inner, max_split))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.step_by","level":2,"title":"<code>step_by(step)</code>","text":"<p>Creates an <code>Iter</code> starting at the same point, but stepping by the given step at each iteration.</p> Note <p>The first element of the iterator will always be returned, regardless of the step given.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>Step size for selecting items.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of every nth item.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 4, 5]).step_by(2).collect()\nSeq(0, 2, 4)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def step_by(self, step: int) -&gt; Iter[T]:\n    \"\"\"Creates an `Iter` starting at the same point, but stepping by the given **step** at each iteration.\n\n    Note:\n        The first element of the iterator will always be returned, regardless of the **step** given.\n\n    Args:\n        step (int): Step size for selecting items.\n\n    Returns:\n        Iter[T]: An iterable of every nth item.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 4, 5]).step_by(2).collect()\n    Seq(0, 2, 4)\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.take_nth(step, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.successors","level":2,"title":"<code>successors(first, succ)</code>  <code>staticmethod</code>","text":"<p>Create an iterator of successive values computed from the previous one.</p> <p>The iterator yields <code>first</code> (if it is <code>Some</code>), then repeatedly applies succ to the previous yielded value until it returns <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>Option[U]</code> <p>Initial item.</p> required <code>succ</code> <code>Callable[[U], Option[U]]</code> <p>Successor function.</p> required <p>Returns:</p> Type Description <code>Iter[U]</code> <p>Iter[U]: Iterator yielding <code>first</code> and its successors.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def next_pow10(x: int) -&gt; pc.Option[int]:\n...     return pc.Some(x * 10) if x &lt; 10_000 else pc.NONE\n&gt;&gt;&gt; pc.Iter.successors(pc.Some(1), next_pow10).collect()\nSeq(1, 10, 100, 1000, 10000)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef successors[U](first: Option[U], succ: Callable[[U], Option[U]]) -&gt; Iter[U]:\n    \"\"\"Create an iterator of successive values computed from the previous one.\n\n    The iterator yields `first` (if it is `Some`), then repeatedly applies **succ** to the\n    previous yielded value until it returns `NONE`.\n\n    Args:\n        first (Option[U]): Initial item.\n        succ (Callable[[U], Option[U]]): Successor function.\n\n    Returns:\n        Iter[U]: Iterator yielding `first` and its successors.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def next_pow10(x: int) -&gt; pc.Option[int]:\n    ...     return pc.Some(x * 10) if x &lt; 10_000 else pc.NONE\n    &gt;&gt;&gt; pc.Iter.successors(pc.Some(1), next_pow10).collect()\n    Seq(1, 10, 100, 1000, 10000)\n\n    ```\n    \"\"\"\n\n    def _successors() -&gt; Iterator[U]:\n        current = first\n        while current.is_some():\n            value = current.unwrap()\n            yield value\n            current = succ(value)\n\n    return Iter(_successors())\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.sum","level":2,"title":"<code>sum()</code>","text":"<p>Return the sum of the <code>Iterable</code>.</p> <p>If the <code>Iterable</code> is empty, return 0.</p> <p>Returns:</p> Type Description <code>U | Literal[0]</code> <p>U | Literal[0]: The sum of all elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n6\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sum[U: SupportsSumWithNoDefaultGiven[Any]](self: BaseIter[U]) -&gt; U | Literal[0]:\n    \"\"\"Return the sum of the `Iterable`.\n\n    If the `Iterable` is empty, return 0.\n\n    Returns:\n        U | Literal[0]: The sum of all elements.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n    6\n\n    ```\n    \"\"\"\n    return sum(self._inner)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.tail","level":2,"title":"<code>tail(n)</code>","text":"<p>Return a tuple of the last n elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to return.</p> required <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the last n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def tail(self, n: int) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the last n elements.\n\n    Args:\n        n (int): Number of elements to return.\n\n    Returns:\n        Seq[T]: A new Seq containing the last n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.tail(n, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.take","level":2,"title":"<code>take(n)</code>","text":"<p>Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner.</p> <p><code>Iter.take(n)</code> yields elements until n elements are yielded or the end of the iterator is reached (whichever happens first).</p> <p>The returned iterator is either:</p> <ul> <li>A prefix of length n if the original iterator contains at least n elements</li> <li>All of the (fewer than n) elements of the original iterator if it contains fewer than n elements.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the first n items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [1, 2, 3]\n&gt;&gt;&gt; pc.Iter(data).take(2).collect()\nSeq(1, 2)\n&gt;&gt;&gt; pc.Iter(data).take(5).collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def take(self, n: int) -&gt; Iter[T]:\n    \"\"\"Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner.\n\n    `Iter.take(n)` yields elements until n elements are yielded or the end of the iterator is reached (whichever happens first).\n\n    The returned iterator is either:\n\n    - A prefix of length n if the original iterator contains at least n elements\n    - All of the (fewer than n) elements of the original iterator if it contains fewer than n elements.\n\n    Args:\n        n (int): Number of elements to take.\n\n    Returns:\n        Iter[T]: An iterable of the first n items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [1, 2, 3]\n    &gt;&gt;&gt; pc.Iter(data).take(2).collect()\n    Seq(1, 2)\n    &gt;&gt;&gt; pc.Iter(data).take(5).collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Iter(itertools.islice(self._inner, n))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.take_while","level":2,"title":"<code>take_while(predicate)</code>","text":"<p>Take items while predicate holds.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the items taken while the predicate is true.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 0)).take_while(lambda x: x &gt; 0).collect()\nSeq(1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def take_while(self, predicate: Callable[[T], bool]) -&gt; Iter[T]:\n    \"\"\"Take items while predicate holds.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Iter[T]: An iterable of the items taken while the predicate is true.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 0)).take_while(lambda x: x &gt; 0).collect()\n    Seq(1, 2)\n\n    ```\n    \"\"\"\n    return Iter(itertools.takewhile(predicate, self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.top_n","level":2,"title":"<code>top_n(n, key=None)</code>","text":"<p>Return a tuple of the top-n items according to key.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of top elements to return.</p> required <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the top-n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\nSeq(3, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def top_n(self, n: int, key: Callable[[T], Any] | None = None) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the top-n items according to key.\n\n    Args:\n        n (int): Number of top elements to return.\n        key (Callable[[T], Any] | None): Function to extract a comparison key from each element. Defaults to None.\n\n    Returns:\n        Seq[T]: A new Seq containing the top-n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\n    Seq(3, 2)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.topk(n, self._inner, key=key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.try_collect","level":2,"title":"<code>try_collect()</code>","text":"<p>Fallibly transforms self into a <code>Vec</code>, short circuiting if a failure is encountered.</p> <p><code>try_collect()</code> is a variation of <code>collect()</code> that allows fallible conversions during collection.</p> <p>Its main use case is simplifying conversions from iterators yielding <code>Option[T]</code>, <code>Result[T, E]</code> or <code>U | None</code> into <code>Option[Sequence[T]]</code>.</p> <p>Also, if a failure is encountered during <code>try_collect()</code>, the iterator is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure.</p> <p>See the last example below for an example of how this works.</p> Note <p>This method return <code>Vec[U]</code> instead of <code>Seq[U]</code> because the underlying data structure must be mutable in order to build up the collection.</p> <p>Returns:</p> Type Description <code>Option[Vec[U]]</code> <p>Option[Vec[U]]: <code>Some[Vec[U]]</code> if all elements were successfully collected, or <code>NONE</code> if a failure was encountered.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Successfully collecting an iterator of Option[int] into Option[Vec[int]]:\n&gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.Some(3)]).try_collect()\nSome(Vec(1, 2, 3))\n&gt;&gt;&gt; # Failing to collect in the same way:\n&gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.NONE, pc.Some(3)]).try_collect()\nNONE\n&gt;&gt;&gt; # A similar example, but with Result:\n&gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Ok(2), pc.Ok(3)]).try_collect()\nSome(Vec(1, 2, 3))\n&gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Err(\"error\"), pc.Ok(3)]).try_collect()\nNONE\n&gt;&gt;&gt; def external_fn(x: int) -&gt; int | None:\n...     if x % 2 == 0:\n...         return x\n...     return None\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map(external_fn).try_collect()\nNONE\n&gt;&gt;&gt; # Demonstrating that the iterator remains usable after a failure:\n&gt;&gt;&gt; it = pc.Iter([pc.Some(1), pc.NONE, pc.Some(3), pc.Some(4)])\n&gt;&gt;&gt; it.try_collect()\nNONE\n&gt;&gt;&gt; it.try_collect()\nSome(Vec(3, 4))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def try_collect[U](self: TryIter[U]) -&gt; Option[Vec[U]]:\n    \"\"\"Fallibly transforms **self** into a `Vec`, short circuiting if a failure is encountered.\n\n    `try_collect()` is a variation of `collect()` that allows fallible conversions during collection.\n\n    Its main use case is simplifying conversions from iterators yielding `Option[T]`, `Result[T, E]` or `U | None` into `Option[Sequence[T]]`.\n\n    Also, if a failure is encountered during `try_collect()`, the iterator is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure.\n\n    See the last example below for an example of how this works.\n\n    Note:\n        This method return `Vec[U]` instead of `Seq[U]` because the underlying data structure must be mutable in order to build up the collection.\n\n    Returns:\n        Option[Vec[U]]: `Some[Vec[U]]` if all elements were successfully collected, or `NONE` if a failure was encountered.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Successfully collecting an iterator of Option[int] into Option[Vec[int]]:\n    &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.Some(3)]).try_collect()\n    Some(Vec(1, 2, 3))\n    &gt;&gt;&gt; # Failing to collect in the same way:\n    &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.NONE, pc.Some(3)]).try_collect()\n    NONE\n    &gt;&gt;&gt; # A similar example, but with Result:\n    &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Ok(2), pc.Ok(3)]).try_collect()\n    Some(Vec(1, 2, 3))\n    &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Err(\"error\"), pc.Ok(3)]).try_collect()\n    NONE\n    &gt;&gt;&gt; def external_fn(x: int) -&gt; int | None:\n    ...     if x % 2 == 0:\n    ...         return x\n    ...     return None\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map(external_fn).try_collect()\n    NONE\n    &gt;&gt;&gt; # Demonstrating that the iterator remains usable after a failure:\n    &gt;&gt;&gt; it = pc.Iter([pc.Some(1), pc.NONE, pc.Some(3), pc.Some(4)])\n    &gt;&gt;&gt; it.try_collect()\n    NONE\n    &gt;&gt;&gt; it.try_collect()\n    Some(Vec(3, 4))\n\n    ```\n    \"\"\"\n    from ._option import NONE, Option, Some\n    from ._result import Result\n\n    collected = Vec[U].new()\n\n    for item in self._inner:\n        if item is None:\n            return NONE\n        match item:\n            case Result():\n                if item.is_err():\n                    return NONE\n                collected.append(item.unwrap())  # pyright: ignore[reportUnknownArgumentType]\n            case Option():\n                if item.is_none():\n                    return NONE\n                collected.append(item.unwrap())  # pyright: ignore[reportUnknownArgumentType]\n            case _ as plain_value:\n                collected.append(plain_value)\n    return Some(collected)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.try_for_each","level":2,"title":"<code>try_for_each(f)</code>","text":"<p>An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.</p> <p>This can also be thought of as the fallible form of <code>.for_each()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[T], Result[Any, E]]</code> <p>A function that takes an item of type <code>T</code> and returns a <code>Result</code>.</p> required <p>Returns:</p> Type Description <code>Result[None, E]</code> <p>Result[None, E]: Returns <code>Ok(None)</code> if all applications of f were successful (i.e., returned <code>Ok</code>), or the first error <code>E</code> encountered.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def validate_positive(n: int) -&gt; pc.Result[None, str]:\n...     if n &gt; 0:\n...         return pc.Ok(None)\n...     return pc.Err(f\"Value {n} is not positive\")\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).try_for_each(validate_positive)\nOk(None)\n&gt;&gt;&gt; # Short-circuit on first error:\n&gt;&gt;&gt; pc.Iter([1, 2, -1, 4]).try_for_each(validate_positive)\nErr('Value -1 is not positive')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def try_for_each[E](self, f: Callable[[T], Result[Any, E]]) -&gt; Result[None, E]:\n    \"\"\"An iterator method that applies a fallible function to each item in the iterator, stopping at the first error and returning that error.\n\n    This can also be thought of as the fallible form of `.for_each()`.\n\n    Args:\n        f (Callable[[T], Result[Any, E]]): A function that takes an item of type `T` and returns a `Result`.\n\n    Returns:\n        Result[None, E]: Returns `Ok(None)` if all applications of **f** were successful (i.e., returned `Ok`), or the first error `E` encountered.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def validate_positive(n: int) -&gt; pc.Result[None, str]:\n    ...     if n &gt; 0:\n    ...         return pc.Ok(None)\n    ...     return pc.Err(f\"Value {n} is not positive\")\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).try_for_each(validate_positive)\n    Ok(None)\n    &gt;&gt;&gt; # Short-circuit on first error:\n    &gt;&gt;&gt; pc.Iter([1, 2, -1, 4]).try_for_each(validate_positive)\n    Err('Value -1 is not positive')\n\n    ```\n    \"\"\"\n    from ._result import Ok\n\n    for item in self._inner:\n        res = f(item)\n        if res.is_err():\n            return res\n    return Ok(None)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.unique","level":2,"title":"<code>unique(key=None)</code>","text":"<p>Return only unique elements of the iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the unique items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).unique().collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; pc.Iter([1, 2, 1, 3]).unique().collect()\nSeq(1, 2, 3)\n</code></pre> Uniqueness can be defined by key keyword <pre><code>&gt;&gt;&gt; pc.Iter([\"cat\", \"mouse\", \"dog\", \"hen\"]).unique(key=len).collect()\nSeq('cat', 'mouse')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unique(self, key: Callable[[T], Any] | None = None) -&gt; Iter[T]:\n    \"\"\"Return only unique elements of the iterable.\n\n    Args:\n        key (Callable[[T], Any] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        Iter[T]: An iterable of the unique items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).unique().collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; pc.Iter([1, 2, 1, 3]).unique().collect()\n    Seq(1, 2, 3)\n\n    ```\n    Uniqueness can be defined by key keyword\n    ```python\n    &gt;&gt;&gt; pc.Iter([\"cat\", \"mouse\", \"dog\", \"hen\"]).unique(key=len).collect()\n    Seq('cat', 'mouse')\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.unique(self._inner, key=key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.unique_in_window","level":2,"title":"<code>unique_in_window(n, key=None)</code>","text":"<p>Yield the items from iterable that haven't been seen recently.</p> <p>The items in iterable must be hashable.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Size of the lookback window.</p> required <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the items that are unique within the specified window.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; iterable = [0, 1, 0, 2, 3, 0]\n&gt;&gt;&gt; n = 3\n&gt;&gt;&gt; pc.Iter(iterable).unique_in_window(n).collect()\nSeq(0, 1, 2, 3, 0)\n</code></pre> The key function, if provided, will be used to determine uniqueness: <pre><code>&gt;&gt;&gt; pc.Iter(\"abAcda\").unique_in_window(3, key=str.lower).collect()\nSeq('a', 'b', 'c', 'd', 'a')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unique_in_window(\n    self,\n    n: int,\n    key: Callable[[T], Any] | None = None,\n) -&gt; Iter[T]:\n    \"\"\"Yield the items from iterable that haven't been seen recently.\n\n    The items in iterable must be hashable.\n\n    Args:\n        n (int): Size of the lookback window.\n        key (Callable[[T], Any] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        Iter[T]: An iterable of the items that are unique within the specified window.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; iterable = [0, 1, 0, 2, 3, 0]\n    &gt;&gt;&gt; n = 3\n    &gt;&gt;&gt; pc.Iter(iterable).unique_in_window(n).collect()\n    Seq(0, 1, 2, 3, 0)\n\n    ```\n    The key function, if provided, will be used to determine uniqueness:\n    ```python\n    &gt;&gt;&gt; pc.Iter(\"abAcda\").unique_in_window(3, key=str.lower).collect()\n    Seq('a', 'b', 'c', 'd', 'a')\n\n    ```\n    \"\"\"\n    return Iter(mit.unique_in_window(self._inner, n, key=key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.unique_justseen","level":2,"title":"<code>unique_justseen(key=None)</code>","text":"<p>Yields elements in order, ignoring serial duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterable of the unique items, preserving order.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"AAAABBBCCDAABBB\").unique_justseen().collect()\nSeq('A', 'B', 'C', 'D', 'A', 'B')\n&gt;&gt;&gt; pc.Iter(\"ABBCcAD\").unique_justseen(str.lower).collect()\nSeq('A', 'B', 'C', 'A', 'D')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unique_justseen(self, key: Callable[[T], Any] | None = None) -&gt; Iter[T]:\n    \"\"\"Yields elements in order, ignoring serial duplicates.\n\n    Args:\n        key (Callable[[T], Any] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        Iter[T]: An iterable of the unique items, preserving order.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"AAAABBBCCDAABBB\").unique_justseen().collect()\n    Seq('A', 'B', 'C', 'D', 'A', 'B')\n    &gt;&gt;&gt; pc.Iter(\"ABBCcAD\").unique_justseen(str.lower).collect()\n    Seq('A', 'B', 'C', 'A', 'D')\n\n    ```\n    \"\"\"\n    return Iter(mit.unique_justseen(self._inner, key=key))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.unique_to_each","level":2,"title":"<code>unique_to_each()</code>","text":"<p>Return the elements from each of the iterators that aren't in the other iterators.</p> <p>It is assumed that the elements of each iterable are hashable.</p> <p>Credits</p> <pre><code>more_itertools.unique_to_each\n</code></pre> <p>Returns:</p> Type Description <code>Iter[Iter[U]]</code> <p>Iter[Iter[U]]: An iterator of iterators, each containing the unique elements from the corresponding input iterable.</p> <p>For example, suppose you have a set of packages, each with a set of dependencies:</p> <p>{'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}</p> <p>If you remove one package, which dependencies can also be removed?</p> <p>If pkg_1 is removed, then A is no longer necessary - it is not associated with pkg_2 or pkg_3.</p> <p>Similarly, C is only needed for pkg_2, and D is only needed for pkg_3:</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = ({\"A\", \"B\"}, {\"B\", \"C\"}, {\"B\", \"D\"})\n&gt;&gt;&gt; pc.Iter(data).unique_to_each().map(lambda x: x.into(list)).collect()\nSeq(['A'], ['C'], ['D'])\n</code></pre> <p>If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output.</p> <p>Input order is preserved: <pre><code>&gt;&gt;&gt; data = (\"mississippi\", \"missouri\")\n&gt;&gt;&gt; pc.Seq(data).iter().unique_to_each().map(lambda x: x.into(list)).collect()\nSeq(['p', 'p'], ['o', 'u', 'r'])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unique_to_each[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Iter[U]]:\n    \"\"\"Return the elements from each of the iterators that aren't in the other iterators.\n\n    It is assumed that the elements of each iterable are hashable.\n\n    **Credits**\n\n        more_itertools.unique_to_each\n\n    Returns:\n        Iter[Iter[U]]: An iterator of iterators, each containing the unique elements from the corresponding input iterable.\n\n    For example, suppose you have a set of packages, each with a set of dependencies:\n\n    **{'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}**\n\n    If you remove one package, which dependencies can also be removed?\n\n    If pkg_1 is removed, then A is no longer necessary - it is not associated with pkg_2 or pkg_3.\n\n    Similarly, C is only needed for pkg_2, and D is only needed for pkg_3:\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = ({\"A\", \"B\"}, {\"B\", \"C\"}, {\"B\", \"D\"})\n    &gt;&gt;&gt; pc.Iter(data).unique_to_each().map(lambda x: x.into(list)).collect()\n    Seq(['A'], ['C'], ['D'])\n\n    ```\n\n    If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output.\n\n    Input order is preserved:\n    ```python\n    &gt;&gt;&gt; data = (\"mississippi\", \"missouri\")\n    &gt;&gt;&gt; pc.Seq(data).iter().unique_to_each().map(lambda x: x.into(list)).collect()\n    Seq(['p', 'p'], ['o', 'u', 'r'])\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    pool: tuple[Iterable[U], ...] = tuple(self._inner)\n    counts: Counter[U] = Counter(itertools.chain.from_iterable(map(set, pool)))\n    uniques: set[U] = {element for element in counts if counts[element] == 1}\n\n    return Iter((Iter(filter(uniques.__contains__, it))) for it in pool)\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.unzip","level":2,"title":"<code>unzip()</code>","text":"<p>Converts an iterator of pairs into a pair of iterators.</p> <p>Returns:</p> Type Description <code>Unzipped[U, V]</code> <p>Unzipped[U, V]: dataclass with first and second iterators.</p> <p><code>Iter.unzip()</code> consumes the iterator of pairs.</p> <p>Returns an Unzipped dataclass, containing two iterators:</p> <ul> <li>one from the left elements of the pairs</li> <li>one from the right elements.</li> </ul> <p>This function is, in some sense, the opposite of zip. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n&gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n&gt;&gt;&gt; unzipped.left.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; unzipped.right.collect()\nSeq('a', 'b', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unzip[U, V](self: BaseIter[tuple[U, V]]) -&gt; Unzipped[U, V]:\n    \"\"\"Converts an iterator of pairs into a pair of iterators.\n\n    Returns:\n        Unzipped[U, V]: dataclass with first and second iterators.\n\n    `Iter.unzip()` consumes the iterator of pairs.\n\n    Returns an Unzipped dataclass, containing two iterators:\n\n    - one from the left elements of the pairs\n    - one from the right elements.\n\n    This function is, in some sense, the opposite of zip.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n    &gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n    &gt;&gt;&gt; unzipped.left.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; unzipped.right.collect()\n    Seq('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    d: tuple[tuple[U, V], ...] = tuple(self._inner)\n    return Unzipped(Iter(x[0] for x in d), Iter(x[1] for x in d))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.with_position","level":2,"title":"<code>with_position()</code>","text":"<p>Return an iterable over (<code>Position</code>, <code>T</code>) tuples.</p> <p>The <code>Position</code> indicates whether the item <code>T</code> is the first, middle, last, or only element in the iterable.</p> <p>Returns:</p> Type Description <code>Iter[tuple[Position, T]]</code> <p>Iter[tuple[Position, T]]: An iterable of (<code>Position</code>, item) tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).with_position().collect()\nSeq(('first', 'a'), ('middle', 'b'), ('last', 'c'))\n&gt;&gt;&gt; pc.Iter([\"a\"]).with_position().collect()\nSeq(('only', 'a'),)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def with_position(self) -&gt; Iter[tuple[Position, T]]:\n    \"\"\"Return an iterable over (`Position`, `T`) tuples.\n\n    The `Position` indicates whether the item `T` is the first, middle, last, or only element in the iterable.\n\n    Returns:\n        Iter[tuple[Position, T]]: An iterable of (`Position`, item) tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).with_position().collect()\n    Seq(('first', 'a'), ('middle', 'b'), ('last', 'c'))\n    &gt;&gt;&gt; pc.Iter([\"a\"]).with_position().collect()\n    Seq(('only', 'a'),)\n\n    ```\n    \"\"\"\n\n    def gen(data: Iterator[T]) -&gt; Iterator[tuple[Position, T]]:\n        try:\n            first = next(data)\n        except StopIteration:\n            return\n\n        try:\n            second = next(data)\n        except StopIteration:\n            yield (\"only\", first)\n            return\n        yield (\"first\", first)\n\n        current: T = second\n        for nxt in self._inner:\n            yield (\"middle\", current)\n            current = nxt\n        yield (\"last\", current)\n\n    return Iter(gen(self._inner))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.zip","level":2,"title":"<code>zip(*others, strict=False)</code>","text":"<pre><code>zip(\n    iter1: Iterable[T1], /, *, strict: bool = ...\n) -&gt; Iter[tuple[T, T1]]\n</code></pre><pre><code>zip(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    /,\n    *,\n    strict: bool = ...,\n) -&gt; Iter[tuple[T, T1, T2]]\n</code></pre><pre><code>zip(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    /,\n    *,\n    strict: bool = ...,\n) -&gt; Iter[tuple[T, T1, T2, T3]]\n</code></pre><pre><code>zip(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n    /,\n    *,\n    strict: bool = ...,\n) -&gt; Iter[tuple[T, T1, T2, T3, T4]]\n</code></pre> <p>Yields n-length tuples, where n is the number of iterables passed as positional arguments.</p> <p>The i-th element in every tuple comes from the i-th iterable argument to <code>.zip()</code>.</p> <p>This continues until the shortest argument is exhausted.</p> Note <p><code>Iter.map_star</code> can then be used for subsequent operations on the index and value, in a destructuring manner. This keep the code clean and readable, without index access like <code>[0]</code> and <code>[1]</code> for inline lambdas.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to zip with.</p> <code>()</code> <code>strict</code> <code>bool</code> <p>If <code>True</code> and one of the arguments is exhausted before the others, raise a ValueError. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iter[tuple[Any, ...]]</code> <p>Iter[tuple[Any, ...]]: An <code>Iter</code> of tuples containing elements from the zipped Iter and other iterables.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).zip([10, 20]).collect()\nSeq((1, 10), (2, 20))\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).zip([1, 2, 3]).collect()\nSeq(('a', 1), ('b', 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def zip(\n    self,\n    *others: Iterable[Any],\n    strict: bool = False,\n) -&gt; Iter[tuple[Any, ...]]:\n    \"\"\"Yields n-length tuples, where n is the number of iterables passed as positional arguments.\n\n    The i-th element in every tuple comes from the i-th iterable argument to `.zip()`.\n\n    This continues until the shortest argument is exhausted.\n\n    Note:\n        `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n        This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to zip with.\n        strict (bool): If `True` and one of the arguments is exhausted before the others, raise a ValueError. Defaults to `False`.\n\n    Returns:\n        Iter[tuple[Any, ...]]: An `Iter` of tuples containing elements from the zipped Iter and other iterables.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).zip([10, 20]).collect()\n    Seq((1, 10), (2, 20))\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).zip([1, 2, 3]).collect()\n    Seq(('a', 1), ('b', 2))\n\n    ```\n    \"\"\"\n    return Iter(zip(self._inner, *others, strict=strict))\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.zip_longest","level":2,"title":"<code>zip_longest(*others)</code>","text":"<pre><code>zip_longest(\n    iter2: Iterable[T2],\n) -&gt; Iter[tuple[Option[T], Option[T2]]]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T2], iter3: Iterable[T3]\n) -&gt; Iter[tuple[Option[T], Option[T2], Option[T3]]]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n) -&gt; Iter[\n    tuple[Option[T], Option[T2], Option[T3], Option[T4]]\n]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n    iter5: Iterable[T5],\n) -&gt; Iter[\n    tuple[\n        Option[T],\n        Option[T2],\n        Option[T3],\n        Option[T4],\n        Option[T5],\n    ]\n]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T],\n    iter3: Iterable[T],\n    iter4: Iterable[T],\n    iter5: Iterable[T],\n    iter6: Iterable[T],\n    /,\n    *iterables: Iterable[T],\n) -&gt; Iter[tuple[Option[T], ...]]\n</code></pre> <p>Return a zip Iterator who yield a tuple where the i-th element comes from the i-th iterable argument.</p> <p>Yield values until the longest iterable in the argument sequence is exhausted, and then it raises StopIteration.</p> <p>The longest iterable determines the length of the returned iterator, and will return <code>Some[T]</code> until exhaustion.</p> <p>When the shorter iterables are exhausted, they yield <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to zip with.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[tuple[Option[Any], ...]]</code> <p>Iter[tuple[Option[Any], ...]]: An iterable of tuples containing optional elements from the zipped iterables.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).collect()\nSeq((Some(1), Some(10)), (Some(2), NONE))\n&gt;&gt;&gt; # Can be combined with try collect to filter out the NONE:\n&gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).map(lambda x: pc.Iter(x).try_collect()).collect()\nSeq(Some(Vec(1, 10)), NONE)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def zip_longest(self, *others: Iterable[Any]) -&gt; Iter[tuple[Option[Any], ...]]:\n    \"\"\"Return a zip Iterator who yield a tuple where the i-th element comes from the i-th iterable argument.\n\n    Yield values until the longest iterable in the argument sequence is exhausted, and then it raises StopIteration.\n\n    The longest iterable determines the length of the returned iterator, and will return `Some[T]` until exhaustion.\n\n    When the shorter iterables are exhausted, they yield `NONE`.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to zip with.\n\n    Returns:\n        Iter[tuple[Option[Any], ...]]: An iterable of tuples containing optional elements from the zipped iterables.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).collect()\n    Seq((Some(1), Some(10)), (Some(2), NONE))\n    &gt;&gt;&gt; # Can be combined with try collect to filter out the NONE:\n    &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).map(lambda x: pc.Iter(x).try_collect()).collect()\n    Seq(Some(Vec(1, 10)), NONE)\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Iter(\n        tuple(Option(t) for t in tup)\n        for tup in itertools.zip_longest(self._inner, *others, fillvalue=None)\n    )\n</code></pre>","path":["API Reference","Collections","Iter"],"tags":[]},{"location":"reference/none/","level":1,"title":"None","text":"<p>               Bases: <code>Option[T]</code></p> <p>Option variant representing the absence of a value.</p> <p>This class is not supposed to be instanciated by the user. Instead, pyochain provide the <code>NONE</code> singleton (for performance reasons).</p> <p>For more documentation, see the <code>Option[T]</code> class.</p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@final\n@dataclass(init=False, slots=True)\nclass NoneOption[T](Option[T]):\n    \"\"\"Option variant representing the absence of a value.\n\n    This class is not supposed to be instanciated by the user.\n    Instead, pyochain provide the `NONE` singleton (for performance reasons).\n\n    For more documentation, see the `Option[T]` class.\n    \"\"\"\n\n    __match_args__ = ()\n\n    def __new__(cls, _value: object = None) -&gt; NoneOption[Any]:\n        \"\"\"Bypass Option's redirect by directly creating a NoneOption instance.\"\"\"\n        return cast(NoneOption[Any], object.__new__(cls))\n\n    def __repr__(self) -&gt; str:\n        return \"NONE\"\n\n    def is_some(self) -&gt; bool:\n        return False\n\n    def is_none(self) -&gt; bool:\n        return True\n\n    def unwrap(self) -&gt; Never:\n        msg = \"called `unwrap` on a `None`\"\n        raise OptionUnwrapError(msg)\n\n    def is_some_and[**P](\n        self,\n        predicate: Callable[Concatenate[T, P], bool],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; bool:\n        return False\n\n    def is_none_or[**P](\n        self,\n        func: Callable[Concatenate[T, P], bool],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; bool:\n        return self.is_none()\n\n    def expect(self, msg: str) -&gt; T:\n        msg = f\"{msg} (called `expect` on a `None`)\"\n        raise OptionUnwrapError(msg)\n\n    def unwrap_or(self, default: T) -&gt; T:\n        return default\n\n    def unwrap_or_else(self, f: Callable[[], T]) -&gt; T:\n        return f()\n\n    def map[**P, R](\n        self,\n        f: Callable[Concatenate[T, P], R],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Option[R]:\n        return NONE\n\n    def and_[U](self, optb: Option[U]) -&gt; Option[U]:  # noqa: ARG002\n        return NONE\n\n    def or_(self, optb: Option[T]) -&gt; Option[T]:\n        return optb\n\n    def and_then[**P, R](\n        self,\n        f: Callable[Concatenate[T, P], Option[R]],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Option[R]:\n        return NONE\n\n    def or_else(self, f: Callable[[], Option[T]]) -&gt; Option[T]:\n        return f()\n\n    def ok_or[E](self, err: E) -&gt; Result[T, E]:\n        from ._result import Err\n\n        return Err(err)\n\n    def ok_or_else[E](self, err: Callable[[], E]) -&gt; Result[T, E]:\n        from ._result import Err\n\n        return Err(err())\n\n    def map_or[**P, R](\n        self,\n        default: R,\n        f: Callable[Concatenate[T, P], R],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; R:\n        return default\n\n    def map_or_else[**P, R](self, default: Callable[[], R], f: Callable[[T], R]) -&gt; R:  # noqa: ARG002\n        return default()\n\n    def filter[**P, R](\n        self,\n        predicate: Callable[Concatenate[T, P], R],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Option[T]:\n        return self\n\n    def iter(self) -&gt; Iter[T]:\n        from ._iter import Iter\n\n        return Iter[T].empty()\n\n    def inspect[**P](\n        self,\n        f: Callable[Concatenate[T, P], object],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Option[T]:\n        return self\n\n    def unzip[U](self: Option[tuple[T, U]]) -&gt; tuple[Option[T], Option[U]]:\n        return NONE, NONE\n\n    def zip[U](self, other: Option[U]) -&gt; Option[tuple[T, U]]:  # noqa: ARG002\n        return NONE\n\n    def zip_with[U, R](self, other: Option[U], f: Callable[[T, U], R]) -&gt; Option[R]:  # noqa: ARG002\n        return NONE\n\n    def reduce[U](self, other: Option[T], func: Callable[[T, T], T]) -&gt; Option[T]:  # noqa: ARG002\n        if other.is_some():\n            return other\n        return self\n\n    def transpose[E](self: Option[Result[T, E]]) -&gt; Result[Option[T], E]:\n        from ._result import Ok\n\n        return Ok(Option(None))\n\n    def xor(self, optb: Option[T]) -&gt; Option[T]:\n        return optb if optb.is_some() else NONE\n</code></pre>","path":["API Reference","Optional Values","None"],"tags":[]},{"location":"reference/none/#pyochain._option.NoneOption.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Option</code>.</p> <p>Converts an <code>Option[Option[U]]</code> into an <code>Option[U]</code> by removing one level of nesting.</p> <p>Equivalent to <code>Option.and_then(lambda x: x)</code>.</p> <p>Returns:</p> Type Description <code>Option[U]</code> <p>Option[U]: The flattened option.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\nSome(42)\n&gt;&gt;&gt; pc.Some(pc.NONE).flatten()\nNONE\n&gt;&gt;&gt; pc.NONE.flatten()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>def flatten[U](self: Option[Option[U]]) -&gt; Option[U]:\n    \"\"\"Flattens a nested `Option`.\n\n    Converts an `Option[Option[U]]` into an `Option[U]` by removing one level of nesting.\n\n    Equivalent to `Option.and_then(lambda x: x)`.\n\n    Returns:\n        Option[U]: The flattened option.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\n    Some(42)\n    &gt;&gt;&gt; pc.Some(pc.NONE).flatten()\n    NONE\n    &gt;&gt;&gt; pc.NONE.flatten()\n    NONE\n\n    ```\n    \"\"\"\n    return self.and_then(lambda x: x)\n</code></pre>","path":["API Reference","Optional Values","None"],"tags":[]},{"location":"reference/none/#pyochain._option.NoneOption.if_some","level":2,"title":"<code>if_some(value)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on the truthiness of a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the value is truthy, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_some(42)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_some(0)\nNONE\n&gt;&gt;&gt; pc.Option.if_some(\"hello\")\nSome('hello')\n&gt;&gt;&gt; pc.Option.if_some(\"\")\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@staticmethod\ndef if_some[V](value: V) -&gt; Option[V]:\n    \"\"\"Creates an `Option[V]` based on the truthiness of a value.\n\n    Args:\n        value (V): The value to evaluate.\n\n    Returns:\n        Option[V]: `Some(value)` if the value is truthy, otherwise `NONE`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Option.if_some(42)\n    Some(42)\n    &gt;&gt;&gt; pc.Option.if_some(0)\n    NONE\n    &gt;&gt;&gt; pc.Option.if_some(\"hello\")\n    Some('hello')\n    &gt;&gt;&gt; pc.Option.if_some(\"\")\n    NONE\n\n    ```\n    \"\"\"\n    return cast(Option[V], Some(value) if value else NONE)\n</code></pre>","path":["API Reference","Optional Values","None"],"tags":[]},{"location":"reference/none/#pyochain._option.NoneOption.if_true","level":2,"title":"<code>if_true(value, *, predicate)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on a predicate condition.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to wrap in <code>Some</code> if the condition is <code>True</code>.</p> required <code>predicate</code> <code>Callable[[], bool]</code> <p>The condition to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the condition is <code>True</code>, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 4)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 5)\nNONE\n&gt;&gt;&gt; # Evaluate on __bool__ of a collection (will call __len__ under the hood)\n&gt;&gt;&gt; data = [1, 2, 3]\n&gt;&gt;&gt; pc.Option.if_true(data, predicate=lambda: data)\nSome([1, 2, 3])\n&gt;&gt;&gt; empty_data = []\n&gt;&gt;&gt; pc.Option.if_true(empty_data, predicate=lambda: empty_data)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@staticmethod\ndef if_true[V](value: V, *, predicate: Callable[[], bool]) -&gt; Option[V]:\n    \"\"\"Creates an `Option[V]` based on a **predicate** condition.\n\n    Args:\n        value (V): The value to wrap in `Some` if the condition is `True`.\n        predicate (Callable[[], bool]): The condition to evaluate.\n\n    Returns:\n        Option[V]: `Some(value)` if the condition is `True`, otherwise `NONE`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 4)\n    Some(42)\n    &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 5)\n    NONE\n    &gt;&gt;&gt; # Evaluate on __bool__ of a collection (will call __len__ under the hood)\n    &gt;&gt;&gt; data = [1, 2, 3]\n    &gt;&gt;&gt; pc.Option.if_true(data, predicate=lambda: data)\n    Some([1, 2, 3])\n    &gt;&gt;&gt; empty_data = []\n    &gt;&gt;&gt; pc.Option.if_true(empty_data, predicate=lambda: empty_data)\n    NONE\n\n    ```\n    \"\"\"\n    return cast(Option[V], Some(value) if predicate() else NONE)\n</code></pre>","path":["API Reference","Optional Values","None"],"tags":[]},{"location":"reference/none/#pyochain._option.NoneOption.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Optional Values","None"],"tags":[]},{"location":"reference/ok/","level":1,"title":"Ok","text":"<p>               Bases: <code>Result[T, E]</code></p> <p>Represents a successful value.</p> <p>For more documentation, see the <code>Result[T, E]</code> class.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>T</code> <p>The contained successful value.</p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@final\n@dataclass(slots=True)\nclass Ok[T, E](Result[T, E]):\n    \"\"\"Represents a successful value.\n\n    For more documentation, see the `Result[T, E]` class.\n\n    Attributes:\n        value (T): The contained successful value.\n    \"\"\"\n\n    __match_args__ = (\"value\",)\n\n    value: T\n\n    def __repr__(self) -&gt; str:\n        return f\"Ok({self.value!r})\"\n\n    def is_ok(self) -&gt; bool:\n        return True\n\n    def is_err(self) -&gt; bool:\n        return False\n\n    def unwrap(self) -&gt; T:\n        return self.value\n\n    def unwrap_err(self) -&gt; Never:\n        msg = \"called `unwrap_err` on Ok\"\n        raise ResultUnwrapError(msg)\n\n    def map_or_else[U](self, ok: Callable[[T], U], err: Callable[[E], U]) -&gt; U:  # noqa: ARG002\n        return ok(self.unwrap())\n\n    def expect(self, msg: str) -&gt; T:  # noqa: ARG002\n        return self.unwrap()\n\n    def expect_err(self, msg: str) -&gt; E:\n        err_msg = f\"{msg}: expected Err, got Ok({self.unwrap()!r})\"\n        raise ResultUnwrapError(err_msg)\n\n    def unwrap_or(self, default: T) -&gt; T:  # noqa: ARG002\n        return self.unwrap()\n\n    def unwrap_or_else[**P](\n        self,\n        fn: Callable[Concatenate[E, P], T],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; T:\n        return self.unwrap()\n\n    def map[**P, R](\n        self, fn: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[R, E]:\n        return Ok(fn(self.unwrap(), *args, **kwargs))\n\n    def map_err[**P, R](\n        self,\n        fn: Callable[Concatenate[E, P], R],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Result[T, R]:\n        return cast(Result[T, R], self)\n\n    def inspect[**P](\n        self, fn: Callable[Concatenate[T, P], object], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[T, E]:\n        fn(self.unwrap(), *args, **kwargs)\n        return self\n\n    def inspect_err[**P](\n        self,\n        fn: Callable[Concatenate[E, P], object],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Result[T, E]:\n        return self\n\n    def and_[U](self, res: Result[U, E]) -&gt; Result[U, E]:\n        return res\n\n    def and_then[**P, R](\n        self,\n        fn: Callable[Concatenate[T, P], Result[R, E]],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Result[R, E]:\n        return fn(self.unwrap(), *args, **kwargs)\n\n    def or_else[**P](\n        self,\n        fn: Callable[Concatenate[E, P], Result[T, E]],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; Result[T, E]:\n        return self\n\n    def ok(self) -&gt; Option[T]:\n        from ._option import Some\n\n        return Some(self.unwrap())\n\n    def err(self) -&gt; Option[E]:\n        from ._option import NONE\n\n        return NONE\n\n    def is_ok_and[**P](\n        self, pred: Callable[Concatenate[T, P], bool], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; bool:\n        return pred(self.unwrap(), *args, **kwargs)\n\n    def is_err_and[**P](\n        self,\n        pred: Callable[Concatenate[E, P], bool],  # noqa: ARG002\n        *args: P.args,  # noqa: ARG002\n        **kwargs: P.kwargs,  # noqa: ARG002\n    ) -&gt; bool:\n        return False\n\n    def map_or[**P, R](\n        self,\n        default: R,  # noqa: ARG002\n        f: Callable[Concatenate[T, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; R:\n        return f(self.unwrap(), *args, **kwargs)\n\n    def transpose(self: Result[Option[T], E]) -&gt; Option[Result[T, E]]:\n        from ._option import NONE, Some\n\n        opt = self.unwrap()\n        if opt.is_none():\n            return NONE\n        return Some(Ok(opt.unwrap()))\n\n    def or_[F](self, res: Result[T, F]) -&gt; Result[T, F]:  # noqa: ARG002\n        return cast(Result[T, F], self)\n</code></pre>","path":["API Reference","Error Handling","Ok"],"tags":[]},{"location":"reference/ok/#pyochain._result.Ok.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Result</code>.</p> <p>Converts from <code>Result[Result[T, E], E]</code> to <code>Result[T, E]</code>.</p> <p>Equivalent to calling <code>Result.and_then(lambda x: x)</code>, but more convenient when there's no need to process the inner <code>Ok</code> value.</p> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The flattened result.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n&gt;&gt;&gt; nested_ok.flatten()\nOk(2)\n&gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n&gt;&gt;&gt; nested_err.flatten()\nErr('inner error')\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>def flatten(self: Result[Result[T, E], E]) -&gt; Result[T, E]:\n    \"\"\"Flattens a nested `Result`.\n\n    Converts from `Result[Result[T, E], E]` to `Result[T, E]`.\n\n    Equivalent to calling `Result.and_then(lambda x: x)`, but more convenient when there's no need to process the inner `Ok` value.\n\n    Returns:\n        Result[T, E]: The flattened result.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n    &gt;&gt;&gt; nested_ok.flatten()\n    Ok(2)\n    &gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n    &gt;&gt;&gt; nested_err.flatten()\n    Err('inner error')\n\n    ```\n    \"\"\"\n    return self.and_then(lambda x: x)\n</code></pre>","path":["API Reference","Error Handling","Ok"],"tags":[]},{"location":"reference/ok/#pyochain._result.Ok.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Error Handling","Ok"],"tags":[]},{"location":"reference/ok/#pyochain._result.Ok.iter","level":2,"title":"<code>iter()</code>","text":"<p>Returns a <code>Iter[T]</code> over the possibly contained value.</p> <p>The iterator yields one value if the result is <code>Ok</code>, otherwise none.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterator over the <code>Ok</code> value, or empty if <code>Err</code>.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(7).iter().next()\nSome(7)\n&gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Returns a `Iter[T]` over the possibly contained value.\n\n    The iterator yields one value if the result is `Ok`, otherwise none.\n\n    Returns:\n        Iter[T]: An iterator over the `Ok` value, or empty if `Err`.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(7).iter().next()\n    Some(7)\n    &gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\n    NONE\n\n    ```\n    \"\"\"\n    return self.ok().iter()\n</code></pre>","path":["API Reference","Error Handling","Ok"],"tags":[]},{"location":"reference/option/","level":1,"title":"Option","text":"<p>               Bases: <code>Pipeable</code></p> <p>Type <code>Option[T]</code> represents an optional value.</p> <p>Every Option is either:</p> <ul> <li><code>Some</code> and contains a value</li> <li><code>None</code>, and does not.</li> </ul> <p>This is a common type in Rust, and is used to represent values that may be absent.</p> <p>In python, this is best tought of a an union type <code>T | None</code>, but with additional methods to operate on the contained value in a functional style.</p> <p><code>Option[T]</code> and/or <code>T | None</code> types are very useful, as they have a number of uses:</p> <ul> <li>Initial values</li> <li>Union types</li> <li>Return value where None is returned on error</li> <li>Optional class fields</li> <li>Optional function arguments</li> </ul> <p>The fact that <code>T | None</code> is a very common pattern in python, but without a dedicated structure/handling, leads to:</p> <ul> <li>a lot of boilerplate code</li> <li>potential bugs (even with type checkers)</li> <li>less readable code (where does the None come from? is it expected?).</li> </ul> <p><code>Option[T]</code> instances are commonly paired with pattern matching. This allow to query the presence of a value and take action, always accounting for the None case.</p> Source code in <code>src/pyochain/_option.py</code> <pre><code>class Option[T](Pipeable):\n    \"\"\"Type `Option[T]` represents an optional value.\n\n    Every Option is either:\n\n    - `Some` and contains a value\n    - `None`, and does not.\n\n    This is a common type in Rust, and is used to represent values that may be absent.\n\n    In python, this is best tought of a an union type `T | None`,\n    but with additional methods to operate on the contained value in a functional style.\n\n    `Option[T]` and/or `T | None` types are very useful, as they have a number of uses:\n\n    - Initial values\n    - Union types\n    - Return value where None is returned on error\n    - Optional class fields\n    - Optional function arguments\n\n    The fact that `T | None` is a very common pattern in python,\n    but without a dedicated structure/handling, leads to:\n\n    - a lot of boilerplate code\n    - potential bugs (even with type checkers)\n    - less readable code (where does the None come from? is it expected?).\n\n    `Option[T]` instances are commonly paired with pattern matching.\n    This allow to query the presence of a value and take action, always accounting for the None case.\n    \"\"\"\n\n    def __new__[V](cls, value: V | None) -&gt; Option[V]:\n        \"\"\"Creates an `Option[V]` from a value that may be `None`.\n\n        When calling `Option(value)`, this method automatically redirects to:\n        - `Some(value)` if the value is not `None`\n        - `NONE` if the value is `None`\n\n        Args:\n            value (V | None): The value to convert into an `Option[V]`.\n\n        Returns:\n            Option[V]: `Some(value)` if the value is not `None`, otherwise `NONE`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Option(42)\n        Some(42)\n        &gt;&gt;&gt; pc.Option(None)\n        NONE\n\n        ```\n        \"\"\"\n        if value is None:\n            return cast(Option[V], NONE)\n        return cast(Option[V], Some(value))\n\n    @staticmethod\n    @warnings.deprecated(\"Use Option(value) instead.\")\n    def from_[V](value: V | None) -&gt; Option[V]:\n        return Option(value)\n\n    def __bool__(self) -&gt; None:\n        \"\"\"Prevent implicit `Some|None` value checking in boolean contexts.\n\n        Raises:\n            TypeError: Always, to prevent implicit `Some|None` value checking.\n        \"\"\"\n        msg = \"Option instances cannot be used in boolean contexts for implicit `Some|None` value checking. Use is_some() or is_none() instead.\"\n        raise TypeError(msg)\n\n    @staticmethod\n    def if_true[V](value: V, *, predicate: Callable[[], bool]) -&gt; Option[V]:\n        \"\"\"Creates an `Option[V]` based on a **predicate** condition.\n\n        Args:\n            value (V): The value to wrap in `Some` if the condition is `True`.\n            predicate (Callable[[], bool]): The condition to evaluate.\n\n        Returns:\n            Option[V]: `Some(value)` if the condition is `True`, otherwise `NONE`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 4)\n        Some(42)\n        &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 5)\n        NONE\n        &gt;&gt;&gt; # Evaluate on __bool__ of a collection (will call __len__ under the hood)\n        &gt;&gt;&gt; data = [1, 2, 3]\n        &gt;&gt;&gt; pc.Option.if_true(data, predicate=lambda: data)\n        Some([1, 2, 3])\n        &gt;&gt;&gt; empty_data = []\n        &gt;&gt;&gt; pc.Option.if_true(empty_data, predicate=lambda: empty_data)\n        NONE\n\n        ```\n        \"\"\"\n        return cast(Option[V], Some(value) if predicate() else NONE)\n\n    @staticmethod\n    def if_some[V](value: V) -&gt; Option[V]:\n        \"\"\"Creates an `Option[V]` based on the truthiness of a value.\n\n        Args:\n            value (V): The value to evaluate.\n\n        Returns:\n            Option[V]: `Some(value)` if the value is truthy, otherwise `NONE`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Option.if_some(42)\n        Some(42)\n        &gt;&gt;&gt; pc.Option.if_some(0)\n        NONE\n        &gt;&gt;&gt; pc.Option.if_some(\"hello\")\n        Some('hello')\n        &gt;&gt;&gt; pc.Option.if_some(\"\")\n        NONE\n\n        ```\n        \"\"\"\n        return cast(Option[V], Some(value) if value else NONE)\n\n    def flatten[U](self: Option[Option[U]]) -&gt; Option[U]:\n        \"\"\"Flattens a nested `Option`.\n\n        Converts an `Option[Option[U]]` into an `Option[U]` by removing one level of nesting.\n\n        Equivalent to `Option.and_then(lambda x: x)`.\n\n        Returns:\n            Option[U]: The flattened option.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\n        Some(42)\n        &gt;&gt;&gt; pc.Some(pc.NONE).flatten()\n        NONE\n        &gt;&gt;&gt; pc.NONE.flatten()\n        NONE\n\n        ```\n        \"\"\"\n        return self.and_then(lambda x: x)\n\n    # Abstract methods ----------------------------------------------------------------\n\n    @abstractmethod\n    def is_some(self) -&gt; bool:\n        \"\"\"Returns `True` if the option is a `Some` value.\n\n        Returns:\n            bool: `True` if the option is a `Some` variant, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; x: Option[int] = pc.Some(2)\n        &gt;&gt;&gt; x.is_some()\n        True\n        &gt;&gt;&gt; y: Option[int] = pc.NONE\n        &gt;&gt;&gt; y.is_some()\n        False\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_some_and[**P](\n        self,\n        predicate: Callable[Concatenate[T, P], bool],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; bool:\n        \"\"\"Returns true if the option is a Some and the value inside of it matches a predicate.\n\n        Args:\n            predicate (Callable[Concatenate[T, P], bool]): The predicate to apply to the contained value.\n            *args (P.args): Additional positional arguments to pass to predicate.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to predicate.\n\n        Returns:\n            bool: `True` if the option is `Some` and the predicate returns `True` for the contained value, `False` otherwise.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; x = pc.Some(2)\n        &gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\n        True\n\n        &gt;&gt;&gt; x = pc.Some(0)\n        &gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\n        False\n        &gt;&gt;&gt; x = pc.NONE\n        &gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\n        False\n        &gt;&gt;&gt; x = pc.Some(\"hello\")\n        &gt;&gt;&gt; x.is_some_and(lambda x: len(x) &gt; 1)\n        True\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_none(self) -&gt; bool:\n        \"\"\"Returns `True` if the option is a `None` value.\n\n        Returns:\n            bool: `True` if the option is a `_None` variant, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; x: Option[int] = pc.Some(2)\n        &gt;&gt;&gt; x.is_none()\n        False\n        &gt;&gt;&gt; y: Option[int] = pc.NONE\n        &gt;&gt;&gt; y.is_none()\n        True\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_none_or[**P](\n        self, func: Callable[Concatenate[T, P], bool], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; bool:\n        \"\"\"Returns true if the option is a None or the value inside of it matches a predicate.\n\n        Args:\n            func (Callable[Concatenate[T, P], bool]): The predicate to apply to the contained value.\n            *args (P.args): Additional positional arguments to pass to func.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to func.\n\n        Returns:\n            bool: `True` if the option is `None` or the predicate returns `True` for the contained value, `False` otherwise.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(2).is_none_or(lambda x: x &gt; 1)\n        True\n        &gt;&gt;&gt; pc.Some(0).is_none_or(lambda x: x &gt; 1)\n        False\n        &gt;&gt;&gt; pc.NONE.is_none_or(lambda x: x &gt; 1)\n        True\n        &gt;&gt;&gt; pc.Some(\"hello\").is_none_or(lambda x: len(x) &gt; 1)\n        True\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def unwrap(self) -&gt; T:\n        \"\"\"Returns the contained `Some` value.\n\n        Returns:\n            T: The contained `Some` value.\n\n        Raises:\n            OptionUnwrapError: If the option is `None`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(\"car\").unwrap()\n        'car'\n\n        ```\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.NONE.unwrap()\n        Traceback (most recent call last):\n            ...\n        pyochain._option.OptionUnwrapError: called `unwrap` on a `None`\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def expect(self, msg: str) -&gt; T:\n        \"\"\"Returns the contained `Some` value.\n\n        Raises an exception with a provided message if the value is `None`.\n\n        Args:\n            msg (str): The message to include in the exception if the result is `None`.\n\n        Returns:\n            T: The contained `Some` value.\n\n        Raises:\n            OptionUnwrapError: If the result is `None`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(\"value\").expect(\"fruits are healthy\")\n        'value'\n        &gt;&gt;&gt; pc.NONE.expect(\"fruits are healthy\")\n        Traceback (most recent call last):\n            ...\n        pyochain._option.OptionUnwrapError: fruits are healthy (called `expect` on a `None`)\n\n        ```\n        \"\"\"\n        if self.is_some():\n            return self.unwrap()\n        msg = f\"{msg} (called `expect` on a `None`)\"\n        raise OptionUnwrapError(msg)\n\n    @abstractmethod\n    def unwrap_or(self, default: T) -&gt; T:\n        \"\"\"Returns the contained `Some` value or a provided default.\n\n        Args:\n            default (T): The value to return if the result is `None`.\n\n        Returns:\n            T: The contained `Some` value or the provided default.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(\"car\").unwrap_or(\"bike\")\n        'car'\n        &gt;&gt;&gt; pc.NONE.unwrap_or(\"bike\")\n        'bike'\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def unwrap_or_else(self, f: Callable[[], T]) -&gt; T:\n        \"\"\"Returns the contained `Some` value or computes it from a function.\n\n        Args:\n            f (Callable[[], T]): A function that returns a default value if the result is `None`.\n\n        Returns:\n            T: The contained `Some` value or the result of the function.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; k = 10\n        &gt;&gt;&gt; pc.Some(4).unwrap_or_else(lambda: 2 * k)\n        4\n        &gt;&gt;&gt; pc.NONE.unwrap_or_else(lambda: 2 * k)\n        20\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def map[**P, R](\n        self, f: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Option[R]:\n        \"\"\"Maps an `Option[T]` to `Option[U]`.\n\n        Done by applying a function to a contained `Some` value,\n        leaving a `None` value untouched.\n\n        Args:\n            f (Callable[Concatenate[T, P], R]): The function to apply to the `Some` value.\n            *args (P.args): Additional positional arguments to pass to f.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n        Returns:\n            Option[R]: A new `Option` with the mapped value if `Some`, otherwise `None`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(\"Hello, World!\").map(len)\n        Some(13)\n        &gt;&gt;&gt; pc.NONE.map(len)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def and_[U](self, optb: Option[U]) -&gt; Option[U]:\n        \"\"\"Returns `NONE` if the option is `NONE`, otherwise returns optb.\n\n        This is similar to `and_then`, except that the value is passed directly instead of through a closure.\n\n        Args:\n            optb (Option[U]): The option to return if the original option is `NONE`\n        Returns:\n            Option[U]: `NONE` if the original option is `NONE`, otherwise `optb`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(2).and_(pc.NONE)\n        NONE\n        &gt;&gt;&gt; pc.NONE.and_(pc.Some(\"foo\"))\n        NONE\n        &gt;&gt;&gt; pc.Some(2).and_(pc.Some(\"foo\"))\n        Some('foo')\n        &gt;&gt;&gt; pc.NONE.and_(pc.NONE)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def or_(self, optb: Option[T]) -&gt; Option[T]:\n        \"\"\"Returns the option if it contains a value, otherwise returns optb.\n\n        Args:\n            optb (Option[T]): The option to return if the original option is `NONE`.\n\n        Returns:\n            Option[T]: The original option if it is `Some`, otherwise `optb`.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(2).or_(pc.NONE)\n        Some(2)\n        &gt;&gt;&gt; pc.NONE.or_(pc.Some(100))\n        Some(100)\n        &gt;&gt;&gt; pc.Some(2).or_(pc.Some(100))\n        Some(2)\n        &gt;&gt;&gt; pc.NONE.or_(pc.NONE)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def and_then[**P, R](\n        self,\n        f: Callable[Concatenate[T, P], Option[R]],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Option[R]:\n        \"\"\"Calls a function if the option is `Some`, otherwise returns `None`.\n\n        Args:\n            f (Callable[Concatenate[T, P], Option[R]]): The function to call with the `Some` value.\n            *args (P.args): Additional positional arguments to pass to f.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n        Returns:\n            Option[R]: The result of the function if `Some`, otherwise `None`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def sq(x: int) -&gt; Option[int]:\n        ...     return pc.Some(x * x)\n        &gt;&gt;&gt; def nope(x: int) -&gt; Option[int]:\n        ...     return pc.NONE\n        &gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(sq)\n        Some(16)\n        &gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(nope)\n        NONE\n        &gt;&gt;&gt; pc.Some(2).and_then(nope).and_then(sq)\n        NONE\n        &gt;&gt;&gt; pc.NONE.and_then(sq).and_then(sq)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def or_else(self, f: Callable[[], Option[T]]) -&gt; Option[T]:\n        \"\"\"Returns the `Option[T]` if it contains a value, otherwise calls a function and returns the result.\n\n        Args:\n            f (Callable[[], Option[T]]): The function to call if the option is `None`.\n\n        Returns:\n            Option[T]: The original `Option` if it is `Some`, otherwise the result of the function.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def nobody() -&gt; Option[str]:\n        ...     return pc.NONE\n        &gt;&gt;&gt; def vikings() -&gt; Option[str]:\n        ...     return pc.Some(\"vikings\")\n        &gt;&gt;&gt; pc.Some(\"barbarians\").or_else(vikings)\n        Some('barbarians')\n        &gt;&gt;&gt; pc.NONE.or_else(vikings)\n        Some('vikings')\n        &gt;&gt;&gt; pc.NONE.or_else(nobody)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def ok_or[E](self, err: E) -&gt; Result[T, E]:\n        \"\"\"Converts the option to a `Result`.\n\n        Args:\n            err (E): The error value to use if the option is `NONE`.\n\n        Returns:\n            Result[T, E]: `Ok(v)` if `Some(v)`, otherwise `Err(err)`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(1).ok_or('fail')\n        Ok(1)\n        &gt;&gt;&gt; pc.NONE.ok_or('fail')\n        Err('fail')\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def ok_or_else[E](self, err: Callable[[], E]) -&gt; Result[T, E]:\n        \"\"\"Converts the option to a Result.\n\n        Args:\n            err (Callable[[], E]): A function returning the error value if the option is NONE.\n\n        Returns:\n            Result[T, E]: Ok(v) if Some(v), otherwise Err(err()).\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(1).ok_or_else(lambda: 'fail')\n        Ok(1)\n        &gt;&gt;&gt; pc.NONE.ok_or_else(lambda: 'fail')\n        Err('fail')\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def map_or[**P, R](\n        self,\n        default: R,\n        f: Callable[Concatenate[T, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; R:\n        \"\"\"Returns the result of applying a function to the contained value if Some, otherwise returns the default value.\n\n        Args:\n            default (R): The default value to return if NONE.\n            f (Callable[Concatenate[T, P], R]): The function to apply to the contained value.\n            *args (P.args): Additional positional arguments to pass to f.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n        Returns:\n            R: The result of f(self.unwrap()) if Some, otherwise default.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(2).map_or(0, lambda x: x * 10)\n        20\n        &gt;&gt;&gt; pc.NONE.map_or(0, lambda x: x * 10)\n        0\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def map_or_else[**P, R](self, default: Callable[[], R], f: Callable[[T], R]) -&gt; R:\n        \"\"\"Returns the result of applying a function to the contained value if Some, otherwise computes a default value.\n\n        Args:\n            default (Callable[[], R]): A function returning the default value if NONE.\n            f (Callable[[T], R]): The function to apply to the contained value.\n\n        Returns:\n            R: The result of f(self.unwrap()) if Some, otherwise default().\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(2).map_or_else(lambda: 0, lambda x: x * 10)\n        20\n        &gt;&gt;&gt; pc.NONE.map_or_else(lambda: 0, lambda x: x * 10)\n        0\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def filter[**P, R](\n        self,\n        predicate: Callable[Concatenate[T, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Option[T]:\n        \"\"\"Returns None if the option is None, otherwise calls predicate with the wrapped value.\n\n        This function works similar to `Iter.filter` in the sense that we only keep the value if it matches a predicate.\n\n        You can imagine the `Option[T]` being an iterator over one or zero elements.\n\n        Args:\n            predicate (Callable[Concatenate[T, P], R]): The predicate to apply to the contained value.\n            *args (P.args): Additional positional arguments to pass to predicate.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to predicate.\n\n        Returns:\n            Option[T]: `Some[T]` if predicate returns true (where T is the wrapped value), `NONE` if predicate returns false.\n\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n        ...     return n % 2 == 0\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.NONE.filter(is_even)\n        NONE\n        &gt;&gt;&gt; pc.Some(3).filter(is_even)\n        NONE\n        &gt;&gt;&gt; pc.Some(4).filter(is_even)\n        Some(4)\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def iter(self) -&gt; Iter[T]:\n        \"\"\"Creates an `Iter` over the optional value.\n\n        - If the option is `Some(value)`, the iterator yields `value`.\n        - If the option is `NONE`, the iterator yields nothing.\n\n        Equivalent to `Iter((self,))`.\n\n        Returns:\n            Iter[T]: An iterator over the optional value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(42).iter().next()\n        Some(42)\n        &gt;&gt;&gt; pc.NONE.iter().next()\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def inspect[**P](\n        self, f: Callable[Concatenate[T, P], object], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Option[T]:\n        \"\"\"Applies a function to the contained `Some` value, returning the original `Option`.\n\n        This allows side effects (logging, debugging, metrics, etc.) on the wrapped value without changing it.\n\n        Args:\n            f (Callable[Concatenate[T, P], object]): Function to apply to the `Some` value.\n            *args (P.args): Additional positional arguments to pass to f.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n        Returns:\n            Option[T]: The original option, unchanged.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; seen: list[int] = []\n        &gt;&gt;&gt; pc.Some(2).inspect(lambda x: seen.append(x))\n        Some(2)\n        &gt;&gt;&gt; seen\n        [2]\n        &gt;&gt;&gt; pc.NONE.inspect(lambda x: seen.append(x))\n        NONE\n        &gt;&gt;&gt; seen\n        [2]\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def unzip[U](self: Option[tuple[T, U]]) -&gt; tuple[Option[T], Option[U]]:\n        \"\"\"Unzips an `Option` of a tuple into a tuple of `Option`s.\n\n        If the option is `Some((a, b))`, this method returns `(Some(a), Some(b))`.\n        If the option is `NONE`, it returns `(NONE, NONE)`.\n\n        Returns:\n            tuple[Option[T], Option[U]]: A tuple containing two options.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some((1, 'a')).unzip()\n        (Some(1), Some('a'))\n        &gt;&gt;&gt; pc.NONE.unzip()\n        (NONE, NONE)\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def zip[U](self, other: Option[U]) -&gt; Option[tuple[T, U]]:\n        \"\"\"Returns an `Option[tuple[T, U]]` containing a tuple of the values if both options are `Some`, otherwise returns `NONE`.\n\n        Args:\n            other (Option[U]): The other option to zip with.\n\n        Returns:\n            Option[tuple[T, U]]: Some((self, other)) if both are Some, otherwise NONE.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(1).zip(pc.Some('a'))\n        Some((1, 'a'))\n        &gt;&gt;&gt; pc.Some(1).zip(pc.NONE)\n        NONE\n        &gt;&gt;&gt; pc.NONE.zip(pc.Some('a'))\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def zip_with[U, R](self, other: Option[U], f: Callable[[T, U], R]) -&gt; Option[R]:\n        \"\"\"Zips `self` and another `Option` with function `f`.\n\n        If `self` is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`.\n\n        Otherwise, `NONE` is returned.\n\n        Args:\n            other (Option[U]): The second option.\n            f (Callable[[T, U], R]): The function to apply to the unwrapped values.\n\n        Returns:\n            Option[R]: The resulting option after applying the function.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; @dataclass\n        ... class Point:\n        ...     x: float\n        ...     y: float\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; x = pc.Some(17.5)\n        &gt;&gt;&gt; y = pc.Some(42.7)\n        &gt;&gt;&gt; x.zip_with(y, Point)\n        Some(Point(x=17.5, y=42.7))\n        &gt;&gt;&gt; x.zip_with(pc.NONE, Point)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def reduce[U](self, other: Option[T], func: Callable[[T, T], T]) -&gt; Option[T]:\n        \"\"\"Reduces two options into one, using the provided function if both are Some.\n\n        If **self** is `Some(s)` and **other** is `Some(o)`, this method returns `Some(func(s, o))`.\n\n        Otherwise, if only one of **self** and **other** is `Some`, that value is returned.\n\n        If both **self** and **other** are `NONE`, `NONE` is returned.\n\n        Args:\n            other (Option[T]): The second option.\n            func (Callable[[T, T], T]): The function to apply to the unwrapped values.\n\n        Returns:\n            Option[T]: The resulting option after reduction.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; s12 = pc.Some(12)\n        &gt;&gt;&gt; s17 = pc.Some(17)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def add(a: int, b: int) -&gt; int:\n        ...     return a + b\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; s12.reduce(s17, add)\n        Some(29)\n        &gt;&gt;&gt; s12.reduce(pc.NONE, add)\n        Some(12)\n        &gt;&gt;&gt; pc.NONE.reduce(s17, add)\n        Some(17)\n        &gt;&gt;&gt; pc.NONE.reduce(pc.NONE, add)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transpose[E](self: Option[Result[T, E]]) -&gt; Result[Option[T], E]:\n        \"\"\"Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n\n        `Some(Ok[T])` is mapped to `Ok(Some[T])`, `Some(Err[E])` is mapped to `Err[E]`, and `NONE` will be mapped to `Ok(NONE)`.\n\n        Returns:\n            Result[Option[T], E]: The transposed result.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(pc.Ok(5)).transpose()\n        Ok(Some(5))\n        &gt;&gt;&gt; pc.NONE.transpose()\n        Ok(NONE)\n        &gt;&gt;&gt; pc.Some(pc.Err(\"error\")).transpose()\n        Err('error')\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def xor(self, optb: Option[T]) -&gt; Option[T]:\n        \"\"\"Returns `Some` if exactly one of **self**, optb is `Some`, otherwise returns `NONE`.\n\n        Args:\n            optb (Option[T]): The other option to compare with.\n\n        Returns:\n            Option[T]: `Some` value if exactly one option is `Some`, otherwise `NONE`.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Some(2).xor(pc.NONE)\n        Some(2)\n        &gt;&gt;&gt; pc.NONE.xor(pc.Some(2))\n        Some(2)\n        &gt;&gt;&gt; pc.Some(2).xor(pc.Some(2))\n        NONE\n        &gt;&gt;&gt; pc.NONE.xor(pc.NONE)\n        NONE\n\n        ```\n        \"\"\"\n        ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.and_","level":2,"title":"<code>and_(optb)</code>  <code>abstractmethod</code>","text":"<p>Returns <code>NONE</code> if the option is <code>NONE</code>, otherwise returns optb.</p> <p>This is similar to <code>and_then</code>, except that the value is passed directly instead of through a closure.</p> <p>Parameters:</p> Name Type Description Default <code>optb</code> <code>Option[U]</code> <p>The option to return if the original option is <code>NONE</code></p> required <p>Returns:     Option[U]: <code>NONE</code> if the original option is <code>NONE</code>, otherwise <code>optb</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).and_(pc.NONE)\nNONE\n&gt;&gt;&gt; pc.NONE.and_(pc.Some(\"foo\"))\nNONE\n&gt;&gt;&gt; pc.Some(2).and_(pc.Some(\"foo\"))\nSome('foo')\n&gt;&gt;&gt; pc.NONE.and_(pc.NONE)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef and_[U](self, optb: Option[U]) -&gt; Option[U]:\n    \"\"\"Returns `NONE` if the option is `NONE`, otherwise returns optb.\n\n    This is similar to `and_then`, except that the value is passed directly instead of through a closure.\n\n    Args:\n        optb (Option[U]): The option to return if the original option is `NONE`\n    Returns:\n        Option[U]: `NONE` if the original option is `NONE`, otherwise `optb`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(2).and_(pc.NONE)\n    NONE\n    &gt;&gt;&gt; pc.NONE.and_(pc.Some(\"foo\"))\n    NONE\n    &gt;&gt;&gt; pc.Some(2).and_(pc.Some(\"foo\"))\n    Some('foo')\n    &gt;&gt;&gt; pc.NONE.and_(pc.NONE)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.and_then","level":2,"title":"<code>and_then(f, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Calls a function if the option is <code>Some</code>, otherwise returns <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[Concatenate[T, P], Option[R]]</code> <p>The function to call with the <code>Some</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: The result of the function if <code>Some</code>, otherwise <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def sq(x: int) -&gt; Option[int]:\n...     return pc.Some(x * x)\n&gt;&gt;&gt; def nope(x: int) -&gt; Option[int]:\n...     return pc.NONE\n&gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(sq)\nSome(16)\n&gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(nope)\nNONE\n&gt;&gt;&gt; pc.Some(2).and_then(nope).and_then(sq)\nNONE\n&gt;&gt;&gt; pc.NONE.and_then(sq).and_then(sq)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef and_then[**P, R](\n    self,\n    f: Callable[Concatenate[T, P], Option[R]],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Calls a function if the option is `Some`, otherwise returns `None`.\n\n    Args:\n        f (Callable[Concatenate[T, P], Option[R]]): The function to call with the `Some` value.\n        *args (P.args): Additional positional arguments to pass to f.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n    Returns:\n        Option[R]: The result of the function if `Some`, otherwise `None`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def sq(x: int) -&gt; Option[int]:\n    ...     return pc.Some(x * x)\n    &gt;&gt;&gt; def nope(x: int) -&gt; Option[int]:\n    ...     return pc.NONE\n    &gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(sq)\n    Some(16)\n    &gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(nope)\n    NONE\n    &gt;&gt;&gt; pc.Some(2).and_then(nope).and_then(sq)\n    NONE\n    &gt;&gt;&gt; pc.NONE.and_then(sq).and_then(sq)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.expect","level":2,"title":"<code>expect(msg)</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Some</code> value.</p> <p>Raises an exception with a provided message if the value is <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to include in the exception if the result is <code>None</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value.</p> <p>Raises:</p> Type Description <code>OptionUnwrapError</code> <p>If the result is <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"value\").expect(\"fruits are healthy\")\n'value'\n&gt;&gt;&gt; pc.NONE.expect(\"fruits are healthy\")\nTraceback (most recent call last):\n    ...\npyochain._option.OptionUnwrapError: fruits are healthy (called `expect` on a `None`)\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef expect(self, msg: str) -&gt; T:\n    \"\"\"Returns the contained `Some` value.\n\n    Raises an exception with a provided message if the value is `None`.\n\n    Args:\n        msg (str): The message to include in the exception if the result is `None`.\n\n    Returns:\n        T: The contained `Some` value.\n\n    Raises:\n        OptionUnwrapError: If the result is `None`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(\"value\").expect(\"fruits are healthy\")\n    'value'\n    &gt;&gt;&gt; pc.NONE.expect(\"fruits are healthy\")\n    Traceback (most recent call last):\n        ...\n    pyochain._option.OptionUnwrapError: fruits are healthy (called `expect` on a `None`)\n\n    ```\n    \"\"\"\n    if self.is_some():\n        return self.unwrap()\n    msg = f\"{msg} (called `expect` on a `None`)\"\n    raise OptionUnwrapError(msg)\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.filter","level":2,"title":"<code>filter(predicate, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns None if the option is None, otherwise calls predicate with the wrapped value.</p> <p>This function works similar to <code>Iter.filter</code> in the sense that we only keep the value if it matches a predicate.</p> <p>You can imagine the <code>Option[T]</code> being an iterator over one or zero elements.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[Concatenate[T, P], R]</code> <p>The predicate to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to predicate.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to predicate.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: <code>Some[T]</code> if predicate returns true (where T is the wrapped value), <code>NONE</code> if predicate returns false.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n...     return n % 2 == 0\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.NONE.filter(is_even)\nNONE\n&gt;&gt;&gt; pc.Some(3).filter(is_even)\nNONE\n&gt;&gt;&gt; pc.Some(4).filter(is_even)\nSome(4)\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef filter[**P, R](\n    self,\n    predicate: Callable[Concatenate[T, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[T]:\n    \"\"\"Returns None if the option is None, otherwise calls predicate with the wrapped value.\n\n    This function works similar to `Iter.filter` in the sense that we only keep the value if it matches a predicate.\n\n    You can imagine the `Option[T]` being an iterator over one or zero elements.\n\n    Args:\n        predicate (Callable[Concatenate[T, P], R]): The predicate to apply to the contained value.\n        *args (P.args): Additional positional arguments to pass to predicate.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to predicate.\n\n    Returns:\n        Option[T]: `Some[T]` if predicate returns true (where T is the wrapped value), `NONE` if predicate returns false.\n\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n    ...     return n % 2 == 0\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.NONE.filter(is_even)\n    NONE\n    &gt;&gt;&gt; pc.Some(3).filter(is_even)\n    NONE\n    &gt;&gt;&gt; pc.Some(4).filter(is_even)\n    Some(4)\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Option</code>.</p> <p>Converts an <code>Option[Option[U]]</code> into an <code>Option[U]</code> by removing one level of nesting.</p> <p>Equivalent to <code>Option.and_then(lambda x: x)</code>.</p> <p>Returns:</p> Type Description <code>Option[U]</code> <p>Option[U]: The flattened option.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\nSome(42)\n&gt;&gt;&gt; pc.Some(pc.NONE).flatten()\nNONE\n&gt;&gt;&gt; pc.NONE.flatten()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>def flatten[U](self: Option[Option[U]]) -&gt; Option[U]:\n    \"\"\"Flattens a nested `Option`.\n\n    Converts an `Option[Option[U]]` into an `Option[U]` by removing one level of nesting.\n\n    Equivalent to `Option.and_then(lambda x: x)`.\n\n    Returns:\n        Option[U]: The flattened option.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\n    Some(42)\n    &gt;&gt;&gt; pc.Some(pc.NONE).flatten()\n    NONE\n    &gt;&gt;&gt; pc.NONE.flatten()\n    NONE\n\n    ```\n    \"\"\"\n    return self.and_then(lambda x: x)\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.if_some","level":2,"title":"<code>if_some(value)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on the truthiness of a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the value is truthy, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_some(42)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_some(0)\nNONE\n&gt;&gt;&gt; pc.Option.if_some(\"hello\")\nSome('hello')\n&gt;&gt;&gt; pc.Option.if_some(\"\")\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@staticmethod\ndef if_some[V](value: V) -&gt; Option[V]:\n    \"\"\"Creates an `Option[V]` based on the truthiness of a value.\n\n    Args:\n        value (V): The value to evaluate.\n\n    Returns:\n        Option[V]: `Some(value)` if the value is truthy, otherwise `NONE`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Option.if_some(42)\n    Some(42)\n    &gt;&gt;&gt; pc.Option.if_some(0)\n    NONE\n    &gt;&gt;&gt; pc.Option.if_some(\"hello\")\n    Some('hello')\n    &gt;&gt;&gt; pc.Option.if_some(\"\")\n    NONE\n\n    ```\n    \"\"\"\n    return cast(Option[V], Some(value) if value else NONE)\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.if_true","level":2,"title":"<code>if_true(value, *, predicate)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on a predicate condition.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to wrap in <code>Some</code> if the condition is <code>True</code>.</p> required <code>predicate</code> <code>Callable[[], bool]</code> <p>The condition to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the condition is <code>True</code>, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 4)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 5)\nNONE\n&gt;&gt;&gt; # Evaluate on __bool__ of a collection (will call __len__ under the hood)\n&gt;&gt;&gt; data = [1, 2, 3]\n&gt;&gt;&gt; pc.Option.if_true(data, predicate=lambda: data)\nSome([1, 2, 3])\n&gt;&gt;&gt; empty_data = []\n&gt;&gt;&gt; pc.Option.if_true(empty_data, predicate=lambda: empty_data)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@staticmethod\ndef if_true[V](value: V, *, predicate: Callable[[], bool]) -&gt; Option[V]:\n    \"\"\"Creates an `Option[V]` based on a **predicate** condition.\n\n    Args:\n        value (V): The value to wrap in `Some` if the condition is `True`.\n        predicate (Callable[[], bool]): The condition to evaluate.\n\n    Returns:\n        Option[V]: `Some(value)` if the condition is `True`, otherwise `NONE`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 4)\n    Some(42)\n    &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 5)\n    NONE\n    &gt;&gt;&gt; # Evaluate on __bool__ of a collection (will call __len__ under the hood)\n    &gt;&gt;&gt; data = [1, 2, 3]\n    &gt;&gt;&gt; pc.Option.if_true(data, predicate=lambda: data)\n    Some([1, 2, 3])\n    &gt;&gt;&gt; empty_data = []\n    &gt;&gt;&gt; pc.Option.if_true(empty_data, predicate=lambda: empty_data)\n    NONE\n\n    ```\n    \"\"\"\n    return cast(Option[V], Some(value) if predicate() else NONE)\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.inspect","level":2,"title":"<code>inspect(f, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Applies a function to the contained <code>Some</code> value, returning the original <code>Option</code>.</p> <p>This allows side effects (logging, debugging, metrics, etc.) on the wrapped value without changing it.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[Concatenate[T, P], object]</code> <p>Function to apply to the <code>Some</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The original option, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; seen: list[int] = []\n&gt;&gt;&gt; pc.Some(2).inspect(lambda x: seen.append(x))\nSome(2)\n&gt;&gt;&gt; seen\n[2]\n&gt;&gt;&gt; pc.NONE.inspect(lambda x: seen.append(x))\nNONE\n&gt;&gt;&gt; seen\n[2]\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef inspect[**P](\n    self, f: Callable[Concatenate[T, P], object], *args: P.args, **kwargs: P.kwargs\n) -&gt; Option[T]:\n    \"\"\"Applies a function to the contained `Some` value, returning the original `Option`.\n\n    This allows side effects (logging, debugging, metrics, etc.) on the wrapped value without changing it.\n\n    Args:\n        f (Callable[Concatenate[T, P], object]): Function to apply to the `Some` value.\n        *args (P.args): Additional positional arguments to pass to f.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n    Returns:\n        Option[T]: The original option, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; seen: list[int] = []\n    &gt;&gt;&gt; pc.Some(2).inspect(lambda x: seen.append(x))\n    Some(2)\n    &gt;&gt;&gt; seen\n    [2]\n    &gt;&gt;&gt; pc.NONE.inspect(lambda x: seen.append(x))\n    NONE\n    &gt;&gt;&gt; seen\n    [2]\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.is_none","level":2,"title":"<code>is_none()</code>  <code>abstractmethod</code>","text":"<p>Returns <code>True</code> if the option is a <code>None</code> value.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is a <code>_None</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: Option[int] = pc.Some(2)\n&gt;&gt;&gt; x.is_none()\nFalse\n&gt;&gt;&gt; y: Option[int] = pc.NONE\n&gt;&gt;&gt; y.is_none()\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef is_none(self) -&gt; bool:\n    \"\"\"Returns `True` if the option is a `None` value.\n\n    Returns:\n        bool: `True` if the option is a `_None` variant, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; x: Option[int] = pc.Some(2)\n    &gt;&gt;&gt; x.is_none()\n    False\n    &gt;&gt;&gt; y: Option[int] = pc.NONE\n    &gt;&gt;&gt; y.is_none()\n    True\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.is_none_or","level":2,"title":"<code>is_none_or(func, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns true if the option is a None or the value inside of it matches a predicate.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[T, P], bool]</code> <p>The predicate to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is <code>None</code> or the predicate returns <code>True</code> for the contained value, <code>False</code> otherwise.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).is_none_or(lambda x: x &gt; 1)\nTrue\n&gt;&gt;&gt; pc.Some(0).is_none_or(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; pc.NONE.is_none_or(lambda x: x &gt; 1)\nTrue\n&gt;&gt;&gt; pc.Some(\"hello\").is_none_or(lambda x: len(x) &gt; 1)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef is_none_or[**P](\n    self, func: Callable[Concatenate[T, P], bool], *args: P.args, **kwargs: P.kwargs\n) -&gt; bool:\n    \"\"\"Returns true if the option is a None or the value inside of it matches a predicate.\n\n    Args:\n        func (Callable[Concatenate[T, P], bool]): The predicate to apply to the contained value.\n        *args (P.args): Additional positional arguments to pass to func.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to func.\n\n    Returns:\n        bool: `True` if the option is `None` or the predicate returns `True` for the contained value, `False` otherwise.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(2).is_none_or(lambda x: x &gt; 1)\n    True\n    &gt;&gt;&gt; pc.Some(0).is_none_or(lambda x: x &gt; 1)\n    False\n    &gt;&gt;&gt; pc.NONE.is_none_or(lambda x: x &gt; 1)\n    True\n    &gt;&gt;&gt; pc.Some(\"hello\").is_none_or(lambda x: len(x) &gt; 1)\n    True\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.is_some","level":2,"title":"<code>is_some()</code>  <code>abstractmethod</code>","text":"<p>Returns <code>True</code> if the option is a <code>Some</code> value.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is a <code>Some</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: Option[int] = pc.Some(2)\n&gt;&gt;&gt; x.is_some()\nTrue\n&gt;&gt;&gt; y: Option[int] = pc.NONE\n&gt;&gt;&gt; y.is_some()\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef is_some(self) -&gt; bool:\n    \"\"\"Returns `True` if the option is a `Some` value.\n\n    Returns:\n        bool: `True` if the option is a `Some` variant, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; x: Option[int] = pc.Some(2)\n    &gt;&gt;&gt; x.is_some()\n    True\n    &gt;&gt;&gt; y: Option[int] = pc.NONE\n    &gt;&gt;&gt; y.is_some()\n    False\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.is_some_and","level":2,"title":"<code>is_some_and(predicate, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns true if the option is a Some and the value inside of it matches a predicate.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[Concatenate[T, P], bool]</code> <p>The predicate to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to predicate.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to predicate.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is <code>Some</code> and the predicate returns <code>True</code> for the contained value, <code>False</code> otherwise.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x = pc.Some(2)\n&gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\nTrue\n\n&gt;&gt;&gt; x = pc.Some(0)\n&gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; x = pc.NONE\n&gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; x = pc.Some(\"hello\")\n&gt;&gt;&gt; x.is_some_and(lambda x: len(x) &gt; 1)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef is_some_and[**P](\n    self,\n    predicate: Callable[Concatenate[T, P], bool],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; bool:\n    \"\"\"Returns true if the option is a Some and the value inside of it matches a predicate.\n\n    Args:\n        predicate (Callable[Concatenate[T, P], bool]): The predicate to apply to the contained value.\n        *args (P.args): Additional positional arguments to pass to predicate.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to predicate.\n\n    Returns:\n        bool: `True` if the option is `Some` and the predicate returns `True` for the contained value, `False` otherwise.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; x = pc.Some(2)\n    &gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\n    True\n\n    &gt;&gt;&gt; x = pc.Some(0)\n    &gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\n    False\n    &gt;&gt;&gt; x = pc.NONE\n    &gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\n    False\n    &gt;&gt;&gt; x = pc.Some(\"hello\")\n    &gt;&gt;&gt; x.is_some_and(lambda x: len(x) &gt; 1)\n    True\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.iter","level":2,"title":"<code>iter()</code>  <code>abstractmethod</code>","text":"<p>Creates an <code>Iter</code> over the optional value.</p> <ul> <li>If the option is <code>Some(value)</code>, the iterator yields <code>value</code>.</li> <li>If the option is <code>NONE</code>, the iterator yields nothing.</li> </ul> <p>Equivalent to <code>Iter((self,))</code>.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterator over the optional value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(42).iter().next()\nSome(42)\n&gt;&gt;&gt; pc.NONE.iter().next()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef iter(self) -&gt; Iter[T]:\n    \"\"\"Creates an `Iter` over the optional value.\n\n    - If the option is `Some(value)`, the iterator yields `value`.\n    - If the option is `NONE`, the iterator yields nothing.\n\n    Equivalent to `Iter((self,))`.\n\n    Returns:\n        Iter[T]: An iterator over the optional value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(42).iter().next()\n    Some(42)\n    &gt;&gt;&gt; pc.NONE.iter().next()\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.map","level":2,"title":"<code>map(f, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Maps an <code>Option[T]</code> to <code>Option[U]</code>.</p> <p>Done by applying a function to a contained <code>Some</code> value, leaving a <code>None</code> value untouched.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[Concatenate[T, P], R]</code> <p>The function to apply to the <code>Some</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: A new <code>Option</code> with the mapped value if <code>Some</code>, otherwise <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"Hello, World!\").map(len)\nSome(13)\n&gt;&gt;&gt; pc.NONE.map(len)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef map[**P, R](\n    self, f: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs\n) -&gt; Option[R]:\n    \"\"\"Maps an `Option[T]` to `Option[U]`.\n\n    Done by applying a function to a contained `Some` value,\n    leaving a `None` value untouched.\n\n    Args:\n        f (Callable[Concatenate[T, P], R]): The function to apply to the `Some` value.\n        *args (P.args): Additional positional arguments to pass to f.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n    Returns:\n        Option[R]: A new `Option` with the mapped value if `Some`, otherwise `None`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(\"Hello, World!\").map(len)\n    Some(13)\n    &gt;&gt;&gt; pc.NONE.map(len)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.map_or","level":2,"title":"<code>map_or(default, f, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns the result of applying a function to the contained value if Some, otherwise returns the default value.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>R</code> <p>The default value to return if NONE.</p> required <code>f</code> <code>Callable[Concatenate[T, P], R]</code> <p>The function to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The result of f(self.unwrap()) if Some, otherwise default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).map_or(0, lambda x: x * 10)\n20\n&gt;&gt;&gt; pc.NONE.map_or(0, lambda x: x * 10)\n0\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef map_or[**P, R](\n    self,\n    default: R,\n    f: Callable[Concatenate[T, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Returns the result of applying a function to the contained value if Some, otherwise returns the default value.\n\n    Args:\n        default (R): The default value to return if NONE.\n        f (Callable[Concatenate[T, P], R]): The function to apply to the contained value.\n        *args (P.args): Additional positional arguments to pass to f.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n    Returns:\n        R: The result of f(self.unwrap()) if Some, otherwise default.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(2).map_or(0, lambda x: x * 10)\n    20\n    &gt;&gt;&gt; pc.NONE.map_or(0, lambda x: x * 10)\n    0\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.map_or_else","level":2,"title":"<code>map_or_else(default, f)</code>  <code>abstractmethod</code>","text":"<p>Returns the result of applying a function to the contained value if Some, otherwise computes a default value.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Callable[[], R]</code> <p>A function returning the default value if NONE.</p> required <code>f</code> <code>Callable[[T], R]</code> <p>The function to apply to the contained value.</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The result of f(self.unwrap()) if Some, otherwise default().</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).map_or_else(lambda: 0, lambda x: x * 10)\n20\n&gt;&gt;&gt; pc.NONE.map_or_else(lambda: 0, lambda x: x * 10)\n0\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef map_or_else[**P, R](self, default: Callable[[], R], f: Callable[[T], R]) -&gt; R:\n    \"\"\"Returns the result of applying a function to the contained value if Some, otherwise computes a default value.\n\n    Args:\n        default (Callable[[], R]): A function returning the default value if NONE.\n        f (Callable[[T], R]): The function to apply to the contained value.\n\n    Returns:\n        R: The result of f(self.unwrap()) if Some, otherwise default().\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(2).map_or_else(lambda: 0, lambda x: x * 10)\n    20\n    &gt;&gt;&gt; pc.NONE.map_or_else(lambda: 0, lambda x: x * 10)\n    0\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.ok_or","level":2,"title":"<code>ok_or(err)</code>  <code>abstractmethod</code>","text":"<p>Converts the option to a <code>Result</code>.</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to use if the option is <code>NONE</code>.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: <code>Ok(v)</code> if <code>Some(v)</code>, otherwise <code>Err(err)</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(1).ok_or('fail')\nOk(1)\n&gt;&gt;&gt; pc.NONE.ok_or('fail')\nErr('fail')\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef ok_or[E](self, err: E) -&gt; Result[T, E]:\n    \"\"\"Converts the option to a `Result`.\n\n    Args:\n        err (E): The error value to use if the option is `NONE`.\n\n    Returns:\n        Result[T, E]: `Ok(v)` if `Some(v)`, otherwise `Err(err)`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(1).ok_or('fail')\n    Ok(1)\n    &gt;&gt;&gt; pc.NONE.ok_or('fail')\n    Err('fail')\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.ok_or_else","level":2,"title":"<code>ok_or_else(err)</code>  <code>abstractmethod</code>","text":"<p>Converts the option to a Result.</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>Callable[[], E]</code> <p>A function returning the error value if the option is NONE.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: Ok(v) if Some(v), otherwise Err(err()).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(1).ok_or_else(lambda: 'fail')\nOk(1)\n&gt;&gt;&gt; pc.NONE.ok_or_else(lambda: 'fail')\nErr('fail')\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef ok_or_else[E](self, err: Callable[[], E]) -&gt; Result[T, E]:\n    \"\"\"Converts the option to a Result.\n\n    Args:\n        err (Callable[[], E]): A function returning the error value if the option is NONE.\n\n    Returns:\n        Result[T, E]: Ok(v) if Some(v), otherwise Err(err()).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(1).ok_or_else(lambda: 'fail')\n    Ok(1)\n    &gt;&gt;&gt; pc.NONE.ok_or_else(lambda: 'fail')\n    Err('fail')\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.or_","level":2,"title":"<code>or_(optb)</code>  <code>abstractmethod</code>","text":"<p>Returns the option if it contains a value, otherwise returns optb.</p> <p>Parameters:</p> Name Type Description Default <code>optb</code> <code>Option[T]</code> <p>The option to return if the original option is <code>NONE</code>.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The original option if it is <code>Some</code>, otherwise <code>optb</code>.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).or_(pc.NONE)\nSome(2)\n&gt;&gt;&gt; pc.NONE.or_(pc.Some(100))\nSome(100)\n&gt;&gt;&gt; pc.Some(2).or_(pc.Some(100))\nSome(2)\n&gt;&gt;&gt; pc.NONE.or_(pc.NONE)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef or_(self, optb: Option[T]) -&gt; Option[T]:\n    \"\"\"Returns the option if it contains a value, otherwise returns optb.\n\n    Args:\n        optb (Option[T]): The option to return if the original option is `NONE`.\n\n    Returns:\n        Option[T]: The original option if it is `Some`, otherwise `optb`.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(2).or_(pc.NONE)\n    Some(2)\n    &gt;&gt;&gt; pc.NONE.or_(pc.Some(100))\n    Some(100)\n    &gt;&gt;&gt; pc.Some(2).or_(pc.Some(100))\n    Some(2)\n    &gt;&gt;&gt; pc.NONE.or_(pc.NONE)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.or_else","level":2,"title":"<code>or_else(f)</code>  <code>abstractmethod</code>","text":"<p>Returns the <code>Option[T]</code> if it contains a value, otherwise calls a function and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], Option[T]]</code> <p>The function to call if the option is <code>None</code>.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The original <code>Option</code> if it is <code>Some</code>, otherwise the result of the function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def nobody() -&gt; Option[str]:\n...     return pc.NONE\n&gt;&gt;&gt; def vikings() -&gt; Option[str]:\n...     return pc.Some(\"vikings\")\n&gt;&gt;&gt; pc.Some(\"barbarians\").or_else(vikings)\nSome('barbarians')\n&gt;&gt;&gt; pc.NONE.or_else(vikings)\nSome('vikings')\n&gt;&gt;&gt; pc.NONE.or_else(nobody)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef or_else(self, f: Callable[[], Option[T]]) -&gt; Option[T]:\n    \"\"\"Returns the `Option[T]` if it contains a value, otherwise calls a function and returns the result.\n\n    Args:\n        f (Callable[[], Option[T]]): The function to call if the option is `None`.\n\n    Returns:\n        Option[T]: The original `Option` if it is `Some`, otherwise the result of the function.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def nobody() -&gt; Option[str]:\n    ...     return pc.NONE\n    &gt;&gt;&gt; def vikings() -&gt; Option[str]:\n    ...     return pc.Some(\"vikings\")\n    &gt;&gt;&gt; pc.Some(\"barbarians\").or_else(vikings)\n    Some('barbarians')\n    &gt;&gt;&gt; pc.NONE.or_else(vikings)\n    Some('vikings')\n    &gt;&gt;&gt; pc.NONE.or_else(nobody)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.reduce","level":2,"title":"<code>reduce(other, func)</code>  <code>abstractmethod</code>","text":"<p>Reduces two options into one, using the provided function if both are Some.</p> <p>If self is <code>Some(s)</code> and other is <code>Some(o)</code>, this method returns <code>Some(func(s, o))</code>.</p> <p>Otherwise, if only one of self and other is <code>Some</code>, that value is returned.</p> <p>If both self and other are <code>NONE</code>, <code>NONE</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[T]</code> <p>The second option.</p> required <code>func</code> <code>Callable[[T, T], T]</code> <p>The function to apply to the unwrapped values.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The resulting option after reduction.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; s12 = pc.Some(12)\n&gt;&gt;&gt; s17 = pc.Some(17)\n&gt;&gt;&gt;\n&gt;&gt;&gt; def add(a: int, b: int) -&gt; int:\n...     return a + b\n&gt;&gt;&gt;\n&gt;&gt;&gt; s12.reduce(s17, add)\nSome(29)\n&gt;&gt;&gt; s12.reduce(pc.NONE, add)\nSome(12)\n&gt;&gt;&gt; pc.NONE.reduce(s17, add)\nSome(17)\n&gt;&gt;&gt; pc.NONE.reduce(pc.NONE, add)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef reduce[U](self, other: Option[T], func: Callable[[T, T], T]) -&gt; Option[T]:\n    \"\"\"Reduces two options into one, using the provided function if both are Some.\n\n    If **self** is `Some(s)` and **other** is `Some(o)`, this method returns `Some(func(s, o))`.\n\n    Otherwise, if only one of **self** and **other** is `Some`, that value is returned.\n\n    If both **self** and **other** are `NONE`, `NONE` is returned.\n\n    Args:\n        other (Option[T]): The second option.\n        func (Callable[[T, T], T]): The function to apply to the unwrapped values.\n\n    Returns:\n        Option[T]: The resulting option after reduction.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; s12 = pc.Some(12)\n    &gt;&gt;&gt; s17 = pc.Some(17)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def add(a: int, b: int) -&gt; int:\n    ...     return a + b\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; s12.reduce(s17, add)\n    Some(29)\n    &gt;&gt;&gt; s12.reduce(pc.NONE, add)\n    Some(12)\n    &gt;&gt;&gt; pc.NONE.reduce(s17, add)\n    Some(17)\n    &gt;&gt;&gt; pc.NONE.reduce(pc.NONE, add)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.transpose","level":2,"title":"<code>transpose()</code>  <code>abstractmethod</code>","text":"<p>Transposes an <code>Option</code> of a <code>Result</code> into a <code>Result</code> of an <code>Option</code>.</p> <p><code>Some(Ok[T])</code> is mapped to <code>Ok(Some[T])</code>, <code>Some(Err[E])</code> is mapped to <code>Err[E]</code>, and <code>NONE</code> will be mapped to <code>Ok(NONE)</code>.</p> <p>Returns:</p> Type Description <code>Result[Option[T], E]</code> <p>Result[Option[T], E]: The transposed result.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(pc.Ok(5)).transpose()\nOk(Some(5))\n&gt;&gt;&gt; pc.NONE.transpose()\nOk(NONE)\n&gt;&gt;&gt; pc.Some(pc.Err(\"error\")).transpose()\nErr('error')\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef transpose[E](self: Option[Result[T, E]]) -&gt; Result[Option[T], E]:\n    \"\"\"Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n\n    `Some(Ok[T])` is mapped to `Ok(Some[T])`, `Some(Err[E])` is mapped to `Err[E]`, and `NONE` will be mapped to `Ok(NONE)`.\n\n    Returns:\n        Result[Option[T], E]: The transposed result.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(pc.Ok(5)).transpose()\n    Ok(Some(5))\n    &gt;&gt;&gt; pc.NONE.transpose()\n    Ok(NONE)\n    &gt;&gt;&gt; pc.Some(pc.Err(\"error\")).transpose()\n    Err('error')\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.unwrap","level":2,"title":"<code>unwrap()</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Some</code> value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value.</p> <p>Raises:</p> Type Description <code>OptionUnwrapError</code> <p>If the option is <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"car\").unwrap()\n'car'\n</code></pre> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.NONE.unwrap()\nTraceback (most recent call last):\n    ...\npyochain._option.OptionUnwrapError: called `unwrap` on a `None`\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef unwrap(self) -&gt; T:\n    \"\"\"Returns the contained `Some` value.\n\n    Returns:\n        T: The contained `Some` value.\n\n    Raises:\n        OptionUnwrapError: If the option is `None`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(\"car\").unwrap()\n    'car'\n\n    ```\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.NONE.unwrap()\n    Traceback (most recent call last):\n        ...\n    pyochain._option.OptionUnwrapError: called `unwrap` on a `None`\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.unwrap_or","level":2,"title":"<code>unwrap_or(default)</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Some</code> value or a provided default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The value to return if the result is <code>None</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value or the provided default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"car\").unwrap_or(\"bike\")\n'car'\n&gt;&gt;&gt; pc.NONE.unwrap_or(\"bike\")\n'bike'\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef unwrap_or(self, default: T) -&gt; T:\n    \"\"\"Returns the contained `Some` value or a provided default.\n\n    Args:\n        default (T): The value to return if the result is `None`.\n\n    Returns:\n        T: The contained `Some` value or the provided default.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(\"car\").unwrap_or(\"bike\")\n    'car'\n    &gt;&gt;&gt; pc.NONE.unwrap_or(\"bike\")\n    'bike'\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.unwrap_or_else","level":2,"title":"<code>unwrap_or_else(f)</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Some</code> value or computes it from a function.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], T]</code> <p>A function that returns a default value if the result is <code>None</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value or the result of the function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; k = 10\n&gt;&gt;&gt; pc.Some(4).unwrap_or_else(lambda: 2 * k)\n4\n&gt;&gt;&gt; pc.NONE.unwrap_or_else(lambda: 2 * k)\n20\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef unwrap_or_else(self, f: Callable[[], T]) -&gt; T:\n    \"\"\"Returns the contained `Some` value or computes it from a function.\n\n    Args:\n        f (Callable[[], T]): A function that returns a default value if the result is `None`.\n\n    Returns:\n        T: The contained `Some` value or the result of the function.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; k = 10\n    &gt;&gt;&gt; pc.Some(4).unwrap_or_else(lambda: 2 * k)\n    4\n    &gt;&gt;&gt; pc.NONE.unwrap_or_else(lambda: 2 * k)\n    20\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.unzip","level":2,"title":"<code>unzip()</code>  <code>abstractmethod</code>","text":"<p>Unzips an <code>Option</code> of a tuple into a tuple of <code>Option</code>s.</p> <p>If the option is <code>Some((a, b))</code>, this method returns <code>(Some(a), Some(b))</code>. If the option is <code>NONE</code>, it returns <code>(NONE, NONE)</code>.</p> <p>Returns:</p> Type Description <code>tuple[Option[T], Option[U]]</code> <p>tuple[Option[T], Option[U]]: A tuple containing two options.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some((1, 'a')).unzip()\n(Some(1), Some('a'))\n&gt;&gt;&gt; pc.NONE.unzip()\n(NONE, NONE)\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef unzip[U](self: Option[tuple[T, U]]) -&gt; tuple[Option[T], Option[U]]:\n    \"\"\"Unzips an `Option` of a tuple into a tuple of `Option`s.\n\n    If the option is `Some((a, b))`, this method returns `(Some(a), Some(b))`.\n    If the option is `NONE`, it returns `(NONE, NONE)`.\n\n    Returns:\n        tuple[Option[T], Option[U]]: A tuple containing two options.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some((1, 'a')).unzip()\n    (Some(1), Some('a'))\n    &gt;&gt;&gt; pc.NONE.unzip()\n    (NONE, NONE)\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.xor","level":2,"title":"<code>xor(optb)</code>  <code>abstractmethod</code>","text":"<p>Returns <code>Some</code> if exactly one of self, optb is <code>Some</code>, otherwise returns <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>optb</code> <code>Option[T]</code> <p>The other option to compare with.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: <code>Some</code> value if exactly one option is <code>Some</code>, otherwise <code>NONE</code>.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).xor(pc.NONE)\nSome(2)\n&gt;&gt;&gt; pc.NONE.xor(pc.Some(2))\nSome(2)\n&gt;&gt;&gt; pc.Some(2).xor(pc.Some(2))\nNONE\n&gt;&gt;&gt; pc.NONE.xor(pc.NONE)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef xor(self, optb: Option[T]) -&gt; Option[T]:\n    \"\"\"Returns `Some` if exactly one of **self**, optb is `Some`, otherwise returns `NONE`.\n\n    Args:\n        optb (Option[T]): The other option to compare with.\n\n    Returns:\n        Option[T]: `Some` value if exactly one option is `Some`, otherwise `NONE`.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(2).xor(pc.NONE)\n    Some(2)\n    &gt;&gt;&gt; pc.NONE.xor(pc.Some(2))\n    Some(2)\n    &gt;&gt;&gt; pc.Some(2).xor(pc.Some(2))\n    NONE\n    &gt;&gt;&gt; pc.NONE.xor(pc.NONE)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.zip","level":2,"title":"<code>zip(other)</code>  <code>abstractmethod</code>","text":"<p>Returns an <code>Option[tuple[T, U]]</code> containing a tuple of the values if both options are <code>Some</code>, otherwise returns <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[U]</code> <p>The other option to zip with.</p> required <p>Returns:</p> Type Description <code>Option[tuple[T, U]]</code> <p>Option[tuple[T, U]]: Some((self, other)) if both are Some, otherwise NONE.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(1).zip(pc.Some('a'))\nSome((1, 'a'))\n&gt;&gt;&gt; pc.Some(1).zip(pc.NONE)\nNONE\n&gt;&gt;&gt; pc.NONE.zip(pc.Some('a'))\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef zip[U](self, other: Option[U]) -&gt; Option[tuple[T, U]]:\n    \"\"\"Returns an `Option[tuple[T, U]]` containing a tuple of the values if both options are `Some`, otherwise returns `NONE`.\n\n    Args:\n        other (Option[U]): The other option to zip with.\n\n    Returns:\n        Option[tuple[T, U]]: Some((self, other)) if both are Some, otherwise NONE.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(1).zip(pc.Some('a'))\n    Some((1, 'a'))\n    &gt;&gt;&gt; pc.Some(1).zip(pc.NONE)\n    NONE\n    &gt;&gt;&gt; pc.NONE.zip(pc.Some('a'))\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain._option.Option.zip_with","level":2,"title":"<code>zip_with(other, f)</code>  <code>abstractmethod</code>","text":"<p>Zips <code>self</code> and another <code>Option</code> with function <code>f</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and other is <code>Some(o)</code>, this method returns <code>Some(f(s, o))</code>.</p> <p>Otherwise, <code>NONE</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[U]</code> <p>The second option.</p> required <code>f</code> <code>Callable[[T, U], R]</code> <p>The function to apply to the unwrapped values.</p> required <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: The resulting option after applying the function.</p> <p>Examples: <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; @dataclass\n... class Point:\n...     x: float\n...     y: float\n&gt;&gt;&gt;\n&gt;&gt;&gt; x = pc.Some(17.5)\n&gt;&gt;&gt; y = pc.Some(42.7)\n&gt;&gt;&gt; x.zip_with(y, Point)\nSome(Point(x=17.5, y=42.7))\n&gt;&gt;&gt; x.zip_with(pc.NONE, Point)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@abstractmethod\ndef zip_with[U, R](self, other: Option[U], f: Callable[[T, U], R]) -&gt; Option[R]:\n    \"\"\"Zips `self` and another `Option` with function `f`.\n\n    If `self` is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`.\n\n    Otherwise, `NONE` is returned.\n\n    Args:\n        other (Option[U]): The second option.\n        f (Callable[[T, U], R]): The function to apply to the unwrapped values.\n\n    Returns:\n        Option[R]: The resulting option after applying the function.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; @dataclass\n    ... class Point:\n    ...     x: float\n    ...     y: float\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; x = pc.Some(17.5)\n    &gt;&gt;&gt; y = pc.Some(42.7)\n    &gt;&gt;&gt; x.zip_with(y, Point)\n    Some(Point(x=17.5, y=42.7))\n    &gt;&gt;&gt; x.zip_with(pc.NONE, Point)\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/pipeable/","level":1,"title":"Pipeable","text":"<p>Mixin class providing pipeable methods for fluent chaining.</p> Source code in <code>src/pyochain/traits.py</code> <pre><code>class Pipeable:\n    \"\"\"Mixin class providing pipeable methods for fluent chaining.\"\"\"\n\n    def into[**P, R](\n        self,\n        func: Callable[Concatenate[Self, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; R:\n        \"\"\"Convert `Self` to `R`.\n\n        This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n        Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n        Args:\n            func (Callable[Concatenate[Self, P], R]): Function for conversion.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            R: The converted value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; import hashlib\n        &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n        ...     return hashlib.sha256(bytes(data)).hexdigest()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n        '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n        ```\n        \"\"\"\n        return func(self, *args, **kwargs)\n\n    def inspect[**P](\n        self,\n        func: Callable[Concatenate[Self, P], object],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Self:\n        \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n        This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n        Args:\n            func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            Self: The instance itself, unchanged.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n        Seq(1, 2, 3, 4)\n        4\n\n        ```\n        \"\"\"\n        func(self, *args, **kwargs)\n        return self\n</code></pre>","path":["API Reference","Traits & Mixins","Pipeable"],"tags":[]},{"location":"reference/pipeable/#pyochain.traits.Pipeable.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["API Reference","Traits & Mixins","Pipeable"],"tags":[]},{"location":"reference/pipeable/#pyochain.traits.Pipeable.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Traits & Mixins","Pipeable"],"tags":[]},{"location":"reference/result/","level":1,"title":"Result","text":"<p>               Bases: <code>Pipeable</code>, <code>ABC</code></p> <p><code>Result[T, E]</code> is the type used for returning and propagating errors.</p> <p>It is a class that can represent two variants, <code>Ok[T]</code>, representing success and containing a value, and <code>Err[E]</code>, representing error and containing an error value.</p> <p>Functions return <code>Result</code> whenever errors are expected and recoverable.</p> <p>For example, I/O or web requests can fail for many reasons, and using <code>Result</code> forces the caller to handle the possibility of failure.</p> <p>This is directly inspired by Rust's <code>Result</code> type, and provides similar functionality for error handling in Python.</p> Source code in <code>src/pyochain/_result.py</code> <pre><code>class Result[T, E](Pipeable, ABC):\n    \"\"\"`Result[T, E]` is the type used for returning and propagating errors.\n\n    It is a class that can represent two variants, `Ok[T]`, representing success and containing a value, and `Err[E]`, representing error and containing an error value.\n\n    Functions return `Result` whenever errors are expected and recoverable.\n\n    For example, I/O or web requests can fail for many reasons, and using `Result` forces the caller to handle the possibility of failure.\n\n    This is directly inspired by Rust's `Result` type, and provides similar functionality for error handling in Python.\n\n    \"\"\"\n\n    def flatten(self: Result[Result[T, E], E]) -&gt; Result[T, E]:\n        \"\"\"Flattens a nested `Result`.\n\n        Converts from `Result[Result[T, E], E]` to `Result[T, E]`.\n\n        Equivalent to calling `Result.and_then(lambda x: x)`, but more convenient when there's no need to process the inner `Ok` value.\n\n        Returns:\n            Result[T, E]: The flattened result.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n        &gt;&gt;&gt; nested_ok.flatten()\n        Ok(2)\n        &gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n        &gt;&gt;&gt; nested_err.flatten()\n        Err('inner error')\n\n        ```\n        \"\"\"\n        return self.and_then(lambda x: x)\n\n    def iter(self) -&gt; Iter[T]:\n        \"\"\"Returns a `Iter[T]` over the possibly contained value.\n\n        The iterator yields one value if the result is `Ok`, otherwise none.\n\n        Returns:\n            Iter[T]: An iterator over the `Ok` value, or empty if `Err`.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(7).iter().next()\n        Some(7)\n        &gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\n        NONE\n\n        ```\n        \"\"\"\n        return self.ok().iter()\n\n    # abstract methods ---------------------------------------------------------------\n\n    @abstractmethod\n    def is_ok(self) -&gt; bool:\n        \"\"\"Returns `True` if the result is `Ok`.\n\n        Returns:\n            bool: `True` if the result is an `Ok` variant, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n        &gt;&gt;&gt; x.is_ok()\n        True\n        &gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n        &gt;&gt;&gt; y.is_ok()\n        False\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_err(self) -&gt; bool:\n        \"\"\"Returns `True` if the result is `Err`.\n\n        Returns:\n            bool: `True` if the result is an `Err` variant, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n        &gt;&gt;&gt; x.is_err()\n        False\n        &gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n        &gt;&gt;&gt; y.is_err()\n        True\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def unwrap(self) -&gt; T:\n        \"\"\"Returns the contained `Ok` value.\n\n        Returns:\n            T: The contained `Ok` value.\n\n        Raises:\n            ResultUnwrapError: If the result is `Err`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).unwrap()\n        2\n\n        ```\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap()\n        Traceback (most recent call last):\n            ...\n        pyochain._result.ResultUnwrapError: called `unwrap` on Err: 'emergency failure'\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def unwrap_err(self) -&gt; E:\n        \"\"\"Returns the contained `Err` value.\n\n        Returns:\n            E: The contained `Err` value.\n\n        Raises:\n            ResultUnwrapError: If the result is `Ok`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap_err()\n        'emergency failure'\n\n        ```\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).unwrap_err()\n        Traceback (most recent call last):\n            ...\n        pyochain._result.ResultUnwrapError: called `unwrap_err` on Ok\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def map_or_else[U](self, ok: Callable[[T], U], err: Callable[[E], U]) -&gt; U:\n        \"\"\"Maps a `Result[T, E]` to `U`.\n\n        Done by applying a fallback function to a contained `Err` value,\n        or a default function to a contained `Ok` value.\n\n        Args:\n            ok (Callable[[T], U]): The function to apply to the `Ok` value.\n            err (Callable[[E], U]): The function to apply to the `Err` value.\n\n        Returns:\n            U: The result of applying the appropriate function.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; k = 21\n        &gt;&gt;&gt; pc.Ok(\"foo\").map_or_else(len, lambda e: k * 2)\n        3\n        &gt;&gt;&gt; pc.Err(\"bar\").map_or_else(len, lambda e: k * 2)\n        42\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def expect(self, msg: str) -&gt; T:\n        \"\"\"Returns the contained `Ok` value.\n\n        Raises an exception with a provided message if the value is an `Err`.\n\n        Args:\n            msg (str): The message to include in the exception if the result is `Err`.\n\n        Returns:\n            T: The contained `Ok` value.\n\n        Raises:\n            ResultUnwrapError: If the result is `Err`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).expect(\"No error\")\n        2\n        &gt;&gt;&gt; pc.Err(\"emergency failure\").expect(\"Testing expect\")\n        Traceback (most recent call last):\n            ...\n        pyochain._result.ResultUnwrapError: Testing expect: emergency failure\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def expect_err(self, msg: str) -&gt; E:\n        \"\"\"Returns the contained `Err` value.\n\n        Raises an exception with a provided message if the value is an `Ok`.\n\n        Args:\n            msg (str): The message to include in the exception if the result is `Ok`.\n\n        Returns:\n            E: The contained `Err` value.\n\n        Raises:\n            ResultUnwrapError: If the result is `Ok`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Err(\"emergency failure\").expect_err(\"Testing expect_err\")\n        'emergency failure'\n        &gt;&gt;&gt; pc.Ok(10).expect_err(\"Testing expect_err\")\n        Traceback (most recent call last):\n            ...\n        pyochain._result.ResultUnwrapError: Testing expect_err: expected Err, got Ok(10)\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def unwrap_or(self, default: T) -&gt; T:\n        \"\"\"Returns the contained `Ok` value or a provided default.\n\n        Args:\n            default (T): The value to return if the result is `Err`.\n\n        Returns:\n            T: The contained `Ok` value or the provided default.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).unwrap_or(10)\n        2\n        &gt;&gt;&gt; pc.Err(\"error\").unwrap_or(10)\n        10\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def unwrap_or_else[**P](\n        self, fn: Callable[Concatenate[E, P], T], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; T:\n        \"\"\"Returns the contained `Ok` value or computes it from a function.\n\n        Args:\n            fn (Callable[Concatenate[E, P], T]): A function that takes the `Err` value and returns a default value.\n            *args (P.args): Additional positional arguments to pass to fn.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n        Returns:\n            T: The contained `Ok` value or the result of the function.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).unwrap_or_else(len)\n        2\n        &gt;&gt;&gt; pc.Err(\"foo\").unwrap_or_else(len)\n        3\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def map[**P, R](\n        self, fn: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[R, E]:\n        \"\"\"Maps a `Result[T, E]` to `Result[U, E]`.\n\n        Done by applying a function to a contained `Ok` value,\n        leaving an `Err` value untouched.\n\n        Args:\n            fn (Callable[Concatenate[T, P], R]): The function to apply to the `Ok` value.\n            *args (P.args): Additional positional arguments to pass to fn.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n        Returns:\n            Result[R, E]: A new `Result` with the mapped value if `Ok`, otherwise the original `Err`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).map(lambda x: x * 2)\n        Ok(4)\n        &gt;&gt;&gt; pc.Err(\"error\").map(lambda x: x * 2)\n        Err('error')\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def map_err[**P, R](\n        self, fn: Callable[Concatenate[E, P], R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[T, R]:\n        \"\"\"Maps a `Result[T, E]` to `Result[T, R]`.\n\n        Done by applying a function to a contained `Err` value,\n        leaving an `Ok` value untouched.\n\n        Args:\n            fn (Callable[Concatenate[E, P], R]): The function to apply to the `Err` value.\n            *args (P.args): Additional positional arguments to pass to fn.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n\n        Returns:\n            Result[T, R]: A new `Result` with the mapped error if `Err`, otherwise the original `Ok`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).map_err(len)\n        Ok(2)\n        &gt;&gt;&gt; pc.Err(\"foo\").map_err(len)\n        Err(3)\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def inspect[**P](\n        self, fn: Callable[Concatenate[T, P], object], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[T, E]:\n        \"\"\"Applies a function to the contained `Ok` value, returning the original `Result`.\n\n        This is primarily useful for debugging or logging, allowing side effects to be\n        performed on the `Ok` value without changing the result.\n\n        Args:\n            fn (Callable[Concatenate[T, P], object]): Function to apply to the `Ok` value.\n            *args (P.args): Additional positional arguments to pass to fn.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n        Returns:\n            Result[T, E]: The original result, unchanged.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; seen: list[int] = []\n        &gt;&gt;&gt; pc.Ok(2).inspect(lambda x: seen.append(x))\n        Ok(2)\n        &gt;&gt;&gt; seen\n        [2]\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def inspect_err[**P](\n        self, fn: Callable[Concatenate[E, P], object], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Result[T, E]:\n        \"\"\"Applies a function to the contained `Err` value, returning the original `Result`.\n\n        This mirrors :meth:`inspect` but operates on the error value. It is useful for\n        logging or debugging error paths while keeping the `Result` unchanged.\n\n        Args:\n            fn (Callable[Concatenate[E, P], object]): Function to apply to the `Err` value.\n            *args (P.args): Additional positional arguments to pass to fn.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n        Returns:\n            Result[T, E]: The original result, unchanged.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; seen: list[str] = []\n        &gt;&gt;&gt; pc.Err(\"oops\").inspect_err(lambda e: seen.append(e))\n        Err('oops')\n        &gt;&gt;&gt; seen\n        ['oops']\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def and_[U](self, res: Result[U, E]) -&gt; Result[U, E]:\n        \"\"\"Returns `res` if the result is `Ok`, otherwise returns the `Err` value.\n\n        This is often used for chaining operations that might fail.\n\n        Args:\n            res (Result[U, E]): The result to return if the original result is `Ok`.\n\n        Returns:\n            Result[U, E]: `res` if the original result is `Ok`, otherwise the original `Err`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; x = pc.Ok(2)\n        &gt;&gt;&gt; y = pc.Err(\"late error\")\n        &gt;&gt;&gt; x.and_(y)\n        Err('late error')\n        &gt;&gt;&gt; x = pc.Err(\"early error\")\n        &gt;&gt;&gt; y = pc.Ok(\"foo\")\n        &gt;&gt;&gt; x.and_(y)\n        Err('early error')\n\n        &gt;&gt;&gt; x = pc.Err(\"not a 2\")\n        &gt;&gt;&gt; y = pc.Err(\"late error\")\n        &gt;&gt;&gt; x.and_(y)\n        Err('not a 2')\n\n        &gt;&gt;&gt; x = pc.Ok(2)\n        &gt;&gt;&gt; y = pc.Ok(\"different result type\")\n        &gt;&gt;&gt; x.and_(y)\n        Ok('different result type')\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def and_then[**P, R](\n        self,\n        fn: Callable[Concatenate[T, P], Result[R, E]],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Result[R, E]:\n        \"\"\"Calls a function if the result is `Ok`, otherwise returns the `Err` value.\n\n        This is often used for chaining operations that might fail.\n\n        Args:\n            fn (Callable[Concatenate[T, P], Result[R, E]]): The function to call with the `Ok` value.\n            *args (P.args): Additional positional arguments to pass to fn.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n        Returns:\n            Result[R, E]: The result of the function if `Ok`, otherwise the original `Err`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def to_str(x: int) -&gt; Result[str, str]:\n        ...     return pc.Ok(str(x))\n        &gt;&gt;&gt; pc.Ok(2).and_then(to_str)\n        Ok('2')\n        &gt;&gt;&gt; pc.Err(\"error\").and_then(to_str)\n        Err('error')\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def or_else[**P](\n        self,\n        fn: Callable[Concatenate[E, P], Result[T, E]],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Result[T, E]:\n        \"\"\"Calls a function if the result is `Err`, otherwise returns the `Ok` value.\n\n        This is often used for handling errors by trying an alternative operation.\n\n        Args:\n            fn (Callable[Concatenate[E, P], Result[T, E]]): The function to call with the `Err` value.\n            *args (P.args): Additional positional arguments to pass to fn.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n        Returns:\n            Result[T, E]: The original `Ok` value, or the result of the function if `Err`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def fallback(e: str) -&gt; Result[int, str]:\n        ...     return pc.Ok(len(e))\n        &gt;&gt;&gt; pc.Ok(2).or_else(fallback)\n        Ok(2)\n        &gt;&gt;&gt; pc.Err(\"foo\").or_else(fallback)\n        Ok(3)\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def ok(self) -&gt; Option[T]:\n        \"\"\"Converts from `Result[T, E]` to `Option[T]`.\n\n        `Ok(v)` becomes `Some(v)`, and `Err(e)` becomes `None`.\n\n        Returns:\n            Option[T]: An `Option` containing the `Ok` value, or `None` if the result is `Err`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).ok()\n        Some(2)\n        &gt;&gt;&gt; pc.Err(\"error\").ok()\n        NONE\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def err(self) -&gt; Option[E]:\n        \"\"\"Converts from `Result[T, E]` to `Option[E]`.\n\n        `Err(e)` becomes `Some(e)`, and `Ok(v)` becomes `None`.\n\n        Returns:\n            Option[E]: An `Option` containing the `Err` value, or `None` if the result is `Ok`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).err()\n        NONE\n        &gt;&gt;&gt; pc.Err(\"error\").err()\n        Some('error')\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_ok_and[**P](\n        self, pred: Callable[Concatenate[T, P], bool], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; bool:\n        \"\"\"Returns True if the result is `Ok` and the predicate is true for the contained value.\n\n        Args:\n            pred (Callable[Concatenate[T, P], bool]): Predicate function to apply to the `Ok` value.\n            *args (P.args): Additional positional arguments to pass to pred.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to pred.\n\n        Returns:\n            bool: True if `Ok` and pred(value) is true, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).is_ok_and(lambda x: x &gt; 1)\n        True\n        &gt;&gt;&gt; pc.Ok(0).is_ok_and(lambda x: x &gt; 1)\n        False\n        &gt;&gt;&gt; pc.Err(\"err\").is_ok_and(lambda x: x &gt; 1)\n        False\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def is_err_and[**P](\n        self, pred: Callable[Concatenate[E, P], bool], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; bool:\n        \"\"\"Returns True if the result is Err and the predicate is true for the error value.\n\n        Args:\n            pred (Callable[Concatenate[E, P], bool]): Predicate function to apply to the Err value.\n            *args (P.args): Additional positional arguments to pass to pred.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to pred.\n\n        Returns:\n            bool: True if Err and pred(error) is true, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Err(\"foo\").is_err_and(lambda e: len(e) == 3)\n        True\n        &gt;&gt;&gt; pc.Err(\"bar\").is_err_and(lambda e: e == \"baz\")\n        False\n        &gt;&gt;&gt; pc.Ok(2).is_err_and(lambda e: True)\n        False\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def map_or[**P, R](\n        self,\n        default: R,\n        f: Callable[Concatenate[T, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; R:\n        \"\"\"Applies a function to the `Ok` value if present, otherwise returns the default value.\n\n        Args:\n            default (R): Value to return if the result is Err.\n            f (Callable[Concatenate[T, P], R]): Function to apply to the `Ok` value.\n            *args (P.args): Additional positional arguments to pass to f.\n            **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n        Returns:\n            R: Result of f(value) if Ok, otherwise default.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).map_or(10, lambda x: x * 2)\n        4\n        &gt;&gt;&gt; pc.Err(\"err\").map_or(10, lambda x: x * 2)\n        10\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def transpose(self: Result[Option[T], E]) -&gt; Option[Result[T, E]]:\n        \"\"\"Transposes a Result containing an Option into an Option containing a Result.\n\n        Can only be called if the inner type is `Option[T, E]`.\n\n        `Ok(Some(v)) -&gt; Some(Ok(v)), Ok(NONE) -&gt; NONE, Err(e) -&gt; Some(Err(e))`\n\n        Returns:\n            Option[Result[T, E]]: Option containing a Result or NONE.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(pc.Some(2)).transpose()\n        Some(Ok(2))\n        &gt;&gt;&gt; pc.Ok(pc.NONE).transpose()\n        NONE\n        &gt;&gt;&gt; pc.Err(\"err\").transpose()\n        Some(Err('err'))\n\n        ```\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def or_[F](self, res: Result[T, F]) -&gt; Result[T, F]:\n        \"\"\"Returns res if the result is `Err`, otherwise returns the `Ok` value of **self**.\n\n        Args:\n            res (Result[T, F]): The result to return if the original result is `Err`.\n\n        Returns:\n            Result[T, F]: The original `Ok` value, or `res` if the original result is `Err`.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Ok(2).or_(pc.Err(\"late error\"))\n        Ok(2)\n        &gt;&gt;&gt; pc.Err(\"early error\").or_(pc.Ok(2))\n        Ok(2)\n        &gt;&gt;&gt; pc.Err(\"not a 2\").or_(pc.Err(\"late error\"))\n        Err('late error')\n        &gt;&gt;&gt; pc.Ok(2).or_(pc.Ok(100))\n        Ok(2)\n\n        ```\n        \"\"\"\n        ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.and_","level":2,"title":"<code>and_(res)</code>  <code>abstractmethod</code>","text":"<p>Returns <code>res</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> value.</p> <p>This is often used for chaining operations that might fail.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>Result[U, E]</code> <p>The result to return if the original result is <code>Ok</code>.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>Result[U, E]: <code>res</code> if the original result is <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x = pc.Ok(2)\n&gt;&gt;&gt; y = pc.Err(\"late error\")\n&gt;&gt;&gt; x.and_(y)\nErr('late error')\n&gt;&gt;&gt; x = pc.Err(\"early error\")\n&gt;&gt;&gt; y = pc.Ok(\"foo\")\n&gt;&gt;&gt; x.and_(y)\nErr('early error')\n\n&gt;&gt;&gt; x = pc.Err(\"not a 2\")\n&gt;&gt;&gt; y = pc.Err(\"late error\")\n&gt;&gt;&gt; x.and_(y)\nErr('not a 2')\n\n&gt;&gt;&gt; x = pc.Ok(2)\n&gt;&gt;&gt; y = pc.Ok(\"different result type\")\n&gt;&gt;&gt; x.and_(y)\nOk('different result type')\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef and_[U](self, res: Result[U, E]) -&gt; Result[U, E]:\n    \"\"\"Returns `res` if the result is `Ok`, otherwise returns the `Err` value.\n\n    This is often used for chaining operations that might fail.\n\n    Args:\n        res (Result[U, E]): The result to return if the original result is `Ok`.\n\n    Returns:\n        Result[U, E]: `res` if the original result is `Ok`, otherwise the original `Err`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; x = pc.Ok(2)\n    &gt;&gt;&gt; y = pc.Err(\"late error\")\n    &gt;&gt;&gt; x.and_(y)\n    Err('late error')\n    &gt;&gt;&gt; x = pc.Err(\"early error\")\n    &gt;&gt;&gt; y = pc.Ok(\"foo\")\n    &gt;&gt;&gt; x.and_(y)\n    Err('early error')\n\n    &gt;&gt;&gt; x = pc.Err(\"not a 2\")\n    &gt;&gt;&gt; y = pc.Err(\"late error\")\n    &gt;&gt;&gt; x.and_(y)\n    Err('not a 2')\n\n    &gt;&gt;&gt; x = pc.Ok(2)\n    &gt;&gt;&gt; y = pc.Ok(\"different result type\")\n    &gt;&gt;&gt; x.and_(y)\n    Ok('different result type')\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.and_then","level":2,"title":"<code>and_then(fn, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Calls a function if the result is <code>Ok</code>, otherwise returns the <code>Err</code> value.</p> <p>This is often used for chaining operations that might fail.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[T, P], Result[R, E]]</code> <p>The function to call with the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[R, E]</code> <p>Result[R, E]: The result of the function if <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def to_str(x: int) -&gt; Result[str, str]:\n...     return pc.Ok(str(x))\n&gt;&gt;&gt; pc.Ok(2).and_then(to_str)\nOk('2')\n&gt;&gt;&gt; pc.Err(\"error\").and_then(to_str)\nErr('error')\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef and_then[**P, R](\n    self,\n    fn: Callable[Concatenate[T, P], Result[R, E]],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[R, E]:\n    \"\"\"Calls a function if the result is `Ok`, otherwise returns the `Err` value.\n\n    This is often used for chaining operations that might fail.\n\n    Args:\n        fn (Callable[Concatenate[T, P], Result[R, E]]): The function to call with the `Ok` value.\n        *args (P.args): Additional positional arguments to pass to fn.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n    Returns:\n        Result[R, E]: The result of the function if `Ok`, otherwise the original `Err`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def to_str(x: int) -&gt; Result[str, str]:\n    ...     return pc.Ok(str(x))\n    &gt;&gt;&gt; pc.Ok(2).and_then(to_str)\n    Ok('2')\n    &gt;&gt;&gt; pc.Err(\"error\").and_then(to_str)\n    Err('error')\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.err","level":2,"title":"<code>err()</code>  <code>abstractmethod</code>","text":"<p>Converts from <code>Result[T, E]</code> to <code>Option[E]</code>.</p> <p><code>Err(e)</code> becomes <code>Some(e)</code>, and <code>Ok(v)</code> becomes <code>None</code>.</p> <p>Returns:</p> Type Description <code>Option[E]</code> <p>Option[E]: An <code>Option</code> containing the <code>Err</code> value, or <code>None</code> if the result is <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).err()\nNONE\n&gt;&gt;&gt; pc.Err(\"error\").err()\nSome('error')\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef err(self) -&gt; Option[E]:\n    \"\"\"Converts from `Result[T, E]` to `Option[E]`.\n\n    `Err(e)` becomes `Some(e)`, and `Ok(v)` becomes `None`.\n\n    Returns:\n        Option[E]: An `Option` containing the `Err` value, or `None` if the result is `Ok`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).err()\n    NONE\n    &gt;&gt;&gt; pc.Err(\"error\").err()\n    Some('error')\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.expect","level":2,"title":"<code>expect(msg)</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Ok</code> value.</p> <p>Raises an exception with a provided message if the value is an <code>Err</code>.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to include in the exception if the result is <code>Err</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).expect(\"No error\")\n2\n&gt;&gt;&gt; pc.Err(\"emergency failure\").expect(\"Testing expect\")\nTraceback (most recent call last):\n    ...\npyochain._result.ResultUnwrapError: Testing expect: emergency failure\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef expect(self, msg: str) -&gt; T:\n    \"\"\"Returns the contained `Ok` value.\n\n    Raises an exception with a provided message if the value is an `Err`.\n\n    Args:\n        msg (str): The message to include in the exception if the result is `Err`.\n\n    Returns:\n        T: The contained `Ok` value.\n\n    Raises:\n        ResultUnwrapError: If the result is `Err`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).expect(\"No error\")\n    2\n    &gt;&gt;&gt; pc.Err(\"emergency failure\").expect(\"Testing expect\")\n    Traceback (most recent call last):\n        ...\n    pyochain._result.ResultUnwrapError: Testing expect: emergency failure\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.expect_err","level":2,"title":"<code>expect_err(msg)</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Err</code> value.</p> <p>Raises an exception with a provided message if the value is an <code>Ok</code>.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to include in the exception if the result is <code>Ok</code>.</p> required <p>Returns:</p> Name Type Description <code>E</code> <code>E</code> <p>The contained <code>Err</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"emergency failure\").expect_err(\"Testing expect_err\")\n'emergency failure'\n&gt;&gt;&gt; pc.Ok(10).expect_err(\"Testing expect_err\")\nTraceback (most recent call last):\n    ...\npyochain._result.ResultUnwrapError: Testing expect_err: expected Err, got Ok(10)\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef expect_err(self, msg: str) -&gt; E:\n    \"\"\"Returns the contained `Err` value.\n\n    Raises an exception with a provided message if the value is an `Ok`.\n\n    Args:\n        msg (str): The message to include in the exception if the result is `Ok`.\n\n    Returns:\n        E: The contained `Err` value.\n\n    Raises:\n        ResultUnwrapError: If the result is `Ok`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Err(\"emergency failure\").expect_err(\"Testing expect_err\")\n    'emergency failure'\n    &gt;&gt;&gt; pc.Ok(10).expect_err(\"Testing expect_err\")\n    Traceback (most recent call last):\n        ...\n    pyochain._result.ResultUnwrapError: Testing expect_err: expected Err, got Ok(10)\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Result</code>.</p> <p>Converts from <code>Result[Result[T, E], E]</code> to <code>Result[T, E]</code>.</p> <p>Equivalent to calling <code>Result.and_then(lambda x: x)</code>, but more convenient when there's no need to process the inner <code>Ok</code> value.</p> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The flattened result.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n&gt;&gt;&gt; nested_ok.flatten()\nOk(2)\n&gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n&gt;&gt;&gt; nested_err.flatten()\nErr('inner error')\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>def flatten(self: Result[Result[T, E], E]) -&gt; Result[T, E]:\n    \"\"\"Flattens a nested `Result`.\n\n    Converts from `Result[Result[T, E], E]` to `Result[T, E]`.\n\n    Equivalent to calling `Result.and_then(lambda x: x)`, but more convenient when there's no need to process the inner `Ok` value.\n\n    Returns:\n        Result[T, E]: The flattened result.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n    &gt;&gt;&gt; nested_ok.flatten()\n    Ok(2)\n    &gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n    &gt;&gt;&gt; nested_err.flatten()\n    Err('inner error')\n\n    ```\n    \"\"\"\n    return self.and_then(lambda x: x)\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.inspect","level":2,"title":"<code>inspect(fn, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Applies a function to the contained <code>Ok</code> value, returning the original <code>Result</code>.</p> <p>This is primarily useful for debugging or logging, allowing side effects to be performed on the <code>Ok</code> value without changing the result.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[T, P], object]</code> <p>Function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The original result, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; seen: list[int] = []\n&gt;&gt;&gt; pc.Ok(2).inspect(lambda x: seen.append(x))\nOk(2)\n&gt;&gt;&gt; seen\n[2]\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef inspect[**P](\n    self, fn: Callable[Concatenate[T, P], object], *args: P.args, **kwargs: P.kwargs\n) -&gt; Result[T, E]:\n    \"\"\"Applies a function to the contained `Ok` value, returning the original `Result`.\n\n    This is primarily useful for debugging or logging, allowing side effects to be\n    performed on the `Ok` value without changing the result.\n\n    Args:\n        fn (Callable[Concatenate[T, P], object]): Function to apply to the `Ok` value.\n        *args (P.args): Additional positional arguments to pass to fn.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n    Returns:\n        Result[T, E]: The original result, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; seen: list[int] = []\n    &gt;&gt;&gt; pc.Ok(2).inspect(lambda x: seen.append(x))\n    Ok(2)\n    &gt;&gt;&gt; seen\n    [2]\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.inspect_err","level":2,"title":"<code>inspect_err(fn, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Applies a function to the contained <code>Err</code> value, returning the original <code>Result</code>.</p> <p>This mirrors :meth:<code>inspect</code> but operates on the error value. It is useful for logging or debugging error paths while keeping the <code>Result</code> unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], object]</code> <p>Function to apply to the <code>Err</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The original result, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; seen: list[str] = []\n&gt;&gt;&gt; pc.Err(\"oops\").inspect_err(lambda e: seen.append(e))\nErr('oops')\n&gt;&gt;&gt; seen\n['oops']\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef inspect_err[**P](\n    self, fn: Callable[Concatenate[E, P], object], *args: P.args, **kwargs: P.kwargs\n) -&gt; Result[T, E]:\n    \"\"\"Applies a function to the contained `Err` value, returning the original `Result`.\n\n    This mirrors :meth:`inspect` but operates on the error value. It is useful for\n    logging or debugging error paths while keeping the `Result` unchanged.\n\n    Args:\n        fn (Callable[Concatenate[E, P], object]): Function to apply to the `Err` value.\n        *args (P.args): Additional positional arguments to pass to fn.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n    Returns:\n        Result[T, E]: The original result, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; seen: list[str] = []\n    &gt;&gt;&gt; pc.Err(\"oops\").inspect_err(lambda e: seen.append(e))\n    Err('oops')\n    &gt;&gt;&gt; seen\n    ['oops']\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.is_err","level":2,"title":"<code>is_err()</code>  <code>abstractmethod</code>","text":"<p>Returns <code>True</code> if the result is <code>Err</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the result is an <code>Err</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n&gt;&gt;&gt; x.is_err()\nFalse\n&gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n&gt;&gt;&gt; y.is_err()\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef is_err(self) -&gt; bool:\n    \"\"\"Returns `True` if the result is `Err`.\n\n    Returns:\n        bool: `True` if the result is an `Err` variant, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n    &gt;&gt;&gt; x.is_err()\n    False\n    &gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n    &gt;&gt;&gt; y.is_err()\n    True\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.is_err_and","level":2,"title":"<code>is_err_and(pred, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns True if the result is Err and the predicate is true for the error value.</p> <p>Parameters:</p> Name Type Description Default <code>pred</code> <code>Callable[Concatenate[E, P], bool]</code> <p>Predicate function to apply to the Err value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to pred.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to pred.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if Err and pred(error) is true, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"foo\").is_err_and(lambda e: len(e) == 3)\nTrue\n&gt;&gt;&gt; pc.Err(\"bar\").is_err_and(lambda e: e == \"baz\")\nFalse\n&gt;&gt;&gt; pc.Ok(2).is_err_and(lambda e: True)\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef is_err_and[**P](\n    self, pred: Callable[Concatenate[E, P], bool], *args: P.args, **kwargs: P.kwargs\n) -&gt; bool:\n    \"\"\"Returns True if the result is Err and the predicate is true for the error value.\n\n    Args:\n        pred (Callable[Concatenate[E, P], bool]): Predicate function to apply to the Err value.\n        *args (P.args): Additional positional arguments to pass to pred.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to pred.\n\n    Returns:\n        bool: True if Err and pred(error) is true, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Err(\"foo\").is_err_and(lambda e: len(e) == 3)\n    True\n    &gt;&gt;&gt; pc.Err(\"bar\").is_err_and(lambda e: e == \"baz\")\n    False\n    &gt;&gt;&gt; pc.Ok(2).is_err_and(lambda e: True)\n    False\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.is_ok","level":2,"title":"<code>is_ok()</code>  <code>abstractmethod</code>","text":"<p>Returns <code>True</code> if the result is <code>Ok</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the result is an <code>Ok</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n&gt;&gt;&gt; x.is_ok()\nTrue\n&gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n&gt;&gt;&gt; y.is_ok()\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef is_ok(self) -&gt; bool:\n    \"\"\"Returns `True` if the result is `Ok`.\n\n    Returns:\n        bool: `True` if the result is an `Ok` variant, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n    &gt;&gt;&gt; x.is_ok()\n    True\n    &gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n    &gt;&gt;&gt; y.is_ok()\n    False\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.is_ok_and","level":2,"title":"<code>is_ok_and(pred, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns True if the result is <code>Ok</code> and the predicate is true for the contained value.</p> <p>Parameters:</p> Name Type Description Default <code>pred</code> <code>Callable[Concatenate[T, P], bool]</code> <p>Predicate function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to pred.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to pred.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>Ok</code> and pred(value) is true, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).is_ok_and(lambda x: x &gt; 1)\nTrue\n&gt;&gt;&gt; pc.Ok(0).is_ok_and(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; pc.Err(\"err\").is_ok_and(lambda x: x &gt; 1)\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef is_ok_and[**P](\n    self, pred: Callable[Concatenate[T, P], bool], *args: P.args, **kwargs: P.kwargs\n) -&gt; bool:\n    \"\"\"Returns True if the result is `Ok` and the predicate is true for the contained value.\n\n    Args:\n        pred (Callable[Concatenate[T, P], bool]): Predicate function to apply to the `Ok` value.\n        *args (P.args): Additional positional arguments to pass to pred.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to pred.\n\n    Returns:\n        bool: True if `Ok` and pred(value) is true, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).is_ok_and(lambda x: x &gt; 1)\n    True\n    &gt;&gt;&gt; pc.Ok(0).is_ok_and(lambda x: x &gt; 1)\n    False\n    &gt;&gt;&gt; pc.Err(\"err\").is_ok_and(lambda x: x &gt; 1)\n    False\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.iter","level":2,"title":"<code>iter()</code>","text":"<p>Returns a <code>Iter[T]</code> over the possibly contained value.</p> <p>The iterator yields one value if the result is <code>Ok</code>, otherwise none.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterator over the <code>Ok</code> value, or empty if <code>Err</code>.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(7).iter().next()\nSome(7)\n&gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Returns a `Iter[T]` over the possibly contained value.\n\n    The iterator yields one value if the result is `Ok`, otherwise none.\n\n    Returns:\n        Iter[T]: An iterator over the `Ok` value, or empty if `Err`.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(7).iter().next()\n    Some(7)\n    &gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\n    NONE\n\n    ```\n    \"\"\"\n    return self.ok().iter()\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.map","level":2,"title":"<code>map(fn, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Maps a <code>Result[T, E]</code> to <code>Result[U, E]</code>.</p> <p>Done by applying a function to a contained <code>Ok</code> value, leaving an <code>Err</code> value untouched.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[T, P], R]</code> <p>The function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[R, E]</code> <p>Result[R, E]: A new <code>Result</code> with the mapped value if <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).map(lambda x: x * 2)\nOk(4)\n&gt;&gt;&gt; pc.Err(\"error\").map(lambda x: x * 2)\nErr('error')\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef map[**P, R](\n    self, fn: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs\n) -&gt; Result[R, E]:\n    \"\"\"Maps a `Result[T, E]` to `Result[U, E]`.\n\n    Done by applying a function to a contained `Ok` value,\n    leaving an `Err` value untouched.\n\n    Args:\n        fn (Callable[Concatenate[T, P], R]): The function to apply to the `Ok` value.\n        *args (P.args): Additional positional arguments to pass to fn.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n    Returns:\n        Result[R, E]: A new `Result` with the mapped value if `Ok`, otherwise the original `Err`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).map(lambda x: x * 2)\n    Ok(4)\n    &gt;&gt;&gt; pc.Err(\"error\").map(lambda x: x * 2)\n    Err('error')\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.map_err","level":2,"title":"<code>map_err(fn, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Maps a <code>Result[T, E]</code> to <code>Result[T, R]</code>.</p> <p>Done by applying a function to a contained <code>Err</code> value, leaving an <code>Ok</code> value untouched.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], R]</code> <p>The function to apply to the <code>Err</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, R]</code> <p>Result[T, R]: A new <code>Result</code> with the mapped error if <code>Err</code>, otherwise the original <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).map_err(len)\nOk(2)\n&gt;&gt;&gt; pc.Err(\"foo\").map_err(len)\nErr(3)\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef map_err[**P, R](\n    self, fn: Callable[Concatenate[E, P], R], *args: P.args, **kwargs: P.kwargs\n) -&gt; Result[T, R]:\n    \"\"\"Maps a `Result[T, E]` to `Result[T, R]`.\n\n    Done by applying a function to a contained `Err` value,\n    leaving an `Ok` value untouched.\n\n    Args:\n        fn (Callable[Concatenate[E, P], R]): The function to apply to the `Err` value.\n        *args (P.args): Additional positional arguments to pass to fn.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n\n    Returns:\n        Result[T, R]: A new `Result` with the mapped error if `Err`, otherwise the original `Ok`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).map_err(len)\n    Ok(2)\n    &gt;&gt;&gt; pc.Err(\"foo\").map_err(len)\n    Err(3)\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.map_or","level":2,"title":"<code>map_or(default, f, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Applies a function to the <code>Ok</code> value if present, otherwise returns the default value.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>R</code> <p>Value to return if the result is Err.</p> required <code>f</code> <code>Callable[Concatenate[T, P], R]</code> <p>Function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>Result of f(value) if Ok, otherwise default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).map_or(10, lambda x: x * 2)\n4\n&gt;&gt;&gt; pc.Err(\"err\").map_or(10, lambda x: x * 2)\n10\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef map_or[**P, R](\n    self,\n    default: R,\n    f: Callable[Concatenate[T, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Applies a function to the `Ok` value if present, otherwise returns the default value.\n\n    Args:\n        default (R): Value to return if the result is Err.\n        f (Callable[Concatenate[T, P], R]): Function to apply to the `Ok` value.\n        *args (P.args): Additional positional arguments to pass to f.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to f.\n\n    Returns:\n        R: Result of f(value) if Ok, otherwise default.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).map_or(10, lambda x: x * 2)\n    4\n    &gt;&gt;&gt; pc.Err(\"err\").map_or(10, lambda x: x * 2)\n    10\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.map_or_else","level":2,"title":"<code>map_or_else(ok, err)</code>  <code>abstractmethod</code>","text":"<p>Maps a <code>Result[T, E]</code> to <code>U</code>.</p> <p>Done by applying a fallback function to a contained <code>Err</code> value, or a default function to a contained <code>Ok</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>ok</code> <code>Callable[[T], U]</code> <p>The function to apply to the <code>Ok</code> value.</p> required <code>err</code> <code>Callable[[E], U]</code> <p>The function to apply to the <code>Err</code> value.</p> required <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The result of applying the appropriate function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; k = 21\n&gt;&gt;&gt; pc.Ok(\"foo\").map_or_else(len, lambda e: k * 2)\n3\n&gt;&gt;&gt; pc.Err(\"bar\").map_or_else(len, lambda e: k * 2)\n42\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef map_or_else[U](self, ok: Callable[[T], U], err: Callable[[E], U]) -&gt; U:\n    \"\"\"Maps a `Result[T, E]` to `U`.\n\n    Done by applying a fallback function to a contained `Err` value,\n    or a default function to a contained `Ok` value.\n\n    Args:\n        ok (Callable[[T], U]): The function to apply to the `Ok` value.\n        err (Callable[[E], U]): The function to apply to the `Err` value.\n\n    Returns:\n        U: The result of applying the appropriate function.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; k = 21\n    &gt;&gt;&gt; pc.Ok(\"foo\").map_or_else(len, lambda e: k * 2)\n    3\n    &gt;&gt;&gt; pc.Err(\"bar\").map_or_else(len, lambda e: k * 2)\n    42\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.ok","level":2,"title":"<code>ok()</code>  <code>abstractmethod</code>","text":"<p>Converts from <code>Result[T, E]</code> to <code>Option[T]</code>.</p> <p><code>Ok(v)</code> becomes <code>Some(v)</code>, and <code>Err(e)</code> becomes <code>None</code>.</p> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: An <code>Option</code> containing the <code>Ok</code> value, or <code>None</code> if the result is <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).ok()\nSome(2)\n&gt;&gt;&gt; pc.Err(\"error\").ok()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef ok(self) -&gt; Option[T]:\n    \"\"\"Converts from `Result[T, E]` to `Option[T]`.\n\n    `Ok(v)` becomes `Some(v)`, and `Err(e)` becomes `None`.\n\n    Returns:\n        Option[T]: An `Option` containing the `Ok` value, or `None` if the result is `Err`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).ok()\n    Some(2)\n    &gt;&gt;&gt; pc.Err(\"error\").ok()\n    NONE\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.or_","level":2,"title":"<code>or_(res)</code>  <code>abstractmethod</code>","text":"<p>Returns res if the result is <code>Err</code>, otherwise returns the <code>Ok</code> value of self.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>Result[T, F]</code> <p>The result to return if the original result is <code>Err</code>.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>Result[T, F]: The original <code>Ok</code> value, or <code>res</code> if the original result is <code>Err</code>.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).or_(pc.Err(\"late error\"))\nOk(2)\n&gt;&gt;&gt; pc.Err(\"early error\").or_(pc.Ok(2))\nOk(2)\n&gt;&gt;&gt; pc.Err(\"not a 2\").or_(pc.Err(\"late error\"))\nErr('late error')\n&gt;&gt;&gt; pc.Ok(2).or_(pc.Ok(100))\nOk(2)\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef or_[F](self, res: Result[T, F]) -&gt; Result[T, F]:\n    \"\"\"Returns res if the result is `Err`, otherwise returns the `Ok` value of **self**.\n\n    Args:\n        res (Result[T, F]): The result to return if the original result is `Err`.\n\n    Returns:\n        Result[T, F]: The original `Ok` value, or `res` if the original result is `Err`.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).or_(pc.Err(\"late error\"))\n    Ok(2)\n    &gt;&gt;&gt; pc.Err(\"early error\").or_(pc.Ok(2))\n    Ok(2)\n    &gt;&gt;&gt; pc.Err(\"not a 2\").or_(pc.Err(\"late error\"))\n    Err('late error')\n    &gt;&gt;&gt; pc.Ok(2).or_(pc.Ok(100))\n    Ok(2)\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.or_else","level":2,"title":"<code>or_else(fn, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Calls a function if the result is <code>Err</code>, otherwise returns the <code>Ok</code> value.</p> <p>This is often used for handling errors by trying an alternative operation.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], Result[T, E]]</code> <p>The function to call with the <code>Err</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The original <code>Ok</code> value, or the result of the function if <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def fallback(e: str) -&gt; Result[int, str]:\n...     return pc.Ok(len(e))\n&gt;&gt;&gt; pc.Ok(2).or_else(fallback)\nOk(2)\n&gt;&gt;&gt; pc.Err(\"foo\").or_else(fallback)\nOk(3)\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef or_else[**P](\n    self,\n    fn: Callable[Concatenate[E, P], Result[T, E]],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[T, E]:\n    \"\"\"Calls a function if the result is `Err`, otherwise returns the `Ok` value.\n\n    This is often used for handling errors by trying an alternative operation.\n\n    Args:\n        fn (Callable[Concatenate[E, P], Result[T, E]]): The function to call with the `Err` value.\n        *args (P.args): Additional positional arguments to pass to fn.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n    Returns:\n        Result[T, E]: The original `Ok` value, or the result of the function if `Err`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def fallback(e: str) -&gt; Result[int, str]:\n    ...     return pc.Ok(len(e))\n    &gt;&gt;&gt; pc.Ok(2).or_else(fallback)\n    Ok(2)\n    &gt;&gt;&gt; pc.Err(\"foo\").or_else(fallback)\n    Ok(3)\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.transpose","level":2,"title":"<code>transpose()</code>  <code>abstractmethod</code>","text":"<p>Transposes a Result containing an Option into an Option containing a Result.</p> <p>Can only be called if the inner type is <code>Option[T, E]</code>.</p> <p><code>Ok(Some(v)) -&gt; Some(Ok(v)), Ok(NONE) -&gt; NONE, Err(e) -&gt; Some(Err(e))</code></p> <p>Returns:</p> Type Description <code>Option[Result[T, E]]</code> <p>Option[Result[T, E]]: Option containing a Result or NONE.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(pc.Some(2)).transpose()\nSome(Ok(2))\n&gt;&gt;&gt; pc.Ok(pc.NONE).transpose()\nNONE\n&gt;&gt;&gt; pc.Err(\"err\").transpose()\nSome(Err('err'))\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef transpose(self: Result[Option[T], E]) -&gt; Option[Result[T, E]]:\n    \"\"\"Transposes a Result containing an Option into an Option containing a Result.\n\n    Can only be called if the inner type is `Option[T, E]`.\n\n    `Ok(Some(v)) -&gt; Some(Ok(v)), Ok(NONE) -&gt; NONE, Err(e) -&gt; Some(Err(e))`\n\n    Returns:\n        Option[Result[T, E]]: Option containing a Result or NONE.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(pc.Some(2)).transpose()\n    Some(Ok(2))\n    &gt;&gt;&gt; pc.Ok(pc.NONE).transpose()\n    NONE\n    &gt;&gt;&gt; pc.Err(\"err\").transpose()\n    Some(Err('err'))\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.unwrap","level":2,"title":"<code>unwrap()</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Ok</code> value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap()\nTraceback (most recent call last):\n    ...\npyochain._result.ResultUnwrapError: called `unwrap` on Err: 'emergency failure'\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef unwrap(self) -&gt; T:\n    \"\"\"Returns the contained `Ok` value.\n\n    Returns:\n        T: The contained `Ok` value.\n\n    Raises:\n        ResultUnwrapError: If the result is `Err`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).unwrap()\n    2\n\n    ```\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap()\n    Traceback (most recent call last):\n        ...\n    pyochain._result.ResultUnwrapError: called `unwrap` on Err: 'emergency failure'\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.unwrap_err","level":2,"title":"<code>unwrap_err()</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Err</code> value.</p> <p>Returns:</p> Name Type Description <code>E</code> <code>E</code> <p>The contained <code>Err</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap_err()\n'emergency failure'\n</code></pre> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap_err()\nTraceback (most recent call last):\n    ...\npyochain._result.ResultUnwrapError: called `unwrap_err` on Ok\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef unwrap_err(self) -&gt; E:\n    \"\"\"Returns the contained `Err` value.\n\n    Returns:\n        E: The contained `Err` value.\n\n    Raises:\n        ResultUnwrapError: If the result is `Ok`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap_err()\n    'emergency failure'\n\n    ```\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).unwrap_err()\n    Traceback (most recent call last):\n        ...\n    pyochain._result.ResultUnwrapError: called `unwrap_err` on Ok\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.unwrap_or","level":2,"title":"<code>unwrap_or(default)</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Ok</code> value or a provided default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The value to return if the result is <code>Err</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value or the provided default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap_or(10)\n2\n&gt;&gt;&gt; pc.Err(\"error\").unwrap_or(10)\n10\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef unwrap_or(self, default: T) -&gt; T:\n    \"\"\"Returns the contained `Ok` value or a provided default.\n\n    Args:\n        default (T): The value to return if the result is `Err`.\n\n    Returns:\n        T: The contained `Ok` value or the provided default.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).unwrap_or(10)\n    2\n    &gt;&gt;&gt; pc.Err(\"error\").unwrap_or(10)\n    10\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain._result.Result.unwrap_or_else","level":2,"title":"<code>unwrap_or_else(fn, *args, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>Returns the contained <code>Ok</code> value or computes it from a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], T]</code> <p>A function that takes the <code>Err</code> value and returns a default value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value or the result of the function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap_or_else(len)\n2\n&gt;&gt;&gt; pc.Err(\"foo\").unwrap_or_else(len)\n3\n</code></pre></p> Source code in <code>src/pyochain/_result.py</code> <pre><code>@abstractmethod\ndef unwrap_or_else[**P](\n    self, fn: Callable[Concatenate[E, P], T], *args: P.args, **kwargs: P.kwargs\n) -&gt; T:\n    \"\"\"Returns the contained `Ok` value or computes it from a function.\n\n    Args:\n        fn (Callable[Concatenate[E, P], T]): A function that takes the `Err` value and returns a default value.\n        *args (P.args): Additional positional arguments to pass to fn.\n        **kwargs (P.kwargs): Additional keyword arguments to pass to fn.\n\n    Returns:\n        T: The contained `Ok` value or the result of the function.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Ok(2).unwrap_or_else(len)\n    2\n    &gt;&gt;&gt; pc.Err(\"foo\").unwrap_or_else(len)\n    3\n\n    ```\n    \"\"\"\n    ...\n</code></pre>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/seq/","level":1,"title":"Seq","text":"<p>               Bases: <code>BaseIter[T]</code>, <code>Sequence[T]</code></p> <p><code>Seq</code> represent an in memory Sequence.</p> <p>Implements the <code>Sequence</code> Protocol from <code>collections.abc</code>, so it can be used as a standard immutable sequence.</p> <p>Provides a subset of <code>Iter</code> methods with eager evaluation, and is the return type of <code>Iter.collect()</code>.</p> <p>The underlying data structure is an immutable tuple, hence the memory efficiency is better than a <code>Vec</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The data to initialize the Seq with.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Seq[T](BaseIter[T], Sequence[T]):\n    \"\"\"`Seq` represent an in memory Sequence.\n\n    Implements the `Sequence` Protocol from `collections.abc`, so it can be used as a standard immutable sequence.\n\n    Provides a subset of `Iter` methods with eager evaluation, and is the return type of `Iter.collect()`.\n\n    The underlying data structure is an immutable tuple, hence the memory efficiency is better than a `Vec`.\n\n    Args:\n            data (Iterable[T]): The data to initialize the Seq with.\n    \"\"\"\n\n    _inner: tuple[T, ...]\n\n    __slots__ = (\"_inner\",)\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = tuple(data)  # pyright: ignore[reportIncompatibleVariableOverride]\n\n    def __len__(self) -&gt; int:\n        return len(self._inner)\n\n    @overload\n    def __getitem__(self, index: int) -&gt; T: ...\n    @overload\n    def __getitem__(self, index: slice) -&gt; Sequence[T]: ...\n    def __getitem__(self, index: int | slice[Any, Any, Any]) -&gt; T | Sequence[T]:\n        return self._inner.__getitem__(index)\n\n    def is_distinct(self) -&gt; bool:\n        \"\"\"Return True if all items are distinct.\n\n        Returns:\n            bool: True if all items are distinct, False otherwise.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\n        True\n\n        ```\n        \"\"\"\n        return cz.itertoolz.isdistinct(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.all","level":2,"title":"<code>all(predicate=None)</code>","text":"<p>Tests if every element of the iterator matches a predicate.</p> <p><code>Iter.all()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if they all return true, then so does <code>Iter.all()</code>.</p> <p>If any of them return false, it returns false.</p> <p>An empty iterator returns true.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements match the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, True]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 0]).all()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if every element of the iterator matches a predicate.\n\n    `Iter.all()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if they all return true, then so does `Iter.all()`.\n\n    If any of them return false, it returns false.\n\n    An empty iterator returns true.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if all elements match the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, True]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 0]).all()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return all(self._inner)\n    return all(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.all_equal","level":2,"title":"<code>all_equal(key=None)</code>","text":"<p>Return True if all items are equal.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\nTrue\n</code></pre> A function that accepts a single argument and returns a transformed version of each input item can be specified with key: <pre><code>&gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_equal[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Return True if all items are equal.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all items are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\n    True\n\n    ```\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with key:\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\n    True\n\n    ```\n    \"\"\"\n    return mit.all_equal(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.all_unique","level":2,"title":"<code>all_unique(key=None)</code>","text":"<p>Returns True if all the elements of iterable are unique.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements are unique, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\nFalse\n</code></pre> If a key function is specified, it will be used to make comparisons. <pre><code>&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\nTrue\n&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\nFalse\n</code></pre> The function returns as soon as the first non-unique element is encountered.</p> <p>Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_unique[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Returns True if all the elements of iterable are unique.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\n    False\n\n    ```\n    If a key function is specified, it will be used to make comparisons.\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\n    True\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\n    False\n\n    ```\n    The function returns as soon as the first non-unique element is encountered.\n\n    Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items\n\n    \"\"\"\n    return mit.all_unique(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.any","level":2,"title":"<code>any(predicate=None)</code>","text":"<p>Tests if any element of the iterator matches a predicate.</p> <p><code>Iter.any()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if any of them return true, then so does <code>Iter.any()</code>.</p> <p>If they all return false, it returns false.</p> <p>An empty iterator returns false.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any element matches the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([0, 1]).any()\nTrue\n&gt;&gt;&gt; pc.Seq(range(0)).any()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def any(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if any element of the iterator matches a predicate.\n\n    `Iter.any()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if any of them return true, then so does `Iter.any()`.\n\n    If they all return false, it returns false.\n\n    An empty iterator returns false.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if any element matches the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([0, 1]).any()\n    True\n    &gt;&gt;&gt; pc.Seq(range(0)).any()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return any(self._inner)\n    return any(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.argmax","level":2,"title":"<code>argmax(key=None)</code>","text":"<p>Index of the first occurrence of a maximum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the maximum value.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n7\n&gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n3\n</code></pre> For example, identify the best machine learning model: <pre><code>&gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n&gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n&gt;&gt;&gt; # Most accurate model\n&gt;&gt;&gt; models.nth(accuracy.argmax())\n'knn'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Best accuracy\n&gt;&gt;&gt; accuracy.into(max)\n84\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmax[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a maximum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the maximum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n    7\n    &gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n    3\n\n    ```\n    For example, identify the best machine learning model:\n    ```python\n    &gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n    &gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n    &gt;&gt;&gt; # Most accurate model\n    &gt;&gt;&gt; models.nth(accuracy.argmax())\n    'knn'\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Best accuracy\n    &gt;&gt;&gt; accuracy.into(max)\n    84\n\n    ```\n    \"\"\"\n    return mit.argmax(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.argmin","level":2,"title":"<code>argmin(key=None)</code>","text":"<p>Index of the first occurrence of a minimum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the minimum value.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n4\n&gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n3\n</code></pre> <p>For example, look up a label corresponding to the position of a value that minimizes a cost function: <pre><code>&gt;&gt;&gt; def cost(x):\n...     \"Days for a wound to heal given a subject's age.\"\n...     return x**2 - 20 * x + 150\n&gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n&gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n&gt;&gt;&gt; # Fastest healing family member\n&gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n'bart'\n&gt;&gt;&gt; # Age with fastest healing\n&gt;&gt;&gt; ages.into(min, key=cost)\n10\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmin[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a minimum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the minimum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n    4\n    &gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n    3\n\n    ```\n\n    For example, look up a label corresponding to the position of a value that minimizes a cost function:\n    ```python\n    &gt;&gt;&gt; def cost(x):\n    ...     \"Days for a wound to heal given a subject's age.\"\n    ...     return x**2 - 20 * x + 150\n    &gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n    &gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n    &gt;&gt;&gt; # Fastest healing family member\n    &gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n    'bart'\n    &gt;&gt;&gt; # Age with fastest healing\n    &gt;&gt;&gt; ages.into(min, key=cost)\n    10\n\n    ```\n    \"\"\"\n    return mit.argmin(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.combination_index","level":2,"title":"<code>combination_index(r)</code>","text":"<p>Computes the index of the first element, without computing the previous combinations.</p> <p>The subsequences of iterable that are of length r can be ordered lexicographically.</p> <p>ValueError will be raised if the given element isn't one of the combinations of iterable.</p> <p>Equivalent to list(combinations(iterable, r)).index(element).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>Iterable[T]</code> <p>The combination to find the index of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the combination.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n10\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combination_index(self, r: Iterable[T]) -&gt; int:\n    \"\"\"Computes the index of the first element, without computing the previous combinations.\n\n    The subsequences of iterable that are of length r can be ordered lexicographically.\n\n\n    ValueError will be raised if the given element isn't one of the combinations of iterable.\n\n    Equivalent to list(combinations(iterable, r)).index(element).\n\n    Args:\n        r (Iterable[T]): The combination to find the index of.\n\n    Returns:\n        int: The index of the combination.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n    10\n\n    ```\n    \"\"\"\n    return mit.combination_index(r, self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Check if two Iterables are equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\nFalse\n&gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def eq(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\n    False\n    &gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\n    True\n\n    ```\n    \"\"\"\n    return tuple(self._inner) == tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.find","level":2,"title":"<code>find(predicate)</code>","text":"<p>Searches for an element of an iterator that satisfies a <code>predicate</code>.</p> <p>Takes a closure that returns true or false as <code>predicate</code>, and applies it to each element of the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The first element satisfying the predicate. <code>Some(value)</code> if found, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n...     return x &gt; 5\n&gt;&gt;&gt;\n&gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n...     return x &gt; 9\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\nSome(6)\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n'missing'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def find(self, predicate: Callable[[T], bool]) -&gt; Option[T]:\n    \"\"\"Searches for an element of an iterator that satisfies a `predicate`.\n\n    Takes a closure that returns true or false as `predicate`, and applies it to each element of the iterator.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Option[T]: The first element satisfying the predicate. `Some(value)` if found, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n    ...     return x &gt; 5\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n    ...     return x &gt; 9\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\n    Some(6)\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n    'missing'\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(next(filter(predicate, self._inner), None))\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.first","level":2,"title":"<code>first()</code>","text":"<p>Return the first element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The first element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9]).first()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def first(self) -&gt; T:\n    \"\"\"Return the first element.\n\n    Returns:\n        T: The first element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9]).first()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.first(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.fold","level":2,"title":"<code>fold(init, func)</code>","text":"<p>Fold every element into an accumulator by applying an operation, returning the final result.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>B</code> <p>Initial value for the accumulator.</p> required <code>func</code> <code>Callable[[B, T], B]</code> <p>Function that takes the accumulator and current element, returning the new accumulator value.</p> required <p>Returns:</p> Name Type Description <code>B</code> <code>B</code> <p>The final accumulated value.</p> Note <p>This is similar to <code>reduce()</code> but with an initial value, making it equivalent to Python's <code>functools.reduce()</code> with an initializer.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n6\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n16\n&gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n'abc'\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def fold[B](self, init: B, func: Callable[[B, T], B]) -&gt; B:\n    \"\"\"Fold every element into an accumulator by applying an operation, returning the final result.\n\n    Args:\n        init (B): Initial value for the accumulator.\n        func (Callable[[B, T], B]): Function that takes the accumulator and current element,\n            returning the new accumulator value.\n\n    Returns:\n        B: The final accumulated value.\n\n    Note:\n        This is similar to `reduce()` but with an initial value, making it equivalent to\n        Python's `functools.reduce()` with an initializer.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n    6\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n    16\n    &gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n    'abc'\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner, init)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.ge","level":2,"title":"<code>ge(other)</code>","text":"<p>Check if this Iterable is greater than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ge(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.gt","level":2,"title":"<code>gt(other)</code>","text":"<p>Check if this Iterable is greater than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def gt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.is_distinct","level":2,"title":"<code>is_distinct()</code>","text":"<p>Return True if all items are distinct.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are distinct, False otherwise.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\nTrue\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_distinct(self) -&gt; bool:\n    \"\"\"Return True if all items are distinct.\n\n    Returns:\n        bool: True if all items are distinct, False otherwise.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\n    True\n\n    ```\n    \"\"\"\n    return cz.itertoolz.isdistinct(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.is_sorted","level":2,"title":"<code>is_sorted(key=None, *, reverse=False, strict=False)</code>","text":"<p>Returns True if the items of iterable are in sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to check for descending order. Defaults to False.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Whether to enforce strict sorting (no equal elements). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if items are sorted according to the criteria, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\nTrue\n&gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\nFalse\n\nIf strict, tests for strict sorting, that is, returns False if equal elements are found:\n```python\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\nFalse\n</code></pre></p> <p>The function returns False after encountering the first out-of-order item.</p> <p>This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).</p> <p>If there are no out-of-order items, the iterable is exhausted.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_sorted[U](\n    self,\n    key: Callable[[T], U] | None = None,\n    *,\n    reverse: bool = False,\n    strict: bool = False,\n) -&gt; bool:\n    \"\"\"Returns True if the items of iterable are in sorted order.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n        reverse (bool): Whether to check for descending order. Defaults to False.\n        strict (bool): Whether to enforce strict sorting (no equal elements). Defaults to False.\n\n    Returns:\n        bool: True if items are sorted according to the criteria, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\n    True\n    &gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\n    False\n\n    If strict, tests for strict sorting, that is, returns False if equal elements are found:\n    ```python\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\n    False\n\n    ```\n\n    The function returns False after encountering the first out-of-order item.\n\n    This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).\n\n    If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n    return mit.is_sorted(self._inner, key=key, reverse=reverse, strict=strict)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.iter","level":2,"title":"<code>iter()</code>","text":"<p>Get an iterator over the <code>Iterable</code>.</p> <p>Call this to switch to lazy evaluation.</p> <p>Calling this method on an <code>Iter</code> instance has no effect.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> over the <code>Iterable</code>.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Get an iterator over the `Iterable`.\n\n    Call this to switch to lazy evaluation.\n\n    Calling this method on an `Iter` instance has no effect.\n\n    Returns:\n        Iter[T]: An `Iterator` over the `Iterable`.\n    \"\"\"\n    return Iter(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.join","level":2,"title":"<code>join(sep)</code>","text":"<p>Join all elements of the <code>Iterable</code> into a single <code>string</code>, with a specified separator.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>str</code> <p>Separator to use between elements.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The joined string.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n'a-b-c'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def join(self: BaseIter[str], sep: str) -&gt; str:\n    \"\"\"Join all elements of the `Iterable` into a single `string`, with a specified separator.\n\n    Args:\n        sep (str): Separator to use between elements.\n\n    Returns:\n        str: The joined string.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n    'a-b-c'\n\n    ```\n    \"\"\"\n    return sep.join(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.last","level":2,"title":"<code>last()</code>","text":"<p>Return the last element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The last element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def last(self) -&gt; T:\n    \"\"\"Return the last element.\n\n    Returns:\n        T: The last element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.last(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.le","level":2,"title":"<code>le(other)</code>","text":"<p>Check if this Iterable is less than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def le(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.length","level":2,"title":"<code>length()</code>","text":"<p>Return the length of the Iterable.</p> <p>Like the builtin len but works on lazy sequences.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The count of elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).length()\n2\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def length(self) -&gt; int:\n    \"\"\"Return the length of the Iterable.\n\n    Like the builtin len but works on lazy sequences.\n\n    Returns:\n        int: The count of elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).length()\n    2\n\n    ```\n    \"\"\"\n    return cz.itertoolz.count(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.lt","level":2,"title":"<code>lt(other)</code>","text":"<p>Check if this Iterable is less than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def lt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.max","level":2,"title":"<code>max()</code>","text":"<p>Return the maximum of the <code>Iterable</code>.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>max_by()</code> instead.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The maximum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n3\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the maximum of the `Iterable`.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `max_by()` instead.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Returns:\n        U: The maximum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n    3\n\n    ```\n    \"\"\"\n    return max(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.max_by","level":2,"title":"<code>max_by(*, key)</code>","text":"<p>Return the maximum element using a custom key function.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the maximum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=4, y='c')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=3, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the maximum element using a custom **key** function.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the maximum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=4, y='c')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=3, y='b')\n\n    ```\n    \"\"\"\n    return max(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.min","level":2,"title":"<code>min()</code>","text":"<p>Return the minimum of the sequence.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>min_by()</code> instead.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The minimum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n1\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the minimum of the sequence.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `min_by()` instead.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Returns:\n        U: The minimum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n    1\n\n    ```\n    \"\"\"\n    return min(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.min_by","level":2,"title":"<code>min_by(*, key)</code>","text":"<p>Return the minimum element using a custom key function.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the minimum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the minimum element using a custom **key** function.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the minimum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n\n    ```\n    \"\"\"\n    return min(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.most_common","level":2,"title":"<code>most_common(n=None)</code>","text":"<p>Return the n most common elements and their counts.</p> <p>If n is None, then all elements are returned.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of most common elements to return. Defaults to None (all elements).</p> <code>None</code> <p>Returns:</p> Type Description <code>Vec[tuple[T, int]]</code> <p>Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\nVec((3, 3), (1, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def most_common(self, n: int | None = None) -&gt; Vec[tuple[T, int]]:\n    \"\"\"Return the n most common elements and their counts.\n\n    If n is None, then all elements are returned.\n\n    Args:\n        n (int | None): Number of most common elements to return. Defaults to None (all elements).\n\n    Returns:\n        Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\n    Vec((3, 3), (1, 2))\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return Vec(Counter(self._inner).most_common(n))\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.ne","level":2,"title":"<code>ne(other)</code>","text":"<p>Check if two Iterables are not equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are not equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ne(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are not equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are not equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) != tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.nth","level":2,"title":"<code>nth(index)</code>","text":"<p>Return the nth item at index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the item to retrieve.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The item at the specified index.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n20\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def nth(self, index: int) -&gt; T:\n    \"\"\"Return the nth item at index.\n\n    Args:\n        index (int): The index of the item to retrieve.\n\n    Returns:\n        T: The item at the specified index.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n    20\n\n    ```\n    \"\"\"\n    return cz.itertoolz.nth(index, self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.reduce","level":2,"title":"<code>reduce(func)</code>","text":"<p>Apply a function of two arguments cumulatively to the items of an iterable, from left to right.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>Function to apply cumulatively to the items of the iterable.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Single value resulting from cumulative reduction.</p> <p>This effectively reduces the iterable to a single value.</p> <p>If initial is present, it is placed before the items of the iterable in the calculation.</p> <p>It then serves as a default when the iterable is empty. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n6\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def reduce(self, func: Callable[[T, T], T]) -&gt; T:\n    \"\"\"Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    Args:\n        func (Callable[[T, T], T]): Function to apply cumulatively to the items of the iterable.\n\n    Returns:\n        T: Single value resulting from cumulative reduction.\n\n    This effectively reduces the iterable to a single value.\n\n    If initial is present, it is placed before the items of the iterable in the calculation.\n\n    It then serves as a default when the iterable is empty.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n    6\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.second","level":2,"title":"<code>second()</code>","text":"<p>Return the second element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The second element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9, 8]).second()\n8\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def second(self) -&gt; T:\n    \"\"\"Return the second element.\n\n    Returns:\n        T: The second element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9, 8]).second()\n    8\n\n    ```\n    \"\"\"\n    return cz.itertoolz.second(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.sort","level":2,"title":"<code>sort(*, key=None, reverse=False)</code>","text":"<pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Vec[U]\n</code></pre><pre><code>sort(\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]],\n    reverse: bool = False,\n) -&gt; Vec[T]\n</code></pre><pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Never\n</code></pre> <p>Sort the elements of the sequence.</p> Note <p>This method must consume the entire iterable to perform the sort. The result is a new <code>Vec</code> over the sorted sequence.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsRichComparison[Any]] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in descending order. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Vec[Any]</code> <p>Vec[Any]: A <code>Vec</code> with elements sorted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\nVec(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sort(\n    self,\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n    reverse: bool = False,\n) -&gt; Vec[Any]:\n    \"\"\"Sort the elements of the sequence.\n\n    Note:\n        This method must consume the entire iterable to perform the sort.\n        The result is a new `Vec` over the sorted sequence.\n\n    Args:\n        key (Callable[[T], SupportsRichComparison[Any]] | None): Function to extract a comparison key from each element. Defaults to None.\n        reverse (bool): Whether to sort in descending order. Defaults to False.\n\n    Returns:\n        Vec[Any]: A `Vec` with elements sorted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\n    Vec(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Vec(sorted(self._inner, reverse=reverse, key=key))\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.sum","level":2,"title":"<code>sum()</code>","text":"<p>Return the sum of the <code>Iterable</code>.</p> <p>If the <code>Iterable</code> is empty, return 0.</p> <p>Returns:</p> Type Description <code>U | Literal[0]</code> <p>U | Literal[0]: The sum of all elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n6\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sum[U: SupportsSumWithNoDefaultGiven[Any]](self: BaseIter[U]) -&gt; U | Literal[0]:\n    \"\"\"Return the sum of the `Iterable`.\n\n    If the `Iterable` is empty, return 0.\n\n    Returns:\n        U | Literal[0]: The sum of all elements.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n    6\n\n    ```\n    \"\"\"\n    return sum(self._inner)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.tail","level":2,"title":"<code>tail(n)</code>","text":"<p>Return a tuple of the last n elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to return.</p> required <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the last n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def tail(self, n: int) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the last n elements.\n\n    Args:\n        n (int): Number of elements to return.\n\n    Returns:\n        Seq[T]: A new Seq containing the last n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.tail(n, self._inner))\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.top_n","level":2,"title":"<code>top_n(n, key=None)</code>","text":"<p>Return a tuple of the top-n items according to key.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of top elements to return.</p> required <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the top-n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\nSeq(3, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def top_n(self, n: int, key: Callable[[T], Any] | None = None) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the top-n items according to key.\n\n    Args:\n        n (int): Number of top elements to return.\n        key (Callable[[T], Any] | None): Function to extract a comparison key from each element. Defaults to None.\n\n    Returns:\n        Seq[T]: A new Seq containing the top-n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\n    Seq(3, 2)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.topk(n, self._inner, key=key))\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/seq/#pyochain._iter.Seq.unzip","level":2,"title":"<code>unzip()</code>","text":"<p>Converts an iterator of pairs into a pair of iterators.</p> <p>Returns:</p> Type Description <code>Unzipped[U, V]</code> <p>Unzipped[U, V]: dataclass with first and second iterators.</p> <p><code>Iter.unzip()</code> consumes the iterator of pairs.</p> <p>Returns an Unzipped dataclass, containing two iterators:</p> <ul> <li>one from the left elements of the pairs</li> <li>one from the right elements.</li> </ul> <p>This function is, in some sense, the opposite of zip. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n&gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n&gt;&gt;&gt; unzipped.left.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; unzipped.right.collect()\nSeq('a', 'b', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unzip[U, V](self: BaseIter[tuple[U, V]]) -&gt; Unzipped[U, V]:\n    \"\"\"Converts an iterator of pairs into a pair of iterators.\n\n    Returns:\n        Unzipped[U, V]: dataclass with first and second iterators.\n\n    `Iter.unzip()` consumes the iterator of pairs.\n\n    Returns an Unzipped dataclass, containing two iterators:\n\n    - one from the left elements of the pairs\n    - one from the right elements.\n\n    This function is, in some sense, the opposite of zip.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n    &gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n    &gt;&gt;&gt; unzipped.left.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; unzipped.right.collect()\n    Seq('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    d: tuple[tuple[U, V], ...] = tuple(self._inner)\n    return Unzipped(Iter(x[0] for x in d), Iter(x[1] for x in d))\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/set/","level":1,"title":"Set","text":"<p>               Bases: <code>BaseIter[T]</code>, <code>Set[T]</code></p> <p><code>Set</code> represent an in- memory unordered  collection of unique elements.</p> <p>Implements the <code>Collection</code> Protocol from <code>collections.abc</code>, so it can be used as a standard immutable collection.</p> <p>Provides a subset of <code>Iter</code> methods with eager evaluation, and is returned from some <code>Iter/Seq/Vec</code> methods.</p> <p>The underlying data structure is a <code>frozenset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The data to initialize the Set with.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Set[T](BaseIter[T], AbstractSet[T]):\n    \"\"\"`Set` represent an in- memory **unordered**  collection of **unique** elements.\n\n    Implements the `Collection` Protocol from `collections.abc`, so it can be used as a standard immutable collection.\n\n    Provides a subset of `Iter` methods with eager evaluation, and is returned from some `Iter/Seq/Vec` methods.\n\n    The underlying data structure is a `frozenset`.\n\n    Args:\n            data (Iterable[T]): The data to initialize the Set with.\n    \"\"\"\n\n    _inner: frozenset[T]\n\n    __slots__ = (\"_inner\",)\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = frozenset(data)  # pyright: ignore[reportIncompatibleVariableOverride]\n\n    def __contains__(self, item: object) -&gt; bool:\n        return self._inner.__contains__(item)\n\n    def __len__(self) -&gt; int:\n        return len(self._inner)\n\n    @overload\n    def union(self, *others: Iterable[T]) -&gt; Set[T]: ...\n    @overload\n    def union[U](self, *others: Iterable[U]) -&gt; Set[T | U]: ...\n    def union(self, *others: Iterable[Any]) -&gt; Set[Any]:\n        \"\"\"Return the union of this iterable and 'others'.\n\n        Note:\n            This method consumes inner data and removes duplicates.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to include in the union.\n\n        Returns:\n            Set[Any]: A new `Set` containing the union of elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3], [4]).iter().sort()\n        Vec(1, 2, 3, 4)\n\n        ```\n        \"\"\"\n        return self.__class__(self._inner.union(*others))\n\n    def intersection(self, *others: Iterable[Any]) -&gt; Self:\n        \"\"\"Return the elements common to this iterable and 'others'.\n\n        Is the opposite of `difference`.\n\n        See Also:\n            - `difference`\n            - `diff_symmetric`\n\n        Note:\n            This method consumes inner data, unsorts it, and removes duplicates.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to intersect with.\n\n        Returns:\n            Self: A new `Set` containing the intersection of elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).intersection([2, 3], [2])\n        Set(2,)\n\n        ```\n        \"\"\"\n        return self.__class__(self._inner.intersection(*others))\n\n    def difference(self, *others: Iterable[T]) -&gt; Self:\n        \"\"\"Return the difference of this iterable and 'others'.\n\n        See Also:\n            - `intersection`\n            - `diff_symmetric`\n\n        Note:\n            This method consumes inner data, unsorts it, and removes duplicates.\n\n        Args:\n            *others (Iterable[T]): Other iterables to subtract from this iterable.\n\n        Returns:\n            Self: A new `Set` containing the difference of elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\n        Set(1,)\n\n        ```\n        \"\"\"\n        return self.__class__(self._inner.difference(*others))\n\n    def symmetric_difference(self, *others: Iterable[T]) -&gt; Self:\n        \"\"\"Return the symmetric difference (XOR) of this iterable and 'others'.\n\n        (Elements in either 'self' or 'others' but not in both).\n\n        **See Also**:\n            - `intersection`\n            - `difference`\n\n        Note:\n            This method consumes inner data, unsorts it, and removes duplicates.\n\n        Args:\n            *others (Iterable[T]): Other iterables to compute the symmetric difference with.\n\n        Returns:\n            Self: A new `Set` containing the symmetric difference of elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\n        Vec(1, 3)\n        &gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\n        Vec(1, 2, 4, 5)\n\n        ```\n        \"\"\"\n        return self.__class__(self._inner.symmetric_difference(*others))\n\n    def is_subset(self, other: Iterable[Any]) -&gt; bool:\n        \"\"\"Test whether every element in the set is in **other**.\n\n        Args:\n            other (Iterable[Any]): Another iterable to compare with.\n\n        Returns:\n            bool: True if this set is a subset of **other**, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2}).is_subset([1, 2, 3])\n        True\n        &gt;&gt;&gt; pc.Set({1, 4}).is_subset([1, 2, 3])\n        False\n\n        ```\n        \"\"\"\n        return self._inner.issubset(other)\n\n    def is_superset(self, other: Iterable[Any]) -&gt; bool:\n        \"\"\"Test whether every element in **other** is in the set.\n\n        Args:\n            other (Iterable[Any]): Another iterable to compare with.\n\n        Returns:\n            bool: True if this set is a superset of **other**, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset([1, 2])\n        True\n        &gt;&gt;&gt; pc.Set({1, 2}).is_superset([1, 2, 3])\n        False\n\n        ```\n        \"\"\"\n        return self._inner.issuperset(other)\n\n    def is_disjoint(self, other: Iterable[Any]) -&gt; bool:\n        \"\"\"Test whether the set and **other** have no elements in common.\n\n        Args:\n            other (Iterable[Any]): Another iterable to compare with.\n\n        Returns:\n            bool: True if the sets have no elements in common, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([3, 4])\n        True\n        &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([2, 3])\n        False\n\n        ```\n        \"\"\"\n        return self._inner.isdisjoint(other)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.all","level":2,"title":"<code>all(predicate=None)</code>","text":"<p>Tests if every element of the iterator matches a predicate.</p> <p><code>Iter.all()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if they all return true, then so does <code>Iter.all()</code>.</p> <p>If any of them return false, it returns false.</p> <p>An empty iterator returns true.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements match the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, True]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 0]).all()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if every element of the iterator matches a predicate.\n\n    `Iter.all()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if they all return true, then so does `Iter.all()`.\n\n    If any of them return false, it returns false.\n\n    An empty iterator returns true.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if all elements match the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, True]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 0]).all()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return all(self._inner)\n    return all(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.all_equal","level":2,"title":"<code>all_equal(key=None)</code>","text":"<p>Return True if all items are equal.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\nTrue\n</code></pre> A function that accepts a single argument and returns a transformed version of each input item can be specified with key: <pre><code>&gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_equal[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Return True if all items are equal.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all items are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\n    True\n\n    ```\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with key:\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\n    True\n\n    ```\n    \"\"\"\n    return mit.all_equal(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.all_unique","level":2,"title":"<code>all_unique(key=None)</code>","text":"<p>Returns True if all the elements of iterable are unique.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements are unique, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\nFalse\n</code></pre> If a key function is specified, it will be used to make comparisons. <pre><code>&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\nTrue\n&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\nFalse\n</code></pre> The function returns as soon as the first non-unique element is encountered.</p> <p>Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_unique[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Returns True if all the elements of iterable are unique.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\n    False\n\n    ```\n    If a key function is specified, it will be used to make comparisons.\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\n    True\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\n    False\n\n    ```\n    The function returns as soon as the first non-unique element is encountered.\n\n    Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items\n\n    \"\"\"\n    return mit.all_unique(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.any","level":2,"title":"<code>any(predicate=None)</code>","text":"<p>Tests if any element of the iterator matches a predicate.</p> <p><code>Iter.any()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if any of them return true, then so does <code>Iter.any()</code>.</p> <p>If they all return false, it returns false.</p> <p>An empty iterator returns false.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any element matches the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([0, 1]).any()\nTrue\n&gt;&gt;&gt; pc.Seq(range(0)).any()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def any(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if any element of the iterator matches a predicate.\n\n    `Iter.any()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if any of them return true, then so does `Iter.any()`.\n\n    If they all return false, it returns false.\n\n    An empty iterator returns false.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if any element matches the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([0, 1]).any()\n    True\n    &gt;&gt;&gt; pc.Seq(range(0)).any()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return any(self._inner)\n    return any(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.argmax","level":2,"title":"<code>argmax(key=None)</code>","text":"<p>Index of the first occurrence of a maximum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the maximum value.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n7\n&gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n3\n</code></pre> For example, identify the best machine learning model: <pre><code>&gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n&gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n&gt;&gt;&gt; # Most accurate model\n&gt;&gt;&gt; models.nth(accuracy.argmax())\n'knn'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Best accuracy\n&gt;&gt;&gt; accuracy.into(max)\n84\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmax[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a maximum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the maximum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n    7\n    &gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n    3\n\n    ```\n    For example, identify the best machine learning model:\n    ```python\n    &gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n    &gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n    &gt;&gt;&gt; # Most accurate model\n    &gt;&gt;&gt; models.nth(accuracy.argmax())\n    'knn'\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Best accuracy\n    &gt;&gt;&gt; accuracy.into(max)\n    84\n\n    ```\n    \"\"\"\n    return mit.argmax(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.argmin","level":2,"title":"<code>argmin(key=None)</code>","text":"<p>Index of the first occurrence of a minimum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the minimum value.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n4\n&gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n3\n</code></pre> <p>For example, look up a label corresponding to the position of a value that minimizes a cost function: <pre><code>&gt;&gt;&gt; def cost(x):\n...     \"Days for a wound to heal given a subject's age.\"\n...     return x**2 - 20 * x + 150\n&gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n&gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n&gt;&gt;&gt; # Fastest healing family member\n&gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n'bart'\n&gt;&gt;&gt; # Age with fastest healing\n&gt;&gt;&gt; ages.into(min, key=cost)\n10\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmin[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a minimum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the minimum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n    4\n    &gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n    3\n\n    ```\n\n    For example, look up a label corresponding to the position of a value that minimizes a cost function:\n    ```python\n    &gt;&gt;&gt; def cost(x):\n    ...     \"Days for a wound to heal given a subject's age.\"\n    ...     return x**2 - 20 * x + 150\n    &gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n    &gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n    &gt;&gt;&gt; # Fastest healing family member\n    &gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n    'bart'\n    &gt;&gt;&gt; # Age with fastest healing\n    &gt;&gt;&gt; ages.into(min, key=cost)\n    10\n\n    ```\n    \"\"\"\n    return mit.argmin(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.combination_index","level":2,"title":"<code>combination_index(r)</code>","text":"<p>Computes the index of the first element, without computing the previous combinations.</p> <p>The subsequences of iterable that are of length r can be ordered lexicographically.</p> <p>ValueError will be raised if the given element isn't one of the combinations of iterable.</p> <p>Equivalent to list(combinations(iterable, r)).index(element).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>Iterable[T]</code> <p>The combination to find the index of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the combination.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n10\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combination_index(self, r: Iterable[T]) -&gt; int:\n    \"\"\"Computes the index of the first element, without computing the previous combinations.\n\n    The subsequences of iterable that are of length r can be ordered lexicographically.\n\n\n    ValueError will be raised if the given element isn't one of the combinations of iterable.\n\n    Equivalent to list(combinations(iterable, r)).index(element).\n\n    Args:\n        r (Iterable[T]): The combination to find the index of.\n\n    Returns:\n        int: The index of the combination.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n    10\n\n    ```\n    \"\"\"\n    return mit.combination_index(r, self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.difference","level":2,"title":"<code>difference(*others)</code>","text":"<p>Return the difference of this iterable and 'others'.</p> See Also <ul> <li><code>intersection</code></li> <li><code>diff_symmetric</code></li> </ul> Note <p>This method consumes inner data, unsorts it, and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to subtract from this iterable.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the difference of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\nSet(1,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def difference(self, *others: Iterable[T]) -&gt; Self:\n    \"\"\"Return the difference of this iterable and 'others'.\n\n    See Also:\n        - `intersection`\n        - `diff_symmetric`\n\n    Note:\n        This method consumes inner data, unsorts it, and removes duplicates.\n\n    Args:\n        *others (Iterable[T]): Other iterables to subtract from this iterable.\n\n    Returns:\n        Self: A new `Set` containing the difference of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\n    Set(1,)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.difference(*others))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Check if two Iterables are equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\nFalse\n&gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def eq(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\n    False\n    &gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\n    True\n\n    ```\n    \"\"\"\n    return tuple(self._inner) == tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.find","level":2,"title":"<code>find(predicate)</code>","text":"<p>Searches for an element of an iterator that satisfies a <code>predicate</code>.</p> <p>Takes a closure that returns true or false as <code>predicate</code>, and applies it to each element of the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The first element satisfying the predicate. <code>Some(value)</code> if found, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n...     return x &gt; 5\n&gt;&gt;&gt;\n&gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n...     return x &gt; 9\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\nSome(6)\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n'missing'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def find(self, predicate: Callable[[T], bool]) -&gt; Option[T]:\n    \"\"\"Searches for an element of an iterator that satisfies a `predicate`.\n\n    Takes a closure that returns true or false as `predicate`, and applies it to each element of the iterator.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Option[T]: The first element satisfying the predicate. `Some(value)` if found, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n    ...     return x &gt; 5\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n    ...     return x &gt; 9\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\n    Some(6)\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n    'missing'\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(next(filter(predicate, self._inner), None))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.first","level":2,"title":"<code>first()</code>","text":"<p>Return the first element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The first element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9]).first()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def first(self) -&gt; T:\n    \"\"\"Return the first element.\n\n    Returns:\n        T: The first element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9]).first()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.first(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.fold","level":2,"title":"<code>fold(init, func)</code>","text":"<p>Fold every element into an accumulator by applying an operation, returning the final result.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>B</code> <p>Initial value for the accumulator.</p> required <code>func</code> <code>Callable[[B, T], B]</code> <p>Function that takes the accumulator and current element, returning the new accumulator value.</p> required <p>Returns:</p> Name Type Description <code>B</code> <code>B</code> <p>The final accumulated value.</p> Note <p>This is similar to <code>reduce()</code> but with an initial value, making it equivalent to Python's <code>functools.reduce()</code> with an initializer.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n6\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n16\n&gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n'abc'\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def fold[B](self, init: B, func: Callable[[B, T], B]) -&gt; B:\n    \"\"\"Fold every element into an accumulator by applying an operation, returning the final result.\n\n    Args:\n        init (B): Initial value for the accumulator.\n        func (Callable[[B, T], B]): Function that takes the accumulator and current element,\n            returning the new accumulator value.\n\n    Returns:\n        B: The final accumulated value.\n\n    Note:\n        This is similar to `reduce()` but with an initial value, making it equivalent to\n        Python's `functools.reduce()` with an initializer.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n    6\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n    16\n    &gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n    'abc'\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner, init)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.ge","level":2,"title":"<code>ge(other)</code>","text":"<p>Check if this Iterable is greater than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ge(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.gt","level":2,"title":"<code>gt(other)</code>","text":"<p>Check if this Iterable is greater than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def gt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.intersection","level":2,"title":"<code>intersection(*others)</code>","text":"<p>Return the elements common to this iterable and 'others'.</p> <p>Is the opposite of <code>difference</code>.</p> See Also <ul> <li><code>difference</code></li> <li><code>diff_symmetric</code></li> </ul> Note <p>This method consumes inner data, unsorts it, and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to intersect with.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the intersection of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).intersection([2, 3], [2])\nSet(2,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def intersection(self, *others: Iterable[Any]) -&gt; Self:\n    \"\"\"Return the elements common to this iterable and 'others'.\n\n    Is the opposite of `difference`.\n\n    See Also:\n        - `difference`\n        - `diff_symmetric`\n\n    Note:\n        This method consumes inner data, unsorts it, and removes duplicates.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to intersect with.\n\n    Returns:\n        Self: A new `Set` containing the intersection of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).intersection([2, 3], [2])\n    Set(2,)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.intersection(*others))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.is_disjoint","level":2,"title":"<code>is_disjoint(other)</code>","text":"<p>Test whether the set and other have no elements in common.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Any]</code> <p>Another iterable to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the sets have no elements in common, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([3, 4])\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([2, 3])\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_disjoint(self, other: Iterable[Any]) -&gt; bool:\n    \"\"\"Test whether the set and **other** have no elements in common.\n\n    Args:\n        other (Iterable[Any]): Another iterable to compare with.\n\n    Returns:\n        bool: True if the sets have no elements in common, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([3, 4])\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([2, 3])\n    False\n\n    ```\n    \"\"\"\n    return self._inner.isdisjoint(other)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.is_sorted","level":2,"title":"<code>is_sorted(key=None, *, reverse=False, strict=False)</code>","text":"<p>Returns True if the items of iterable are in sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to check for descending order. Defaults to False.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Whether to enforce strict sorting (no equal elements). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if items are sorted according to the criteria, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\nTrue\n&gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\nFalse\n\nIf strict, tests for strict sorting, that is, returns False if equal elements are found:\n```python\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\nFalse\n</code></pre></p> <p>The function returns False after encountering the first out-of-order item.</p> <p>This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).</p> <p>If there are no out-of-order items, the iterable is exhausted.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_sorted[U](\n    self,\n    key: Callable[[T], U] | None = None,\n    *,\n    reverse: bool = False,\n    strict: bool = False,\n) -&gt; bool:\n    \"\"\"Returns True if the items of iterable are in sorted order.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n        reverse (bool): Whether to check for descending order. Defaults to False.\n        strict (bool): Whether to enforce strict sorting (no equal elements). Defaults to False.\n\n    Returns:\n        bool: True if items are sorted according to the criteria, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\n    True\n    &gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\n    False\n\n    If strict, tests for strict sorting, that is, returns False if equal elements are found:\n    ```python\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\n    False\n\n    ```\n\n    The function returns False after encountering the first out-of-order item.\n\n    This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).\n\n    If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n    return mit.is_sorted(self._inner, key=key, reverse=reverse, strict=strict)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.is_subset","level":2,"title":"<code>is_subset(other)</code>","text":"<p>Test whether every element in the set is in other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Any]</code> <p>Another iterable to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this set is a subset of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).is_subset([1, 2, 3])\nTrue\n&gt;&gt;&gt; pc.Set({1, 4}).is_subset([1, 2, 3])\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_subset(self, other: Iterable[Any]) -&gt; bool:\n    \"\"\"Test whether every element in the set is in **other**.\n\n    Args:\n        other (Iterable[Any]): Another iterable to compare with.\n\n    Returns:\n        bool: True if this set is a subset of **other**, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).is_subset([1, 2, 3])\n    True\n    &gt;&gt;&gt; pc.Set({1, 4}).is_subset([1, 2, 3])\n    False\n\n    ```\n    \"\"\"\n    return self._inner.issubset(other)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.is_superset","level":2,"title":"<code>is_superset(other)</code>","text":"<p>Test whether every element in other is in the set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Any]</code> <p>Another iterable to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this set is a superset of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset([1, 2])\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).is_superset([1, 2, 3])\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_superset(self, other: Iterable[Any]) -&gt; bool:\n    \"\"\"Test whether every element in **other** is in the set.\n\n    Args:\n        other (Iterable[Any]): Another iterable to compare with.\n\n    Returns:\n        bool: True if this set is a superset of **other**, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset([1, 2])\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).is_superset([1, 2, 3])\n    False\n\n    ```\n    \"\"\"\n    return self._inner.issuperset(other)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.iter","level":2,"title":"<code>iter()</code>","text":"<p>Get an iterator over the <code>Iterable</code>.</p> <p>Call this to switch to lazy evaluation.</p> <p>Calling this method on an <code>Iter</code> instance has no effect.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> over the <code>Iterable</code>.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Get an iterator over the `Iterable`.\n\n    Call this to switch to lazy evaluation.\n\n    Calling this method on an `Iter` instance has no effect.\n\n    Returns:\n        Iter[T]: An `Iterator` over the `Iterable`.\n    \"\"\"\n    return Iter(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.join","level":2,"title":"<code>join(sep)</code>","text":"<p>Join all elements of the <code>Iterable</code> into a single <code>string</code>, with a specified separator.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>str</code> <p>Separator to use between elements.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The joined string.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n'a-b-c'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def join(self: BaseIter[str], sep: str) -&gt; str:\n    \"\"\"Join all elements of the `Iterable` into a single `string`, with a specified separator.\n\n    Args:\n        sep (str): Separator to use between elements.\n\n    Returns:\n        str: The joined string.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n    'a-b-c'\n\n    ```\n    \"\"\"\n    return sep.join(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.last","level":2,"title":"<code>last()</code>","text":"<p>Return the last element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The last element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def last(self) -&gt; T:\n    \"\"\"Return the last element.\n\n    Returns:\n        T: The last element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.last(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.le","level":2,"title":"<code>le(other)</code>","text":"<p>Check if this Iterable is less than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def le(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.length","level":2,"title":"<code>length()</code>","text":"<p>Return the length of the Iterable.</p> <p>Like the builtin len but works on lazy sequences.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The count of elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).length()\n2\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def length(self) -&gt; int:\n    \"\"\"Return the length of the Iterable.\n\n    Like the builtin len but works on lazy sequences.\n\n    Returns:\n        int: The count of elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).length()\n    2\n\n    ```\n    \"\"\"\n    return cz.itertoolz.count(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.lt","level":2,"title":"<code>lt(other)</code>","text":"<p>Check if this Iterable is less than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def lt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.max","level":2,"title":"<code>max()</code>","text":"<p>Return the maximum of the <code>Iterable</code>.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>max_by()</code> instead.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The maximum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n3\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the maximum of the `Iterable`.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `max_by()` instead.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Returns:\n        U: The maximum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n    3\n\n    ```\n    \"\"\"\n    return max(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.max_by","level":2,"title":"<code>max_by(*, key)</code>","text":"<p>Return the maximum element using a custom key function.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the maximum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=4, y='c')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=3, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the maximum element using a custom **key** function.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the maximum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=4, y='c')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=3, y='b')\n\n    ```\n    \"\"\"\n    return max(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.min","level":2,"title":"<code>min()</code>","text":"<p>Return the minimum of the sequence.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>min_by()</code> instead.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The minimum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n1\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the minimum of the sequence.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `min_by()` instead.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Returns:\n        U: The minimum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n    1\n\n    ```\n    \"\"\"\n    return min(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.min_by","level":2,"title":"<code>min_by(*, key)</code>","text":"<p>Return the minimum element using a custom key function.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the minimum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the minimum element using a custom **key** function.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the minimum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n\n    ```\n    \"\"\"\n    return min(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.most_common","level":2,"title":"<code>most_common(n=None)</code>","text":"<p>Return the n most common elements and their counts.</p> <p>If n is None, then all elements are returned.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of most common elements to return. Defaults to None (all elements).</p> <code>None</code> <p>Returns:</p> Type Description <code>Vec[tuple[T, int]]</code> <p>Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\nVec((3, 3), (1, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def most_common(self, n: int | None = None) -&gt; Vec[tuple[T, int]]:\n    \"\"\"Return the n most common elements and their counts.\n\n    If n is None, then all elements are returned.\n\n    Args:\n        n (int | None): Number of most common elements to return. Defaults to None (all elements).\n\n    Returns:\n        Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\n    Vec((3, 3), (1, 2))\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return Vec(Counter(self._inner).most_common(n))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.ne","level":2,"title":"<code>ne(other)</code>","text":"<p>Check if two Iterables are not equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are not equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ne(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are not equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are not equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) != tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.nth","level":2,"title":"<code>nth(index)</code>","text":"<p>Return the nth item at index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the item to retrieve.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The item at the specified index.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n20\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def nth(self, index: int) -&gt; T:\n    \"\"\"Return the nth item at index.\n\n    Args:\n        index (int): The index of the item to retrieve.\n\n    Returns:\n        T: The item at the specified index.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n    20\n\n    ```\n    \"\"\"\n    return cz.itertoolz.nth(index, self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.reduce","level":2,"title":"<code>reduce(func)</code>","text":"<p>Apply a function of two arguments cumulatively to the items of an iterable, from left to right.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>Function to apply cumulatively to the items of the iterable.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Single value resulting from cumulative reduction.</p> <p>This effectively reduces the iterable to a single value.</p> <p>If initial is present, it is placed before the items of the iterable in the calculation.</p> <p>It then serves as a default when the iterable is empty. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n6\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def reduce(self, func: Callable[[T, T], T]) -&gt; T:\n    \"\"\"Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    Args:\n        func (Callable[[T, T], T]): Function to apply cumulatively to the items of the iterable.\n\n    Returns:\n        T: Single value resulting from cumulative reduction.\n\n    This effectively reduces the iterable to a single value.\n\n    If initial is present, it is placed before the items of the iterable in the calculation.\n\n    It then serves as a default when the iterable is empty.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n    6\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.second","level":2,"title":"<code>second()</code>","text":"<p>Return the second element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The second element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9, 8]).second()\n8\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def second(self) -&gt; T:\n    \"\"\"Return the second element.\n\n    Returns:\n        T: The second element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9, 8]).second()\n    8\n\n    ```\n    \"\"\"\n    return cz.itertoolz.second(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.sort","level":2,"title":"<code>sort(*, key=None, reverse=False)</code>","text":"<pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Vec[U]\n</code></pre><pre><code>sort(\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]],\n    reverse: bool = False,\n) -&gt; Vec[T]\n</code></pre><pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Never\n</code></pre> <p>Sort the elements of the sequence.</p> Note <p>This method must consume the entire iterable to perform the sort. The result is a new <code>Vec</code> over the sorted sequence.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsRichComparison[Any]] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in descending order. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Vec[Any]</code> <p>Vec[Any]: A <code>Vec</code> with elements sorted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\nVec(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sort(\n    self,\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n    reverse: bool = False,\n) -&gt; Vec[Any]:\n    \"\"\"Sort the elements of the sequence.\n\n    Note:\n        This method must consume the entire iterable to perform the sort.\n        The result is a new `Vec` over the sorted sequence.\n\n    Args:\n        key (Callable[[T], SupportsRichComparison[Any]] | None): Function to extract a comparison key from each element. Defaults to None.\n        reverse (bool): Whether to sort in descending order. Defaults to False.\n\n    Returns:\n        Vec[Any]: A `Vec` with elements sorted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\n    Vec(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Vec(sorted(self._inner, reverse=reverse, key=key))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.sum","level":2,"title":"<code>sum()</code>","text":"<p>Return the sum of the <code>Iterable</code>.</p> <p>If the <code>Iterable</code> is empty, return 0.</p> <p>Returns:</p> Type Description <code>U | Literal[0]</code> <p>U | Literal[0]: The sum of all elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n6\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sum[U: SupportsSumWithNoDefaultGiven[Any]](self: BaseIter[U]) -&gt; U | Literal[0]:\n    \"\"\"Return the sum of the `Iterable`.\n\n    If the `Iterable` is empty, return 0.\n\n    Returns:\n        U | Literal[0]: The sum of all elements.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n    6\n\n    ```\n    \"\"\"\n    return sum(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.symmetric_difference","level":2,"title":"<code>symmetric_difference(*others)</code>","text":"<p>Return the symmetric difference (XOR) of this iterable and 'others'.</p> <p>(Elements in either 'self' or 'others' but not in both).</p> <p>See Also:     - <code>intersection</code>     - <code>difference</code></p> Note <p>This method consumes inner data, unsorts it, and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to compute the symmetric difference with.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the symmetric difference of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\nVec(1, 3)\n&gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\nVec(1, 2, 4, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def symmetric_difference(self, *others: Iterable[T]) -&gt; Self:\n    \"\"\"Return the symmetric difference (XOR) of this iterable and 'others'.\n\n    (Elements in either 'self' or 'others' but not in both).\n\n    **See Also**:\n        - `intersection`\n        - `difference`\n\n    Note:\n        This method consumes inner data, unsorts it, and removes duplicates.\n\n    Args:\n        *others (Iterable[T]): Other iterables to compute the symmetric difference with.\n\n    Returns:\n        Self: A new `Set` containing the symmetric difference of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\n    Vec(1, 3)\n    &gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\n    Vec(1, 2, 4, 5)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.symmetric_difference(*others))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.tail","level":2,"title":"<code>tail(n)</code>","text":"<p>Return a tuple of the last n elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to return.</p> required <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the last n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def tail(self, n: int) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the last n elements.\n\n    Args:\n        n (int): Number of elements to return.\n\n    Returns:\n        Seq[T]: A new Seq containing the last n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.tail(n, self._inner))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.top_n","level":2,"title":"<code>top_n(n, key=None)</code>","text":"<p>Return a tuple of the top-n items according to key.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of top elements to return.</p> required <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the top-n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\nSeq(3, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def top_n(self, n: int, key: Callable[[T], Any] | None = None) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the top-n items according to key.\n\n    Args:\n        n (int): Number of top elements to return.\n        key (Callable[[T], Any] | None): Function to extract a comparison key from each element. Defaults to None.\n\n    Returns:\n        Seq[T]: A new Seq containing the top-n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\n    Seq(3, 2)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.topk(n, self._inner, key=key))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.union","level":2,"title":"<code>union(*others)</code>","text":"<pre><code>union(*others: Iterable[T]) -&gt; Set[T]\n</code></pre><pre><code>union(*others: Iterable[U]) -&gt; Set[T | U]\n</code></pre> <p>Return the union of this iterable and 'others'.</p> Note <p>This method consumes inner data and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to include in the union.</p> <code>()</code> <p>Returns:</p> Type Description <code>Set[Any]</code> <p>Set[Any]: A new <code>Set</code> containing the union of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3], [4]).iter().sort()\nVec(1, 2, 3, 4)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def union(self, *others: Iterable[Any]) -&gt; Set[Any]:\n    \"\"\"Return the union of this iterable and 'others'.\n\n    Note:\n        This method consumes inner data and removes duplicates.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to include in the union.\n\n    Returns:\n        Set[Any]: A new `Set` containing the union of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3], [4]).iter().sort()\n    Vec(1, 2, 3, 4)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.union(*others))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/set/#pyochain._iter.Set.unzip","level":2,"title":"<code>unzip()</code>","text":"<p>Converts an iterator of pairs into a pair of iterators.</p> <p>Returns:</p> Type Description <code>Unzipped[U, V]</code> <p>Unzipped[U, V]: dataclass with first and second iterators.</p> <p><code>Iter.unzip()</code> consumes the iterator of pairs.</p> <p>Returns an Unzipped dataclass, containing two iterators:</p> <ul> <li>one from the left elements of the pairs</li> <li>one from the right elements.</li> </ul> <p>This function is, in some sense, the opposite of zip. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n&gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n&gt;&gt;&gt; unzipped.left.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; unzipped.right.collect()\nSeq('a', 'b', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unzip[U, V](self: BaseIter[tuple[U, V]]) -&gt; Unzipped[U, V]:\n    \"\"\"Converts an iterator of pairs into a pair of iterators.\n\n    Returns:\n        Unzipped[U, V]: dataclass with first and second iterators.\n\n    `Iter.unzip()` consumes the iterator of pairs.\n\n    Returns an Unzipped dataclass, containing two iterators:\n\n    - one from the left elements of the pairs\n    - one from the right elements.\n\n    This function is, in some sense, the opposite of zip.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n    &gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n    &gt;&gt;&gt; unzipped.left.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; unzipped.right.collect()\n    Seq('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    d: tuple[tuple[U, V], ...] = tuple(self._inner)\n    return Unzipped(Iter(x[0] for x in d), Iter(x[1] for x in d))\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/setmut/","level":1,"title":"SetMut","text":"<p>               Bases: <code>Set[T]</code>, <code>MutableSet[T]</code></p> <p>A mutable set wrapper with functional API.</p> <p>Unlike <code>Set</code> which is immutable, <code>SetMut</code> allows in-place modification of elements.</p> <p>Implement the <code>MutableSet</code> interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable set.</p> <p>Underlying data structure is a <code>set</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The mutable set to wrap.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class SetMut[T](Set[T], MutableSet[T]):\n    \"\"\"A mutable set wrapper with functional API.\n\n    Unlike `Set` which is immutable, `SetMut` allows in-place modification of elements.\n\n    Implement the `MutableSet` interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable set.\n\n    Underlying data structure is a `set`.\n\n    Args:\n        data (Iterable[T]): The mutable set to wrap.\n    \"\"\"\n\n    _inner: set[T]\n    __slots__ = (\"_inner\",)\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = set(data)  # type: ignore[override]\n\n    @classmethod\n    def new(cls) -&gt; Self:\n        \"\"\"Create an empty `SetMut`.\n\n        Make sure to specify the type when calling this method, e.g., `SetMut[int].new()`.\n\n        Otherwise, `T` will be inferred as `Any`.\n\n        Returns:\n            Self: A new empty SetMut instance.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.SetMut[object].new()\n        SetMut()\n\n        ```\n        \"\"\"\n        return cls([])\n\n    def add(self, value: T) -&gt; None:\n        \"\"\"Add an element to the set.\n\n        Args:\n            value (T): The element to add.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; s = pc.SetMut({'a', 'b'})\n        &gt;&gt;&gt; s.add('c')\n        &gt;&gt;&gt; s.iter().sort()\n        Vec('a', 'b', 'c')\n\n        ```\n        \"\"\"\n        self._inner.add(value)\n\n    def discard(self, value: T) -&gt; None:\n        \"\"\"Remove an element from the set if it is a member.\n\n        Unlike `.remove()`, the `discard()` method does not raise an exception when an element is missing from the set.\n\n        Args:\n            value (T): The element to remove.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; s = pc.SetMut({'a', 'b', 'c'})\n        &gt;&gt;&gt; s.discard('b')\n        &gt;&gt;&gt; s.iter().sort()\n        Vec('a', 'c')\n\n        ```\n        \"\"\"\n        self._inner.discard(value)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.add","level":2,"title":"<code>add(value)</code>","text":"<p>Add an element to the set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The element to add.</p> required <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; s = pc.SetMut({'a', 'b'})\n&gt;&gt;&gt; s.add('c')\n&gt;&gt;&gt; s.iter().sort()\nVec('a', 'b', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def add(self, value: T) -&gt; None:\n    \"\"\"Add an element to the set.\n\n    Args:\n        value (T): The element to add.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; s = pc.SetMut({'a', 'b'})\n    &gt;&gt;&gt; s.add('c')\n    &gt;&gt;&gt; s.iter().sort()\n    Vec('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    self._inner.add(value)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.all","level":2,"title":"<code>all(predicate=None)</code>","text":"<p>Tests if every element of the iterator matches a predicate.</p> <p><code>Iter.all()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if they all return true, then so does <code>Iter.all()</code>.</p> <p>If any of them return false, it returns false.</p> <p>An empty iterator returns true.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements match the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, True]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 0]).all()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if every element of the iterator matches a predicate.\n\n    `Iter.all()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if they all return true, then so does `Iter.all()`.\n\n    If any of them return false, it returns false.\n\n    An empty iterator returns true.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if all elements match the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, True]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 0]).all()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return all(self._inner)\n    return all(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.all_equal","level":2,"title":"<code>all_equal(key=None)</code>","text":"<p>Return True if all items are equal.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\nTrue\n</code></pre> A function that accepts a single argument and returns a transformed version of each input item can be specified with key: <pre><code>&gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_equal[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Return True if all items are equal.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all items are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\n    True\n\n    ```\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with key:\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\n    True\n\n    ```\n    \"\"\"\n    return mit.all_equal(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.all_unique","level":2,"title":"<code>all_unique(key=None)</code>","text":"<p>Returns True if all the elements of iterable are unique.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements are unique, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\nFalse\n</code></pre> If a key function is specified, it will be used to make comparisons. <pre><code>&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\nTrue\n&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\nFalse\n</code></pre> The function returns as soon as the first non-unique element is encountered.</p> <p>Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_unique[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Returns True if all the elements of iterable are unique.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\n    False\n\n    ```\n    If a key function is specified, it will be used to make comparisons.\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\n    True\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\n    False\n\n    ```\n    The function returns as soon as the first non-unique element is encountered.\n\n    Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items\n\n    \"\"\"\n    return mit.all_unique(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.any","level":2,"title":"<code>any(predicate=None)</code>","text":"<p>Tests if any element of the iterator matches a predicate.</p> <p><code>Iter.any()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if any of them return true, then so does <code>Iter.any()</code>.</p> <p>If they all return false, it returns false.</p> <p>An empty iterator returns false.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any element matches the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([0, 1]).any()\nTrue\n&gt;&gt;&gt; pc.Seq(range(0)).any()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def any(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if any element of the iterator matches a predicate.\n\n    `Iter.any()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if any of them return true, then so does `Iter.any()`.\n\n    If they all return false, it returns false.\n\n    An empty iterator returns false.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if any element matches the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([0, 1]).any()\n    True\n    &gt;&gt;&gt; pc.Seq(range(0)).any()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return any(self._inner)\n    return any(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.argmax","level":2,"title":"<code>argmax(key=None)</code>","text":"<p>Index of the first occurrence of a maximum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the maximum value.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n7\n&gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n3\n</code></pre> For example, identify the best machine learning model: <pre><code>&gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n&gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n&gt;&gt;&gt; # Most accurate model\n&gt;&gt;&gt; models.nth(accuracy.argmax())\n'knn'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Best accuracy\n&gt;&gt;&gt; accuracy.into(max)\n84\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmax[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a maximum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the maximum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n    7\n    &gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n    3\n\n    ```\n    For example, identify the best machine learning model:\n    ```python\n    &gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n    &gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n    &gt;&gt;&gt; # Most accurate model\n    &gt;&gt;&gt; models.nth(accuracy.argmax())\n    'knn'\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Best accuracy\n    &gt;&gt;&gt; accuracy.into(max)\n    84\n\n    ```\n    \"\"\"\n    return mit.argmax(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.argmin","level":2,"title":"<code>argmin(key=None)</code>","text":"<p>Index of the first occurrence of a minimum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the minimum value.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n4\n&gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n3\n</code></pre> <p>For example, look up a label corresponding to the position of a value that minimizes a cost function: <pre><code>&gt;&gt;&gt; def cost(x):\n...     \"Days for a wound to heal given a subject's age.\"\n...     return x**2 - 20 * x + 150\n&gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n&gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n&gt;&gt;&gt; # Fastest healing family member\n&gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n'bart'\n&gt;&gt;&gt; # Age with fastest healing\n&gt;&gt;&gt; ages.into(min, key=cost)\n10\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmin[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a minimum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the minimum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n    4\n    &gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n    3\n\n    ```\n\n    For example, look up a label corresponding to the position of a value that minimizes a cost function:\n    ```python\n    &gt;&gt;&gt; def cost(x):\n    ...     \"Days for a wound to heal given a subject's age.\"\n    ...     return x**2 - 20 * x + 150\n    &gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n    &gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n    &gt;&gt;&gt; # Fastest healing family member\n    &gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n    'bart'\n    &gt;&gt;&gt; # Age with fastest healing\n    &gt;&gt;&gt; ages.into(min, key=cost)\n    10\n\n    ```\n    \"\"\"\n    return mit.argmin(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.combination_index","level":2,"title":"<code>combination_index(r)</code>","text":"<p>Computes the index of the first element, without computing the previous combinations.</p> <p>The subsequences of iterable that are of length r can be ordered lexicographically.</p> <p>ValueError will be raised if the given element isn't one of the combinations of iterable.</p> <p>Equivalent to list(combinations(iterable, r)).index(element).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>Iterable[T]</code> <p>The combination to find the index of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the combination.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n10\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combination_index(self, r: Iterable[T]) -&gt; int:\n    \"\"\"Computes the index of the first element, without computing the previous combinations.\n\n    The subsequences of iterable that are of length r can be ordered lexicographically.\n\n\n    ValueError will be raised if the given element isn't one of the combinations of iterable.\n\n    Equivalent to list(combinations(iterable, r)).index(element).\n\n    Args:\n        r (Iterable[T]): The combination to find the index of.\n\n    Returns:\n        int: The index of the combination.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n    10\n\n    ```\n    \"\"\"\n    return mit.combination_index(r, self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.difference","level":2,"title":"<code>difference(*others)</code>","text":"<p>Return the difference of this iterable and 'others'.</p> See Also <ul> <li><code>intersection</code></li> <li><code>diff_symmetric</code></li> </ul> Note <p>This method consumes inner data, unsorts it, and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to subtract from this iterable.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the difference of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\nSet(1,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def difference(self, *others: Iterable[T]) -&gt; Self:\n    \"\"\"Return the difference of this iterable and 'others'.\n\n    See Also:\n        - `intersection`\n        - `diff_symmetric`\n\n    Note:\n        This method consumes inner data, unsorts it, and removes duplicates.\n\n    Args:\n        *others (Iterable[T]): Other iterables to subtract from this iterable.\n\n    Returns:\n        Self: A new `Set` containing the difference of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\n    Set(1,)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.difference(*others))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.discard","level":2,"title":"<code>discard(value)</code>","text":"<p>Remove an element from the set if it is a member.</p> <p>Unlike <code>.remove()</code>, the <code>discard()</code> method does not raise an exception when an element is missing from the set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The element to remove.</p> required <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; s = pc.SetMut({'a', 'b', 'c'})\n&gt;&gt;&gt; s.discard('b')\n&gt;&gt;&gt; s.iter().sort()\nVec('a', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def discard(self, value: T) -&gt; None:\n    \"\"\"Remove an element from the set if it is a member.\n\n    Unlike `.remove()`, the `discard()` method does not raise an exception when an element is missing from the set.\n\n    Args:\n        value (T): The element to remove.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; s = pc.SetMut({'a', 'b', 'c'})\n    &gt;&gt;&gt; s.discard('b')\n    &gt;&gt;&gt; s.iter().sort()\n    Vec('a', 'c')\n\n    ```\n    \"\"\"\n    self._inner.discard(value)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Check if two Iterables are equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\nFalse\n&gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def eq(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\n    False\n    &gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\n    True\n\n    ```\n    \"\"\"\n    return tuple(self._inner) == tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.find","level":2,"title":"<code>find(predicate)</code>","text":"<p>Searches for an element of an iterator that satisfies a <code>predicate</code>.</p> <p>Takes a closure that returns true or false as <code>predicate</code>, and applies it to each element of the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The first element satisfying the predicate. <code>Some(value)</code> if found, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n...     return x &gt; 5\n&gt;&gt;&gt;\n&gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n...     return x &gt; 9\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\nSome(6)\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n'missing'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def find(self, predicate: Callable[[T], bool]) -&gt; Option[T]:\n    \"\"\"Searches for an element of an iterator that satisfies a `predicate`.\n\n    Takes a closure that returns true or false as `predicate`, and applies it to each element of the iterator.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Option[T]: The first element satisfying the predicate. `Some(value)` if found, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n    ...     return x &gt; 5\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n    ...     return x &gt; 9\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\n    Some(6)\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n    'missing'\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(next(filter(predicate, self._inner), None))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.first","level":2,"title":"<code>first()</code>","text":"<p>Return the first element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The first element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9]).first()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def first(self) -&gt; T:\n    \"\"\"Return the first element.\n\n    Returns:\n        T: The first element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9]).first()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.first(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.fold","level":2,"title":"<code>fold(init, func)</code>","text":"<p>Fold every element into an accumulator by applying an operation, returning the final result.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>B</code> <p>Initial value for the accumulator.</p> required <code>func</code> <code>Callable[[B, T], B]</code> <p>Function that takes the accumulator and current element, returning the new accumulator value.</p> required <p>Returns:</p> Name Type Description <code>B</code> <code>B</code> <p>The final accumulated value.</p> Note <p>This is similar to <code>reduce()</code> but with an initial value, making it equivalent to Python's <code>functools.reduce()</code> with an initializer.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n6\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n16\n&gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n'abc'\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def fold[B](self, init: B, func: Callable[[B, T], B]) -&gt; B:\n    \"\"\"Fold every element into an accumulator by applying an operation, returning the final result.\n\n    Args:\n        init (B): Initial value for the accumulator.\n        func (Callable[[B, T], B]): Function that takes the accumulator and current element,\n            returning the new accumulator value.\n\n    Returns:\n        B: The final accumulated value.\n\n    Note:\n        This is similar to `reduce()` but with an initial value, making it equivalent to\n        Python's `functools.reduce()` with an initializer.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n    6\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n    16\n    &gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n    'abc'\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner, init)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.ge","level":2,"title":"<code>ge(other)</code>","text":"<p>Check if this Iterable is greater than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ge(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.gt","level":2,"title":"<code>gt(other)</code>","text":"<p>Check if this Iterable is greater than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def gt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.intersection","level":2,"title":"<code>intersection(*others)</code>","text":"<p>Return the elements common to this iterable and 'others'.</p> <p>Is the opposite of <code>difference</code>.</p> See Also <ul> <li><code>difference</code></li> <li><code>diff_symmetric</code></li> </ul> Note <p>This method consumes inner data, unsorts it, and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to intersect with.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the intersection of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).intersection([2, 3], [2])\nSet(2,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def intersection(self, *others: Iterable[Any]) -&gt; Self:\n    \"\"\"Return the elements common to this iterable and 'others'.\n\n    Is the opposite of `difference`.\n\n    See Also:\n        - `difference`\n        - `diff_symmetric`\n\n    Note:\n        This method consumes inner data, unsorts it, and removes duplicates.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to intersect with.\n\n    Returns:\n        Self: A new `Set` containing the intersection of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).intersection([2, 3], [2])\n    Set(2,)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.intersection(*others))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.is_disjoint","level":2,"title":"<code>is_disjoint(other)</code>","text":"<p>Test whether the set and other have no elements in common.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Any]</code> <p>Another iterable to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the sets have no elements in common, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([3, 4])\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([2, 3])\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_disjoint(self, other: Iterable[Any]) -&gt; bool:\n    \"\"\"Test whether the set and **other** have no elements in common.\n\n    Args:\n        other (Iterable[Any]): Another iterable to compare with.\n\n    Returns:\n        bool: True if the sets have no elements in common, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([3, 4])\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint([2, 3])\n    False\n\n    ```\n    \"\"\"\n    return self._inner.isdisjoint(other)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.is_sorted","level":2,"title":"<code>is_sorted(key=None, *, reverse=False, strict=False)</code>","text":"<p>Returns True if the items of iterable are in sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to check for descending order. Defaults to False.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Whether to enforce strict sorting (no equal elements). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if items are sorted according to the criteria, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\nTrue\n&gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\nFalse\n\nIf strict, tests for strict sorting, that is, returns False if equal elements are found:\n```python\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\nFalse\n</code></pre></p> <p>The function returns False after encountering the first out-of-order item.</p> <p>This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).</p> <p>If there are no out-of-order items, the iterable is exhausted.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_sorted[U](\n    self,\n    key: Callable[[T], U] | None = None,\n    *,\n    reverse: bool = False,\n    strict: bool = False,\n) -&gt; bool:\n    \"\"\"Returns True if the items of iterable are in sorted order.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n        reverse (bool): Whether to check for descending order. Defaults to False.\n        strict (bool): Whether to enforce strict sorting (no equal elements). Defaults to False.\n\n    Returns:\n        bool: True if items are sorted according to the criteria, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\n    True\n    &gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\n    False\n\n    If strict, tests for strict sorting, that is, returns False if equal elements are found:\n    ```python\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\n    False\n\n    ```\n\n    The function returns False after encountering the first out-of-order item.\n\n    This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).\n\n    If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n    return mit.is_sorted(self._inner, key=key, reverse=reverse, strict=strict)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.is_subset","level":2,"title":"<code>is_subset(other)</code>","text":"<p>Test whether every element in the set is in other.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Any]</code> <p>Another iterable to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this set is a subset of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).is_subset([1, 2, 3])\nTrue\n&gt;&gt;&gt; pc.Set({1, 4}).is_subset([1, 2, 3])\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_subset(self, other: Iterable[Any]) -&gt; bool:\n    \"\"\"Test whether every element in the set is in **other**.\n\n    Args:\n        other (Iterable[Any]): Another iterable to compare with.\n\n    Returns:\n        bool: True if this set is a subset of **other**, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).is_subset([1, 2, 3])\n    True\n    &gt;&gt;&gt; pc.Set({1, 4}).is_subset([1, 2, 3])\n    False\n\n    ```\n    \"\"\"\n    return self._inner.issubset(other)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.is_superset","level":2,"title":"<code>is_superset(other)</code>","text":"<p>Test whether every element in other is in the set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[Any]</code> <p>Another iterable to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this set is a superset of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset([1, 2])\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).is_superset([1, 2, 3])\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_superset(self, other: Iterable[Any]) -&gt; bool:\n    \"\"\"Test whether every element in **other** is in the set.\n\n    Args:\n        other (Iterable[Any]): Another iterable to compare with.\n\n    Returns:\n        bool: True if this set is a superset of **other**, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset([1, 2])\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).is_superset([1, 2, 3])\n    False\n\n    ```\n    \"\"\"\n    return self._inner.issuperset(other)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.iter","level":2,"title":"<code>iter()</code>","text":"<p>Get an iterator over the <code>Iterable</code>.</p> <p>Call this to switch to lazy evaluation.</p> <p>Calling this method on an <code>Iter</code> instance has no effect.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> over the <code>Iterable</code>.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Get an iterator over the `Iterable`.\n\n    Call this to switch to lazy evaluation.\n\n    Calling this method on an `Iter` instance has no effect.\n\n    Returns:\n        Iter[T]: An `Iterator` over the `Iterable`.\n    \"\"\"\n    return Iter(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.join","level":2,"title":"<code>join(sep)</code>","text":"<p>Join all elements of the <code>Iterable</code> into a single <code>string</code>, with a specified separator.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>str</code> <p>Separator to use between elements.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The joined string.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n'a-b-c'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def join(self: BaseIter[str], sep: str) -&gt; str:\n    \"\"\"Join all elements of the `Iterable` into a single `string`, with a specified separator.\n\n    Args:\n        sep (str): Separator to use between elements.\n\n    Returns:\n        str: The joined string.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n    'a-b-c'\n\n    ```\n    \"\"\"\n    return sep.join(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.last","level":2,"title":"<code>last()</code>","text":"<p>Return the last element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The last element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def last(self) -&gt; T:\n    \"\"\"Return the last element.\n\n    Returns:\n        T: The last element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.last(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.le","level":2,"title":"<code>le(other)</code>","text":"<p>Check if this Iterable is less than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def le(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.length","level":2,"title":"<code>length()</code>","text":"<p>Return the length of the Iterable.</p> <p>Like the builtin len but works on lazy sequences.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The count of elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).length()\n2\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def length(self) -&gt; int:\n    \"\"\"Return the length of the Iterable.\n\n    Like the builtin len but works on lazy sequences.\n\n    Returns:\n        int: The count of elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).length()\n    2\n\n    ```\n    \"\"\"\n    return cz.itertoolz.count(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.lt","level":2,"title":"<code>lt(other)</code>","text":"<p>Check if this Iterable is less than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def lt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.max","level":2,"title":"<code>max()</code>","text":"<p>Return the maximum of the <code>Iterable</code>.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>max_by()</code> instead.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The maximum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n3\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the maximum of the `Iterable`.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `max_by()` instead.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Returns:\n        U: The maximum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n    3\n\n    ```\n    \"\"\"\n    return max(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.max_by","level":2,"title":"<code>max_by(*, key)</code>","text":"<p>Return the maximum element using a custom key function.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the maximum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=4, y='c')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=3, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the maximum element using a custom **key** function.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the maximum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=4, y='c')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=3, y='b')\n\n    ```\n    \"\"\"\n    return max(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.min","level":2,"title":"<code>min()</code>","text":"<p>Return the minimum of the sequence.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>min_by()</code> instead.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The minimum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n1\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the minimum of the sequence.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `min_by()` instead.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Returns:\n        U: The minimum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n    1\n\n    ```\n    \"\"\"\n    return min(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.min_by","level":2,"title":"<code>min_by(*, key)</code>","text":"<p>Return the minimum element using a custom key function.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the minimum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the minimum element using a custom **key** function.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the minimum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n\n    ```\n    \"\"\"\n    return min(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.most_common","level":2,"title":"<code>most_common(n=None)</code>","text":"<p>Return the n most common elements and their counts.</p> <p>If n is None, then all elements are returned.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of most common elements to return. Defaults to None (all elements).</p> <code>None</code> <p>Returns:</p> Type Description <code>Vec[tuple[T, int]]</code> <p>Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\nVec((3, 3), (1, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def most_common(self, n: int | None = None) -&gt; Vec[tuple[T, int]]:\n    \"\"\"Return the n most common elements and their counts.\n\n    If n is None, then all elements are returned.\n\n    Args:\n        n (int | None): Number of most common elements to return. Defaults to None (all elements).\n\n    Returns:\n        Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\n    Vec((3, 3), (1, 2))\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return Vec(Counter(self._inner).most_common(n))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.ne","level":2,"title":"<code>ne(other)</code>","text":"<p>Check if two Iterables are not equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are not equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ne(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are not equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are not equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) != tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.new","level":2,"title":"<code>new()</code>  <code>classmethod</code>","text":"<p>Create an empty <code>SetMut</code>.</p> <p>Make sure to specify the type when calling this method, e.g., <code>SetMut[int].new()</code>.</p> <p>Otherwise, <code>T</code> will be inferred as <code>Any</code>.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new empty SetMut instance.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.SetMut[object].new()\nSetMut()\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@classmethod\ndef new(cls) -&gt; Self:\n    \"\"\"Create an empty `SetMut`.\n\n    Make sure to specify the type when calling this method, e.g., `SetMut[int].new()`.\n\n    Otherwise, `T` will be inferred as `Any`.\n\n    Returns:\n        Self: A new empty SetMut instance.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.SetMut[object].new()\n    SetMut()\n\n    ```\n    \"\"\"\n    return cls([])\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.nth","level":2,"title":"<code>nth(index)</code>","text":"<p>Return the nth item at index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the item to retrieve.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The item at the specified index.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n20\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def nth(self, index: int) -&gt; T:\n    \"\"\"Return the nth item at index.\n\n    Args:\n        index (int): The index of the item to retrieve.\n\n    Returns:\n        T: The item at the specified index.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n    20\n\n    ```\n    \"\"\"\n    return cz.itertoolz.nth(index, self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.reduce","level":2,"title":"<code>reduce(func)</code>","text":"<p>Apply a function of two arguments cumulatively to the items of an iterable, from left to right.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>Function to apply cumulatively to the items of the iterable.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Single value resulting from cumulative reduction.</p> <p>This effectively reduces the iterable to a single value.</p> <p>If initial is present, it is placed before the items of the iterable in the calculation.</p> <p>It then serves as a default when the iterable is empty. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n6\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def reduce(self, func: Callable[[T, T], T]) -&gt; T:\n    \"\"\"Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    Args:\n        func (Callable[[T, T], T]): Function to apply cumulatively to the items of the iterable.\n\n    Returns:\n        T: Single value resulting from cumulative reduction.\n\n    This effectively reduces the iterable to a single value.\n\n    If initial is present, it is placed before the items of the iterable in the calculation.\n\n    It then serves as a default when the iterable is empty.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n    6\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.second","level":2,"title":"<code>second()</code>","text":"<p>Return the second element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The second element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9, 8]).second()\n8\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def second(self) -&gt; T:\n    \"\"\"Return the second element.\n\n    Returns:\n        T: The second element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9, 8]).second()\n    8\n\n    ```\n    \"\"\"\n    return cz.itertoolz.second(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.sort","level":2,"title":"<code>sort(*, key=None, reverse=False)</code>","text":"<pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Vec[U]\n</code></pre><pre><code>sort(\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]],\n    reverse: bool = False,\n) -&gt; Vec[T]\n</code></pre><pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Never\n</code></pre> <p>Sort the elements of the sequence.</p> Note <p>This method must consume the entire iterable to perform the sort. The result is a new <code>Vec</code> over the sorted sequence.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsRichComparison[Any]] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in descending order. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Vec[Any]</code> <p>Vec[Any]: A <code>Vec</code> with elements sorted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\nVec(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sort(\n    self,\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n    reverse: bool = False,\n) -&gt; Vec[Any]:\n    \"\"\"Sort the elements of the sequence.\n\n    Note:\n        This method must consume the entire iterable to perform the sort.\n        The result is a new `Vec` over the sorted sequence.\n\n    Args:\n        key (Callable[[T], SupportsRichComparison[Any]] | None): Function to extract a comparison key from each element. Defaults to None.\n        reverse (bool): Whether to sort in descending order. Defaults to False.\n\n    Returns:\n        Vec[Any]: A `Vec` with elements sorted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\n    Vec(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Vec(sorted(self._inner, reverse=reverse, key=key))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.sum","level":2,"title":"<code>sum()</code>","text":"<p>Return the sum of the <code>Iterable</code>.</p> <p>If the <code>Iterable</code> is empty, return 0.</p> <p>Returns:</p> Type Description <code>U | Literal[0]</code> <p>U | Literal[0]: The sum of all elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n6\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sum[U: SupportsSumWithNoDefaultGiven[Any]](self: BaseIter[U]) -&gt; U | Literal[0]:\n    \"\"\"Return the sum of the `Iterable`.\n\n    If the `Iterable` is empty, return 0.\n\n    Returns:\n        U | Literal[0]: The sum of all elements.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n    6\n\n    ```\n    \"\"\"\n    return sum(self._inner)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.symmetric_difference","level":2,"title":"<code>symmetric_difference(*others)</code>","text":"<p>Return the symmetric difference (XOR) of this iterable and 'others'.</p> <p>(Elements in either 'self' or 'others' but not in both).</p> <p>See Also:     - <code>intersection</code>     - <code>difference</code></p> Note <p>This method consumes inner data, unsorts it, and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to compute the symmetric difference with.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the symmetric difference of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\nVec(1, 3)\n&gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\nVec(1, 2, 4, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def symmetric_difference(self, *others: Iterable[T]) -&gt; Self:\n    \"\"\"Return the symmetric difference (XOR) of this iterable and 'others'.\n\n    (Elements in either 'self' or 'others' but not in both).\n\n    **See Also**:\n        - `intersection`\n        - `difference`\n\n    Note:\n        This method consumes inner data, unsorts it, and removes duplicates.\n\n    Args:\n        *others (Iterable[T]): Other iterables to compute the symmetric difference with.\n\n    Returns:\n        Self: A new `Set` containing the symmetric difference of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\n    Vec(1, 3)\n    &gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\n    Vec(1, 2, 4, 5)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.symmetric_difference(*others))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.tail","level":2,"title":"<code>tail(n)</code>","text":"<p>Return a tuple of the last n elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to return.</p> required <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the last n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def tail(self, n: int) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the last n elements.\n\n    Args:\n        n (int): Number of elements to return.\n\n    Returns:\n        Seq[T]: A new Seq containing the last n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.tail(n, self._inner))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.top_n","level":2,"title":"<code>top_n(n, key=None)</code>","text":"<p>Return a tuple of the top-n items according to key.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of top elements to return.</p> required <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the top-n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\nSeq(3, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def top_n(self, n: int, key: Callable[[T], Any] | None = None) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the top-n items according to key.\n\n    Args:\n        n (int): Number of top elements to return.\n        key (Callable[[T], Any] | None): Function to extract a comparison key from each element. Defaults to None.\n\n    Returns:\n        Seq[T]: A new Seq containing the top-n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\n    Seq(3, 2)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.topk(n, self._inner, key=key))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.union","level":2,"title":"<code>union(*others)</code>","text":"<pre><code>union(*others: Iterable[T]) -&gt; Set[T]\n</code></pre><pre><code>union(*others: Iterable[U]) -&gt; Set[T | U]\n</code></pre> <p>Return the union of this iterable and 'others'.</p> Note <p>This method consumes inner data and removes duplicates.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to include in the union.</p> <code>()</code> <p>Returns:</p> Type Description <code>Set[Any]</code> <p>Set[Any]: A new <code>Set</code> containing the union of elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3], [4]).iter().sort()\nVec(1, 2, 3, 4)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def union(self, *others: Iterable[Any]) -&gt; Set[Any]:\n    \"\"\"Return the union of this iterable and 'others'.\n\n    Note:\n        This method consumes inner data and removes duplicates.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to include in the union.\n\n    Returns:\n        Set[Any]: A new `Set` containing the union of elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3], [4]).iter().sort()\n    Vec(1, 2, 3, 4)\n\n    ```\n    \"\"\"\n    return self.__class__(self._inner.union(*others))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.unzip","level":2,"title":"<code>unzip()</code>","text":"<p>Converts an iterator of pairs into a pair of iterators.</p> <p>Returns:</p> Type Description <code>Unzipped[U, V]</code> <p>Unzipped[U, V]: dataclass with first and second iterators.</p> <p><code>Iter.unzip()</code> consumes the iterator of pairs.</p> <p>Returns an Unzipped dataclass, containing two iterators:</p> <ul> <li>one from the left elements of the pairs</li> <li>one from the right elements.</li> </ul> <p>This function is, in some sense, the opposite of zip. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n&gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n&gt;&gt;&gt; unzipped.left.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; unzipped.right.collect()\nSeq('a', 'b', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unzip[U, V](self: BaseIter[tuple[U, V]]) -&gt; Unzipped[U, V]:\n    \"\"\"Converts an iterator of pairs into a pair of iterators.\n\n    Returns:\n        Unzipped[U, V]: dataclass with first and second iterators.\n\n    `Iter.unzip()` consumes the iterator of pairs.\n\n    Returns an Unzipped dataclass, containing two iterators:\n\n    - one from the left elements of the pairs\n    - one from the right elements.\n\n    This function is, in some sense, the opposite of zip.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n    &gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n    &gt;&gt;&gt; unzipped.left.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; unzipped.right.collect()\n    Seq('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    d: tuple[tuple[U, V], ...] = tuple(self._inner)\n    return Unzipped(Iter(x[0] for x in d), Iter(x[1] for x in d))\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/some/","level":1,"title":"Some","text":"<p>               Bases: <code>Option[T]</code></p> <p>Option variant representing the presence of a value.</p> <p>For more documentation, see the <code>Option[T]</code> class.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>T</code> <p>The contained value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(42)\nSome(42)\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@final\n@dataclass(slots=True)\nclass Some[T](Option[T]):\n    \"\"\"Option variant representing the presence of a value.\n\n    For more documentation, see the `Option[T]` class.\n\n    Attributes:\n        value (T): The contained value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(42)\n    Some(42)\n\n    ```\n\n    \"\"\"\n\n    __match_args__ = (\"value\",)\n\n    value: T\n\n    def __new__[V](cls, _value: V) -&gt; Some[V]:\n        \"\"\"Bypass Option's redirect by directly creating a Some instance.\"\"\"\n        return cast(Some[V], object.__new__(cls))\n\n    def __repr__(self) -&gt; str:\n        return f\"Some({self.value!r})\"\n\n    def is_some(self) -&gt; bool:\n        return True\n\n    def is_none(self) -&gt; bool:\n        return False\n\n    def unwrap(self) -&gt; T:\n        return self.value\n\n    def is_some_and[**P](\n        self,\n        predicate: Callable[Concatenate[T, P], bool],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; bool:\n        return predicate(self.unwrap(), *args, **kwargs)\n\n    def is_none_or[**P](\n        self, func: Callable[Concatenate[T, P], bool], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; bool:\n        return func(self.unwrap(), *args, **kwargs)\n\n    def expect(self, msg: str) -&gt; T:  # noqa: ARG002\n        return self.unwrap()\n\n    def unwrap_or(self, default: T) -&gt; T:  # noqa: ARG002\n        return self.unwrap()\n\n    def unwrap_or_else(self, f: Callable[[], T]) -&gt; T:  # noqa: ARG002\n        return self.unwrap()\n\n    def map[**P, R](\n        self, f: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Option[R]:\n        return Some(f(self.unwrap(), *args, **kwargs))\n\n    def and_[U](self, optb: Option[U]) -&gt; Option[U]:\n        return optb\n\n    def or_(self, optb: Option[T]) -&gt; Option[T]:  # noqa: ARG002\n        return self\n\n    def and_then[**P, R](\n        self,\n        f: Callable[Concatenate[T, P], Option[R]],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Option[R]:\n        return f(self.unwrap(), *args, **kwargs)\n\n    def or_else(self, f: Callable[[], Option[T]]) -&gt; Option[T]:  # noqa: ARG002\n        return self\n\n    def ok_or[E](self, err: E) -&gt; Result[T, E]:  # noqa: ARG002\n        from ._result import Ok\n\n        return Ok(self.unwrap())\n\n    def ok_or_else[E](self, err: Callable[[], E]) -&gt; Result[T, E]:  # noqa: ARG002\n        from ._result import Ok\n\n        return Ok(self.unwrap())\n\n    def map_or[**P, R](\n        self,\n        default: R,  # noqa: ARG002\n        f: Callable[Concatenate[T, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; R:\n        return f(self.unwrap(), *args, **kwargs)\n\n    def map_or_else[**P, R](self, default: Callable[[], R], f: Callable[[T], R]) -&gt; R:  # noqa: ARG002\n        return f(self.unwrap())\n\n    def filter[**P, R](\n        self,\n        predicate: Callable[Concatenate[T, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Option[T]:\n        return self if predicate(self.unwrap(), *args, **kwargs) else NONE\n\n    def iter(self) -&gt; Iter[T]:\n        from ._iter import Iter\n\n        return Iter.once(self.unwrap())\n\n    def inspect[**P](\n        self, f: Callable[Concatenate[T, P], object], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Option[T]:\n        f(self.unwrap(), *args, **kwargs)\n        return self\n\n    def unzip[U](self: Option[tuple[T, U]]) -&gt; tuple[Option[T], Option[U]]:\n        a, b = self.unwrap()\n        return Some(a), Some(b)\n\n    def zip[U](self, other: Option[U]) -&gt; Option[tuple[T, U]]:\n        if other.is_some():\n            return Some((self.unwrap(), other.unwrap()))\n        return NONE\n\n    def zip_with[U, R](self, other: Option[U], f: Callable[[T, U], R]) -&gt; Option[R]:\n        if other.is_some():\n            return Some(f(self.unwrap(), other.unwrap()))\n        return NONE\n\n    def reduce[U](self, other: Option[T], func: Callable[[T, T], T]) -&gt; Option[T]:\n        if other.is_some():\n            return Some(func(self.unwrap(), other.unwrap()))\n        return self\n\n    def transpose[E](self: Option[Result[T, E]]) -&gt; Result[Option[T], E]:\n        from ._result import Err, Ok\n\n        inner = self.unwrap()\n        if inner.is_ok():\n            return Ok(Option(inner.unwrap()))\n        return Err(inner.unwrap_err())\n\n    def xor(self, optb: Option[T]) -&gt; Option[T]:\n        return self if optb.is_none() else NONE\n</code></pre>","path":["API Reference","Optional Values","Some"],"tags":[]},{"location":"reference/some/#pyochain._option.Some.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Option</code>.</p> <p>Converts an <code>Option[Option[U]]</code> into an <code>Option[U]</code> by removing one level of nesting.</p> <p>Equivalent to <code>Option.and_then(lambda x: x)</code>.</p> <p>Returns:</p> Type Description <code>Option[U]</code> <p>Option[U]: The flattened option.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\nSome(42)\n&gt;&gt;&gt; pc.Some(pc.NONE).flatten()\nNONE\n&gt;&gt;&gt; pc.NONE.flatten()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>def flatten[U](self: Option[Option[U]]) -&gt; Option[U]:\n    \"\"\"Flattens a nested `Option`.\n\n    Converts an `Option[Option[U]]` into an `Option[U]` by removing one level of nesting.\n\n    Equivalent to `Option.and_then(lambda x: x)`.\n\n    Returns:\n        Option[U]: The flattened option.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\n    Some(42)\n    &gt;&gt;&gt; pc.Some(pc.NONE).flatten()\n    NONE\n    &gt;&gt;&gt; pc.NONE.flatten()\n    NONE\n\n    ```\n    \"\"\"\n    return self.and_then(lambda x: x)\n</code></pre>","path":["API Reference","Optional Values","Some"],"tags":[]},{"location":"reference/some/#pyochain._option.Some.if_some","level":2,"title":"<code>if_some(value)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on the truthiness of a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the value is truthy, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_some(42)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_some(0)\nNONE\n&gt;&gt;&gt; pc.Option.if_some(\"hello\")\nSome('hello')\n&gt;&gt;&gt; pc.Option.if_some(\"\")\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@staticmethod\ndef if_some[V](value: V) -&gt; Option[V]:\n    \"\"\"Creates an `Option[V]` based on the truthiness of a value.\n\n    Args:\n        value (V): The value to evaluate.\n\n    Returns:\n        Option[V]: `Some(value)` if the value is truthy, otherwise `NONE`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Option.if_some(42)\n    Some(42)\n    &gt;&gt;&gt; pc.Option.if_some(0)\n    NONE\n    &gt;&gt;&gt; pc.Option.if_some(\"hello\")\n    Some('hello')\n    &gt;&gt;&gt; pc.Option.if_some(\"\")\n    NONE\n\n    ```\n    \"\"\"\n    return cast(Option[V], Some(value) if value else NONE)\n</code></pre>","path":["API Reference","Optional Values","Some"],"tags":[]},{"location":"reference/some/#pyochain._option.Some.if_true","level":2,"title":"<code>if_true(value, *, predicate)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on a predicate condition.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to wrap in <code>Some</code> if the condition is <code>True</code>.</p> required <code>predicate</code> <code>Callable[[], bool]</code> <p>The condition to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the condition is <code>True</code>, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 4)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 5)\nNONE\n&gt;&gt;&gt; # Evaluate on __bool__ of a collection (will call __len__ under the hood)\n&gt;&gt;&gt; data = [1, 2, 3]\n&gt;&gt;&gt; pc.Option.if_true(data, predicate=lambda: data)\nSome([1, 2, 3])\n&gt;&gt;&gt; empty_data = []\n&gt;&gt;&gt; pc.Option.if_true(empty_data, predicate=lambda: empty_data)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/_option.py</code> <pre><code>@staticmethod\ndef if_true[V](value: V, *, predicate: Callable[[], bool]) -&gt; Option[V]:\n    \"\"\"Creates an `Option[V]` based on a **predicate** condition.\n\n    Args:\n        value (V): The value to wrap in `Some` if the condition is `True`.\n        predicate (Callable[[], bool]): The condition to evaluate.\n\n    Returns:\n        Option[V]: `Some(value)` if the condition is `True`, otherwise `NONE`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 4)\n    Some(42)\n    &gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda: 2 + 2 == 5)\n    NONE\n    &gt;&gt;&gt; # Evaluate on __bool__ of a collection (will call __len__ under the hood)\n    &gt;&gt;&gt; data = [1, 2, 3]\n    &gt;&gt;&gt; pc.Option.if_true(data, predicate=lambda: data)\n    Some([1, 2, 3])\n    &gt;&gt;&gt; empty_data = []\n    &gt;&gt;&gt; pc.Option.if_true(empty_data, predicate=lambda: empty_data)\n    NONE\n\n    ```\n    \"\"\"\n    return cast(Option[V], Some(value) if predicate() else NONE)\n</code></pre>","path":["API Reference","Optional Values","Some"],"tags":[]},{"location":"reference/some/#pyochain._option.Some.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Optional Values","Some"],"tags":[]},{"location":"reference/traits/","level":1,"title":"Traits","text":"<p>Mixin class providing pipeable methods for fluent chaining.</p> Source code in <code>src/pyochain/traits.py</code> <pre><code>class Pipeable:\n    \"\"\"Mixin class providing pipeable methods for fluent chaining.\"\"\"\n\n    def into[**P, R](\n        self,\n        func: Callable[Concatenate[Self, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; R:\n        \"\"\"Convert `Self` to `R`.\n\n        This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n        Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n        Args:\n            func (Callable[Concatenate[Self, P], R]): Function for conversion.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            R: The converted value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; import hashlib\n        &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n        ...     return hashlib.sha256(bytes(data)).hexdigest()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n        '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n        ```\n        \"\"\"\n        return func(self, *args, **kwargs)\n\n    def inspect[**P](\n        self,\n        func: Callable[Concatenate[Self, P], object],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Self:\n        \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n        This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n        Args:\n            func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            Self: The instance itself, unchanged.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n        Seq(1, 2, 3, 4)\n        4\n\n        ```\n        \"\"\"\n        func(self, *args, **kwargs)\n        return self\n</code></pre> <pre><code>    options:\n        inherited_members: true\n        show_overloads: true\n        members_order: alphabetical\n        filters:\n            - \"!^_\"\n</code></pre> <p>Mixin class providing conditional chaining methods based on truthiness.</p> <p>This class provides methods inspired by Rust's <code>bool</code> type for conditional execution and wrapping in <code>Option</code> or <code>Result</code> types.</p> <p>All methods evaluate the instance's truthiness to determine their behavior.</p> Source code in <code>src/pyochain/traits.py</code> <pre><code>class Checkable:\n    \"\"\"Mixin class providing conditional chaining methods based on truthiness.\n\n    This class provides methods inspired by Rust's `bool` type for conditional\n    execution and wrapping in `Option` or `Result` types.\n\n    All methods evaluate the instance's truthiness to determine their behavior.\n    \"\"\"\n\n    def then[**P, R](\n        self,\n        func: Callable[Concatenate[Self, P], R],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Option[R]:\n        \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n        `R` being the return type of **func**.\n\n        The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Args:\n            func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n        Some(6)\n        &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n        NONE\n\n        ```\n        \"\"\"\n        from ._option import NONE, Some\n\n        return Some(func(self, *args, **kwargs)) if self else NONE\n\n    def then_some(self) -&gt; Option[Self]:\n        \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Returns:\n            Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n        Some(Seq(1, 2, 3))\n        &gt;&gt;&gt; pc.Seq([]).then_some()\n        NONE\n\n        ```\n        \"\"\"\n        from ._option import NONE, Some\n\n        return Some(self) if self else NONE\n\n    def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n        \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Args:\n            err (E): The error value to wrap in Err if self is falsy.\n\n        Returns:\n            Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n        Ok(Seq(1, 2, 3))\n        &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n        Err('empty')\n\n        ```\n        \"\"\"\n        from ._result import Err, Ok\n\n        return Ok(self) if self else Err(err)\n\n    def ok_or_else[**P, E](\n        self,\n        func: Callable[Concatenate[Self, P], E],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; Result[Self, E]:\n        \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n        `E` being the return type of **func**.\n\n        The function is only called if self evaluates to False.\n\n        Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n        Args:\n            func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n            *args (P.args): Positional arguments to pass to the function.\n            **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n        Returns:\n            Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n        Ok(Seq(1, 2, 3))\n        &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n        Err('empty seq')\n\n        ```\n        \"\"\"\n        from ._result import Err, Ok\n\n        return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre> <pre><code>    options:\n        inherited_members: true\n        show_overloads: true\n        members_order: alphabetical\n        filters:\n            - \"!^_\"\n</code></pre>","path":["Traits"],"tags":[]},{"location":"reference/traits/#pyochain.traits.Pipeable.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["Traits"],"tags":[]},{"location":"reference/traits/#pyochain.traits.Pipeable.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["Traits"],"tags":[]},{"location":"reference/traits/#pyochain.traits.Checkable.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["Traits"],"tags":[]},{"location":"reference/traits/#pyochain.traits.Checkable.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["Traits"],"tags":[]},{"location":"reference/traits/#pyochain.traits.Checkable.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["Traits"],"tags":[]},{"location":"reference/traits/#pyochain.traits.Checkable.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["Traits"],"tags":[]},{"location":"reference/vec/","level":1,"title":"Vec","text":"<p>               Bases: <code>Seq[T]</code>, <code>MutableSequence[T]</code></p> <p>A mutable sequence wrapper with functional API.</p> <p>Implement <code>MutableSequence</code> Protocol from <code>collections.abc</code> so it can be used as a standard mutable sequence.</p> <p>Unlike <code>Seq</code> which is immutable, <code>Vec</code> allows in-place modification of elements.</p> <p>Implement the <code>MutableSequence</code> interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable sequence.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The mutable sequence to wrap.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Vec[T](Seq[T], MutableSequence[T]):\n    \"\"\"A mutable sequence wrapper with functional API.\n\n    Implement `MutableSequence` Protocol from `collections.abc` so it can be used as a standard mutable sequence.\n\n    Unlike `Seq` which is immutable, `Vec` allows in-place modification of elements.\n\n    Implement the `MutableSequence` interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable sequence.\n\n    Args:\n        data (Iterable[T]): The mutable sequence to wrap.\n    \"\"\"\n\n    _inner: list[T]\n    __slots__ = (\"_inner\",)\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = list(data)  # type: ignore[override]\n\n    @classmethod\n    def new(cls) -&gt; Self:\n        \"\"\"Create an empty `Vec`.\n\n        Make sure to specify the type when calling this method, e.g., `Vec[int].new()`.\n\n        Otherwise, `T` will be inferred as `Any`.\n\n        Returns:\n            Self: A new empty Vec instance.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Vec.new()\n        Vec()\n\n        ```\n        \"\"\"\n        return cls([])\n\n    @overload\n    def __setitem__(self, index: int, value: T) -&gt; None: ...\n    @overload\n    def __setitem__(self, index: slice, value: Iterable[T]) -&gt; None: ...\n    def __setitem__(self, index: int | slice, value: T | Iterable[T]) -&gt; None:\n        return self._inner.__setitem__(index, value)  # type: ignore[arg-type]\n\n    def __delitem__(self, index: int | slice) -&gt; None:\n        self._inner.__delitem__(index)\n\n    def insert(self, index: int, value: T) -&gt; None:\n        \"\"\"Inserts an element at position index within the vector, shifting all elements after it to the right.\n\n        Args:\n            index (int): Position where to insert the element.\n            value (T): The element to insert.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; vec = pc.Vec(['a', 'b', 'c'])\n        &gt;&gt;&gt; vec.insert(1, 'd')\n        &gt;&gt;&gt; vec\n        Vec('a', 'd', 'b', 'c')\n        &gt;&gt;&gt; vec.insert(4, 'e')\n        &gt;&gt;&gt; vec\n        Vec('a', 'd', 'b', 'c', 'e')\n\n        ```\n        \"\"\"\n        self._inner.insert(index, value)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.all","level":2,"title":"<code>all(predicate=None)</code>","text":"<p>Tests if every element of the iterator matches a predicate.</p> <p><code>Iter.all()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if they all return true, then so does <code>Iter.all()</code>.</p> <p>If any of them return false, it returns false.</p> <p>An empty iterator returns true.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements match the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, True]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 0]).all()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if every element of the iterator matches a predicate.\n\n    `Iter.all()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if they all return true, then so does `Iter.all()`.\n\n    If any of them return false, it returns false.\n\n    An empty iterator returns true.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if all elements match the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, True]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 0]).all()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return all(self._inner)\n    return all(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.all_equal","level":2,"title":"<code>all_equal(key=None)</code>","text":"<p>Return True if all items are equal.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\nTrue\n</code></pre> A function that accepts a single argument and returns a transformed version of each input item can be specified with key: <pre><code>&gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_equal[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Return True if all items are equal.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all items are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 1]).all_equal()\n    True\n\n    ```\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with key:\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"AaaA\").all_equal(key=str.casefold)\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\n    True\n\n    ```\n    \"\"\"\n    return mit.all_equal(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.all_unique","level":2,"title":"<code>all_unique(key=None)</code>","text":"<p>Returns True if all the elements of iterable are unique.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements are unique, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\nFalse\n</code></pre> If a key function is specified, it will be used to make comparisons. <pre><code>&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\nTrue\n&gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\nFalse\n</code></pre> The function returns as soon as the first non-unique element is encountered.</p> <p>Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def all_unique[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Returns True if all the elements of iterable are unique.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n\n    Returns:\n        bool: True if all elements are unique, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"ABCB\").all_unique()\n    False\n\n    ```\n    If a key function is specified, it will be used to make comparisons.\n    ```python\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique()\n    True\n    &gt;&gt;&gt; pc.Seq(\"ABCb\").all_unique(str.lower)\n    False\n\n    ```\n    The function returns as soon as the first non-unique element is encountered.\n\n    Iterables with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items\n\n    \"\"\"\n    return mit.all_unique(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.any","level":2,"title":"<code>any(predicate=None)</code>","text":"<p>Tests if any element of the iterator matches a predicate.</p> <p><code>Iter.any()</code> takes a closure that returns true or false.</p> <p>It applies this closure to each element of the iterator, and if any of them return true, then so does <code>Iter.any()</code>.</p> <p>If they all return false, it returns false.</p> <p>An empty iterator returns false.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any element matches the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([0, 1]).any()\nTrue\n&gt;&gt;&gt; pc.Seq(range(0)).any()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def any(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if any element of the iterator matches a predicate.\n\n    `Iter.any()` takes a closure that returns true or false.\n\n    It applies this closure to each element of the iterator, and if any of them return true, then so does `Iter.any()`.\n\n    If they all return false, it returns false.\n\n    An empty iterator returns false.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if any element matches the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([0, 1]).any()\n    True\n    &gt;&gt;&gt; pc.Seq(range(0)).any()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return any(self._inner)\n    return any(predicate(x) for x in self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.argmax","level":2,"title":"<code>argmax(key=None)</code>","text":"<p>Index of the first occurrence of a maximum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the maximum value.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n7\n&gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n3\n</code></pre> For example, identify the best machine learning model: <pre><code>&gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n&gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n&gt;&gt;&gt; # Most accurate model\n&gt;&gt;&gt; models.nth(accuracy.argmax())\n'knn'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Best accuracy\n&gt;&gt;&gt; accuracy.into(max)\n84\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmax[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a maximum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the maximum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefghabcd\").argmax()\n    7\n    &gt;&gt;&gt; pc.Seq([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n    3\n\n    ```\n    For example, identify the best machine learning model:\n    ```python\n    &gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n    &gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n    &gt;&gt;&gt; # Most accurate model\n    &gt;&gt;&gt; models.nth(accuracy.argmax())\n    'knn'\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Best accuracy\n    &gt;&gt;&gt; accuracy.into(max)\n    84\n\n    ```\n    \"\"\"\n    return mit.argmax(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.argmin","level":2,"title":"<code>argmin(key=None)</code>","text":"<p>Index of the first occurrence of a minimum value in an iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the minimum value.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n4\n&gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n3\n</code></pre> <p>For example, look up a label corresponding to the position of a value that minimizes a cost function: <pre><code>&gt;&gt;&gt; def cost(x):\n...     \"Days for a wound to heal given a subject's age.\"\n...     return x**2 - 20 * x + 150\n&gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n&gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n&gt;&gt;&gt; # Fastest healing family member\n&gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n'bart'\n&gt;&gt;&gt; # Age with fastest healing\n&gt;&gt;&gt; ages.into(min, key=cost)\n10\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def argmin[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a minimum value in an iterable.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the minimum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"efghabcdijkl\").argmin()\n    4\n    &gt;&gt;&gt; pc.Seq([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n    3\n\n    ```\n\n    For example, look up a label corresponding to the position of a value that minimizes a cost function:\n    ```python\n    &gt;&gt;&gt; def cost(x):\n    ...     \"Days for a wound to heal given a subject's age.\"\n    ...     return x**2 - 20 * x + 150\n    &gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n    &gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n    &gt;&gt;&gt; # Fastest healing family member\n    &gt;&gt;&gt; labels.nth(ages.argmin(key=cost))\n    'bart'\n    &gt;&gt;&gt; # Age with fastest healing\n    &gt;&gt;&gt; ages.into(min, key=cost)\n    10\n\n    ```\n    \"\"\"\n    return mit.argmin(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.combination_index","level":2,"title":"<code>combination_index(r)</code>","text":"<p>Computes the index of the first element, without computing the previous combinations.</p> <p>The subsequences of iterable that are of length r can be ordered lexicographically.</p> <p>ValueError will be raised if the given element isn't one of the combinations of iterable.</p> <p>Equivalent to list(combinations(iterable, r)).index(element).</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>Iterable[T]</code> <p>The combination to find the index of.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the combination.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n10\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combination_index(self, r: Iterable[T]) -&gt; int:\n    \"\"\"Computes the index of the first element, without computing the previous combinations.\n\n    The subsequences of iterable that are of length r can be ordered lexicographically.\n\n\n    ValueError will be raised if the given element isn't one of the combinations of iterable.\n\n    Equivalent to list(combinations(iterable, r)).index(element).\n\n    Args:\n        r (Iterable[T]): The combination to find the index of.\n\n    Returns:\n        int: The index of the combination.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq(\"abcdefg\").combination_index(\"adf\")\n    10\n\n    ```\n    \"\"\"\n    return mit.combination_index(r, self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Check if two Iterables are equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\nFalse\n&gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def eq(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\n    False\n    &gt;&gt;&gt; pc.Seq((1,2,3)).eq(pc.Vec([1,2,3]))\n    True\n\n    ```\n    \"\"\"\n    return tuple(self._inner) == tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.find","level":2,"title":"<code>find(predicate)</code>","text":"<p>Searches for an element of an iterator that satisfies a <code>predicate</code>.</p> <p>Takes a closure that returns true or false as <code>predicate</code>, and applies it to each element of the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The first element satisfying the predicate. <code>Some(value)</code> if found, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n...     return x &gt; 5\n&gt;&gt;&gt;\n&gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n...     return x &gt; 9\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\nSome(6)\n&gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n'missing'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def find(self, predicate: Callable[[T], bool]) -&gt; Option[T]:\n    \"\"\"Searches for an element of an iterator that satisfies a `predicate`.\n\n    Takes a closure that returns true or false as `predicate`, and applies it to each element of the iterator.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Option[T]: The first element satisfying the predicate. `Some(value)` if found, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n    ...     return x &gt; 5\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n    ...     return x &gt; 9\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_five)\n    Some(6)\n    &gt;&gt;&gt; pc.Seq(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n    'missing'\n\n    ```\n    \"\"\"\n    from ._option import Option\n\n    return Option(next(filter(predicate, self._inner), None))\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.first","level":2,"title":"<code>first()</code>","text":"<p>Return the first element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The first element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9]).first()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def first(self) -&gt; T:\n    \"\"\"Return the first element.\n\n    Returns:\n        T: The first element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9]).first()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.first(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.fold","level":2,"title":"<code>fold(init, func)</code>","text":"<p>Fold every element into an accumulator by applying an operation, returning the final result.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>B</code> <p>Initial value for the accumulator.</p> required <code>func</code> <code>Callable[[B, T], B]</code> <p>Function that takes the accumulator and current element, returning the new accumulator value.</p> required <p>Returns:</p> Name Type Description <code>B</code> <code>B</code> <p>The final accumulated value.</p> Note <p>This is similar to <code>reduce()</code> but with an initial value, making it equivalent to Python's <code>functools.reduce()</code> with an initializer.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n6\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n16\n&gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n'abc'\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def fold[B](self, init: B, func: Callable[[B, T], B]) -&gt; B:\n    \"\"\"Fold every element into an accumulator by applying an operation, returning the final result.\n\n    Args:\n        init (B): Initial value for the accumulator.\n        func (Callable[[B, T], B]): Function that takes the accumulator and current element,\n            returning the new accumulator value.\n\n    Returns:\n        B: The final accumulated value.\n\n    Note:\n        This is similar to `reduce()` but with an initial value, making it equivalent to\n        Python's `functools.reduce()` with an initializer.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n    6\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n    16\n    &gt;&gt;&gt; pc.Seq(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n    'abc'\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner, init)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.ge","level":2,"title":"<code>ge(other)</code>","text":"<p>Check if this Iterable is greater than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ge(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).ge(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).ge(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.gt","level":2,"title":"<code>gt(other)</code>","text":"<p>Check if this Iterable is greater than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is greater than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def gt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is greater than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is greater than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2,3)).gt(pc.Seq((1,2)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2)).gt(pc.Seq((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &gt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.insert","level":2,"title":"<code>insert(index, value)</code>","text":"<p>Inserts an element at position index within the vector, shifting all elements after it to the right.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Position where to insert the element.</p> required <code>value</code> <code>T</code> <p>The element to insert.</p> required <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; vec = pc.Vec(['a', 'b', 'c'])\n&gt;&gt;&gt; vec.insert(1, 'd')\n&gt;&gt;&gt; vec\nVec('a', 'd', 'b', 'c')\n&gt;&gt;&gt; vec.insert(4, 'e')\n&gt;&gt;&gt; vec\nVec('a', 'd', 'b', 'c', 'e')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def insert(self, index: int, value: T) -&gt; None:\n    \"\"\"Inserts an element at position index within the vector, shifting all elements after it to the right.\n\n    Args:\n        index (int): Position where to insert the element.\n        value (T): The element to insert.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; vec = pc.Vec(['a', 'b', 'c'])\n    &gt;&gt;&gt; vec.insert(1, 'd')\n    &gt;&gt;&gt; vec\n    Vec('a', 'd', 'b', 'c')\n    &gt;&gt;&gt; vec.insert(4, 'e')\n    &gt;&gt;&gt; vec\n    Vec('a', 'd', 'b', 'c', 'e')\n\n    ```\n    \"\"\"\n    self._inner.insert(index, value)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def inspect[**P](\n    self,\n    func: Callable[Concatenate[Self, P], object],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Self:\n    \"\"\"Pass `Self` to **func** to perform side effects without altering the data.\n\n    This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.\n\n    Args:\n        func (Callable[Concatenate[Self, P], object]): Function to apply to the instance for side effects.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Self: The instance itself, unchanged.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\n    Seq(1, 2, 3, 4)\n    4\n\n    ```\n    \"\"\"\n    func(self, *args, **kwargs)\n    return self\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def into[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; R:\n    \"\"\"Convert `Self` to `R`.\n\n    This method allows to pipe the instance into an object or function that can convert `Self` into another type.\n\n    Conceptually, this allow to do `x.into(f)` instead of `f(x)`, hence keeping a fluent chaining style.\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): Function for conversion.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        R: The converted value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import hashlib\n    &gt;&gt;&gt; def sha256_hex(data: pc.Seq[int]) -&gt; str:\n    ...     return hashlib.sha256(bytes(data)).hexdigest()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n    '039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n\n    ```\n    \"\"\"\n    return func(self, *args, **kwargs)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.is_distinct","level":2,"title":"<code>is_distinct()</code>","text":"<p>Return True if all items are distinct.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are distinct, False otherwise.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\nTrue\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_distinct(self) -&gt; bool:\n    \"\"\"Return True if all items are distinct.\n\n    Returns:\n        bool: True if all items are distinct, False otherwise.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\n    True\n\n    ```\n    \"\"\"\n    return cz.itertoolz.isdistinct(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.is_sorted","level":2,"title":"<code>is_sorted(key=None, *, reverse=False, strict=False)</code>","text":"<p>Returns True if the items of iterable are in sorted order.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to check for descending order. Defaults to False.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Whether to enforce strict sorting (no equal elements). Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if items are sorted according to the criteria, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\nTrue\n&gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\nFalse\n\nIf strict, tests for strict sorting, that is, returns False if equal elements are found:\n```python\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\nFalse\n</code></pre></p> <p>The function returns False after encountering the first out-of-order item.</p> <p>This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).</p> <p>If there are no out-of-order items, the iterable is exhausted.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_sorted[U](\n    self,\n    key: Callable[[T], U] | None = None,\n    *,\n    reverse: bool = False,\n    strict: bool = False,\n) -&gt; bool:\n    \"\"\"Returns True if the items of iterable are in sorted order.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison. Defaults to None.\n        reverse (bool): Whether to check for descending order. Defaults to False.\n        strict (bool): Whether to enforce strict sorting (no equal elements). Defaults to False.\n\n    Returns:\n        bool: True if items are sorted according to the criteria, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted(key=int)\n    True\n    &gt;&gt;&gt; pc.Seq([5, 4, 3, 1, 2]).is_sorted(reverse=True)\n    False\n\n    If strict, tests for strict sorting, that is, returns False if equal elements are found:\n    ```python\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 2, 2]).is_sorted(strict=True)\n    False\n\n    ```\n\n    The function returns False after encountering the first out-of-order item.\n\n    This means it may produce results that differ from the built-in sorted function for objects with unusual comparison dynamics (like math.nan).\n\n    If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n    return mit.is_sorted(self._inner, key=key, reverse=reverse, strict=strict)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.iter","level":2,"title":"<code>iter()</code>","text":"<p>Get an iterator over the <code>Iterable</code>.</p> <p>Call this to switch to lazy evaluation.</p> <p>Calling this method on an <code>Iter</code> instance has no effect.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> over the <code>Iterable</code>.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Get an iterator over the `Iterable`.\n\n    Call this to switch to lazy evaluation.\n\n    Calling this method on an `Iter` instance has no effect.\n\n    Returns:\n        Iter[T]: An `Iterator` over the `Iterable`.\n    \"\"\"\n    return Iter(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.join","level":2,"title":"<code>join(sep)</code>","text":"<p>Join all elements of the <code>Iterable</code> into a single <code>string</code>, with a specified separator.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>str</code> <p>Separator to use between elements.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The joined string.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n'a-b-c'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def join(self: BaseIter[str], sep: str) -&gt; str:\n    \"\"\"Join all elements of the `Iterable` into a single `string`, with a specified separator.\n\n    Args:\n        sep (str): Separator to use between elements.\n\n    Returns:\n        str: The joined string.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n    'a-b-c'\n\n    ```\n    \"\"\"\n    return sep.join(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.last","level":2,"title":"<code>last()</code>","text":"<p>Return the last element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The last element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n9\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def last(self) -&gt; T:\n    \"\"\"Return the last element.\n\n    Returns:\n        T: The last element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.last(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.le","level":2,"title":"<code>le(other)</code>","text":"<p>Check if this Iterable is less than or equal to another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than or equal to that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def le(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than or equal to another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than or equal to that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).le(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).le(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt;= tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.length","level":2,"title":"<code>length()</code>","text":"<p>Return the length of the Iterable.</p> <p>Like the builtin len but works on lazy sequences.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The count of elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).length()\n2\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def length(self) -&gt; int:\n    \"\"\"Return the length of the Iterable.\n\n    Like the builtin len but works on lazy sequences.\n\n    Returns:\n        int: The count of elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).length()\n    2\n\n    ```\n    \"\"\"\n    return cz.itertoolz.count(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.lt","level":2,"title":"<code>lt(other)</code>","text":"<p>Check if this Iterable is less than another based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data of self is less than that of other, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def lt(self, other: Self) -&gt; bool:\n    \"\"\"Check if this Iterable is less than another based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data of self is less than that of other, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq((1,2)).lt(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Seq((1,2,3)).lt(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) &lt; tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.max","level":2,"title":"<code>max()</code>","text":"<p>Return the maximum of the <code>Iterable</code>.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>max_by()</code> instead.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The maximum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n3\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the maximum of the `Iterable`.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `max_by()` instead.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Returns:\n        U: The maximum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n    3\n\n    ```\n    \"\"\"\n    return max(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.max_by","level":2,"title":"<code>max_by(*, key)</code>","text":"<p>Return the maximum element using a custom key function.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the maximum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=4, y='c')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=3, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def max_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the maximum element using a custom **key** function.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the maximum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=4, y='c')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=3, y='b')\n\n    ```\n    \"\"\"\n    return max(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.min","level":2,"title":"<code>min()</code>","text":"<p>Return the minimum of the sequence.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>min_by()</code> instead.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The minimum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n1\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min[U: SupportsRichComparison[Any]](self: BaseIter[U]) -&gt; U:\n    \"\"\"Return the minimum of the sequence.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `min_by()` instead.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Returns:\n        U: The minimum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n    1\n\n    ```\n    \"\"\"\n    return min(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.min_by","level":2,"title":"<code>min_by(*, key)</code>","text":"<p>Return the minimum element using a custom key function.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the minimum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def min_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the minimum element using a custom **key** function.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the minimum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n\n    ```\n    \"\"\"\n    return min(self._inner, key=key)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.most_common","level":2,"title":"<code>most_common(n=None)</code>","text":"<p>Return the n most common elements and their counts.</p> <p>If n is None, then all elements are returned.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of most common elements to return. Defaults to None (all elements).</p> <code>None</code> <p>Returns:</p> Type Description <code>Vec[tuple[T, int]]</code> <p>Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\nVec((3, 3), (1, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def most_common(self, n: int | None = None) -&gt; Vec[tuple[T, int]]:\n    \"\"\"Return the n most common elements and their counts.\n\n    If n is None, then all elements are returned.\n\n    Args:\n        n (int | None): Number of most common elements to return. Defaults to None (all elements).\n\n    Returns:\n        Vec[tuple[T, int]]: A new Seq containing tuples of (element, count).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 1, 2, 3, 3, 3]).most_common(2)\n    Vec((3, 3), (1, 2))\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return Vec(Counter(self._inner).most_common(n))\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.ne","level":2,"title":"<code>ne(other)</code>","text":"<p>Check if two Iterables are not equal based on their data.</p> Note <p>This will consume any <code>Iter</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Another instance of <code>Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the underlying data are not equal, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def ne(self, other: Self) -&gt; bool:\n    \"\"\"Check if two Iterables are not equal based on their data.\n\n    Note:\n        This will consume any `Iter` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Self): Another instance of `Iter[T]|Seq[T]|Vec[T]|Set[T]|SetMut[T]` to compare against.\n\n    Returns:\n        bool: True if the underlying data are not equal, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\n    False\n\n    ```\n    \"\"\"\n    return tuple(self._inner) != tuple(other._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.new","level":2,"title":"<code>new()</code>  <code>classmethod</code>","text":"<p>Create an empty <code>Vec</code>.</p> <p>Make sure to specify the type when calling this method, e.g., <code>Vec[int].new()</code>.</p> <p>Otherwise, <code>T</code> will be inferred as <code>Any</code>.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new empty Vec instance.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Vec.new()\nVec()\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@classmethod\ndef new(cls) -&gt; Self:\n    \"\"\"Create an empty `Vec`.\n\n    Make sure to specify the type when calling this method, e.g., `Vec[int].new()`.\n\n    Otherwise, `T` will be inferred as `Any`.\n\n    Returns:\n        Self: A new empty Vec instance.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Vec.new()\n    Vec()\n\n    ```\n    \"\"\"\n    return cls([])\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.nth","level":2,"title":"<code>nth(index)</code>","text":"<p>Return the nth item at index.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the item to retrieve.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The item at the specified index.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n20\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def nth(self, index: int) -&gt; T:\n    \"\"\"Return the nth item at index.\n\n    Args:\n        index (int): The index of the item to retrieve.\n\n    Returns:\n        T: The item at the specified index.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([10, 20]).nth(1)\n    20\n\n    ```\n    \"\"\"\n    return cz.itertoolz.nth(index, self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or[E](self, err: E) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        err (E): The error value to wrap in Err if self is falsy.\n\n    Returns:\n        Result[Self, E]: `Ok(self)` if self is truthy, `Err(err)` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\n    Err('empty')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(err)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def ok_or_else[**P, E](\n    self,\n    func: Callable[Concatenate[Self, P], E],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Result[Self, E]:\n    \"\"\"Wrap `Self` in a `Result[Self, E]` based on its truthiness.\n\n    `E` being the return type of **func**.\n\n    The function is only called if self evaluates to False.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], E]): A callable that returns the error value to wrap in Err.\n        *args (P.args): Positional arguments to pass to the function.\n        **kwargs (P.kwargs): Keyword arguments to pass to the function.\n\n    Returns:\n        Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\n    Ok(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\n    Err('empty seq')\n\n    ```\n    \"\"\"\n    from ._result import Err, Ok\n\n    return Ok(self) if self else Err(func(self, *args, **kwargs))\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.reduce","level":2,"title":"<code>reduce(func)</code>","text":"<p>Apply a function of two arguments cumulatively to the items of an iterable, from left to right.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>Function to apply cumulatively to the items of the iterable.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Single value resulting from cumulative reduction.</p> <p>This effectively reduces the iterable to a single value.</p> <p>If initial is present, it is placed before the items of the iterable in the calculation.</p> <p>It then serves as a default when the iterable is empty. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n6\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def reduce(self, func: Callable[[T, T], T]) -&gt; T:\n    \"\"\"Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    Args:\n        func (Callable[[T, T], T]): Function to apply cumulatively to the items of the iterable.\n\n    Returns:\n        T: Single value resulting from cumulative reduction.\n\n    This effectively reduces the iterable to a single value.\n\n    If initial is present, it is placed before the items of the iterable in the calculation.\n\n    It then serves as a default when the iterable is empty.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).reduce(lambda a, b: a + b)\n    6\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.second","level":2,"title":"<code>second()</code>","text":"<p>Return the second element.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The second element of the iterable.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9, 8]).second()\n8\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def second(self) -&gt; T:\n    \"\"\"Return the second element.\n\n    Returns:\n        T: The second element of the iterable.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9, 8]).second()\n    8\n\n    ```\n    \"\"\"\n    return cz.itertoolz.second(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.sort","level":2,"title":"<code>sort(*, key=None, reverse=False)</code>","text":"<pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Vec[U]\n</code></pre><pre><code>sort(\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]],\n    reverse: bool = False,\n) -&gt; Vec[T]\n</code></pre><pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Never\n</code></pre> <p>Sort the elements of the sequence.</p> Note <p>This method must consume the entire iterable to perform the sort. The result is a new <code>Vec</code> over the sorted sequence.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsRichComparison[Any]] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in descending order. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Vec[Any]</code> <p>Vec[Any]: A <code>Vec</code> with elements sorted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\nVec(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sort(\n    self,\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n    reverse: bool = False,\n) -&gt; Vec[Any]:\n    \"\"\"Sort the elements of the sequence.\n\n    Note:\n        This method must consume the entire iterable to perform the sort.\n        The result is a new `Vec` over the sorted sequence.\n\n    Args:\n        key (Callable[[T], SupportsRichComparison[Any]] | None): Function to extract a comparison key from each element. Defaults to None.\n        reverse (bool): Whether to sort in descending order. Defaults to False.\n\n    Returns:\n        Vec[Any]: A `Vec` with elements sorted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).sort()\n    Vec(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Vec(sorted(self._inner, reverse=reverse, key=key))\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.sum","level":2,"title":"<code>sum()</code>","text":"<p>Return the sum of the <code>Iterable</code>.</p> <p>If the <code>Iterable</code> is empty, return 0.</p> <p>Returns:</p> Type Description <code>U | Literal[0]</code> <p>U | Literal[0]: The sum of all elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n6\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sum[U: SupportsSumWithNoDefaultGiven[Any]](self: BaseIter[U]) -&gt; U | Literal[0]:\n    \"\"\"Return the sum of the `Iterable`.\n\n    If the `Iterable` is empty, return 0.\n\n    Returns:\n        U | Literal[0]: The sum of all elements.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n    6\n\n    ```\n    \"\"\"\n    return sum(self._inner)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.tail","level":2,"title":"<code>tail(n)</code>","text":"<p>Return a tuple of the last n elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to return.</p> required <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the last n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def tail(self, n: int) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the last n elements.\n\n    Args:\n        n (int): Number of elements to return.\n\n    Returns:\n        Seq[T]: A new Seq containing the last n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).tail(2)\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.tail(n, self._inner))\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then[**P, R](\n    self,\n    func: Callable[Concatenate[Self, P], R],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; Option[R]:\n    \"\"\"Wrap `Self` in an `Option[R]` based on its truthiness.\n\n    `R` being the return type of **func**.\n\n    The function is only called if `Self` evaluates to `True` (lazy evaluation).\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Args:\n        func (Callable[Concatenate[Self, P], R]): A callable that returns the value to wrap in Some.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Option[R]: `Some(R)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\n    Some(6)\n    &gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(func(self, *args, **kwargs)) if self else NONE\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits.py</code> <pre><code>def then_some(self) -&gt; Option[Self]:\n    \"\"\"Wraps `Self` in an `Option[Self]` based on its truthiness.\n\n    Truthiness is determined by `__bool__()` if defined, otherwise by `__len__()` if defined (returning `False` if length is 0), otherwise all instances are truthy (Python's default behavior).\n\n    Returns:\n        Option[Self]: `Some(self)` if self is truthy, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\n    Some(Seq(1, 2, 3))\n    &gt;&gt;&gt; pc.Seq([]).then_some()\n    NONE\n\n    ```\n    \"\"\"\n    from ._option import NONE, Some\n\n    return Some(self) if self else NONE\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.top_n","level":2,"title":"<code>top_n(n, key=None)</code>","text":"<p>Return a tuple of the top-n items according to key.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of top elements to return.</p> required <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to extract a comparison key from each element. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the top-n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\nSeq(3, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def top_n(self, n: int, key: Callable[[T], Any] | None = None) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the top-n items according to key.\n\n    Args:\n        n (int): Number of top elements to return.\n        key (Callable[[T], Any] | None): Function to extract a comparison key from each element. Defaults to None.\n\n    Returns:\n        Seq[T]: A new Seq containing the top-n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 3, 2]).top_n(2)\n    Seq(3, 2)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.topk(n, self._inner, key=key))\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.unzip","level":2,"title":"<code>unzip()</code>","text":"<p>Converts an iterator of pairs into a pair of iterators.</p> <p>Returns:</p> Type Description <code>Unzipped[U, V]</code> <p>Unzipped[U, V]: dataclass with first and second iterators.</p> <p><code>Iter.unzip()</code> consumes the iterator of pairs.</p> <p>Returns an Unzipped dataclass, containing two iterators:</p> <ul> <li>one from the left elements of the pairs</li> <li>one from the right elements.</li> </ul> <p>This function is, in some sense, the opposite of zip. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n&gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n&gt;&gt;&gt; unzipped.left.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; unzipped.right.collect()\nSeq('a', 'b', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unzip[U, V](self: BaseIter[tuple[U, V]]) -&gt; Unzipped[U, V]:\n    \"\"\"Converts an iterator of pairs into a pair of iterators.\n\n    Returns:\n        Unzipped[U, V]: dataclass with first and second iterators.\n\n    `Iter.unzip()` consumes the iterator of pairs.\n\n    Returns an Unzipped dataclass, containing two iterators:\n\n    - one from the left elements of the pairs\n    - one from the right elements.\n\n    This function is, in some sense, the opposite of zip.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n    &gt;&gt;&gt; unzipped = pc.Seq(data).unzip()\n    &gt;&gt;&gt; unzipped.left.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; unzipped.right.collect()\n    Seq('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    d: tuple[tuple[U, V], ...] = tuple(self._inner)\n    return Unzipped(Iter(x[0] for x in d), Iter(x[1] for x in d))\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]}]}