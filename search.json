{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"pyochain ‚õìÔ∏è","text":"<p>Functional-style method chaining for Python data structures.</p> <p>Welcome to the <code>pyochain</code> documentation! This library brings a fluent, declarative API inspired by Rust and DataFrame libraries to your Python iterables and dictionaries.</p> <ul> <li>Getting Started ‚Äî installation + quick start + next steps</li> <li>API Reference ‚Äî complete public API docs</li> <li>GitHub Repository</li> <li>Contributing Guide</li> <li>PyPI Package</li> </ul>","path":["pyochain ‚õìÔ∏è"],"tags":[]},{"location":"api-reference/","level":1,"title":"API Reference","text":"<p>This page is the entry point to the complete public API documentation.</p>","path":["API Reference"],"tags":[]},{"location":"api-reference/#collections","level":2,"title":"Collections","text":"<ul> <li><code>Seq[T]</code> ‚Äî Immutable collections (tuple-backed)</li> <li><code>Vec[T]</code> ‚Äî Mutable collections (list-backed)</li> <li><code>Set[T]</code> ‚Äî Immutable collections (frozenset-backed)</li> <li><code>SetMut[T]</code> ‚Äî Mutable sets (set-backed)</li> <li><code>Dict[K, V]</code> ‚Äî Chainable dictionaries</li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#iterators","level":2,"title":"Iterators","text":"<ul> <li><code>Iter[T]</code> ‚Äî Lazy processing of iterators</li> <li><code>Peekable</code> ‚Äî Peeking iterator</li> <li><code>Unzipped</code> ‚Äî Unzipped iterator results</li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#error-handling","level":2,"title":"Error handling","text":"<ul> <li><code>Result[T, E]</code> ‚Äî Explicit error handling (<code>Ok</code> / <code>Err</code>)</li> <li><code>Ok</code></li> <li><code>Err</code></li> <li><code>ResultUnwrapError</code></li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#optional-values","level":2,"title":"Optional values","text":"<ul> <li><code>Option[T]</code> ‚Äî Optional values (<code>Some</code> / <code>NONE</code>)</li> <li><code>Some</code></li> <li><code>None</code></li> <li><code>OptionUnwrapError</code></li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#traits-mixins","level":2,"title":"Traits &amp; mixins","text":"","path":["API Reference"],"tags":[]},{"location":"api-reference/#fluent-traits","level":3,"title":"Fluent Traits","text":"<ul> <li><code>Pipeable</code> ‚Äî <code>.into()</code>, <code>.inspect()</code></li> <li><code>Checkable</code> ‚Äî <code>.then()</code>, <code>.ok_or()</code>, ...</li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#abstract-collection-traits","level":3,"title":"Abstract Collection Traits","text":"<ul> <li><code>PyoIterable[T]</code> ‚Äî Base trait for all iterables</li> <li><code>PyoIterator[T]</code> ‚Äî Iterator trait</li> <li><code>PyoCollection[T]</code> ‚Äî Base trait for eager collections</li> <li><code>PyoSequence[T]</code> ‚Äî Sequence trait</li> <li><code>PyoMutableSequence[T]</code> ‚Äî Mutable sequence trait</li> <li><code>PyoSet[T]</code> ‚Äî Set trait</li> <li><code>PyoMappingView[T]</code> ‚Äî Mapping view trait</li> <li><code>PyoMapping[K, V]</code> ‚Äî Mapping trait</li> <li><code>PyoMutableMapping[K, V]</code> ‚Äî Mutable mapping trait</li> </ul>","path":["API Reference"],"tags":[]},{"location":"api-reference/#mapping-views","level":3,"title":"Mapping Views","text":"<ul> <li><code>PyoKeysView[K]</code> ‚Äî Keys view</li> <li><code>PyoValuesView[V]</code> ‚Äî Values view</li> <li><code>PyoItemsView[K, V]</code> ‚Äî Items view</li> </ul>","path":["API Reference"],"tags":[]},{"location":"core-types-overview/","level":1,"title":"Types Overview","text":"<p>Pyochain provides a comprehensive set of abstract base classes and concrete collection types, inspired by Python's <code>collections.abc</code> module and Rust's iterator patterns.</p>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#core-traits","level":2,"title":"Core Traits","text":"<p>Pyochain's type system is built on two categories of traits:</p> <ol> <li>Fluent traits (mixins) ‚Äî providing methods for fluent method chaining and conversion to <code>Option</code> and <code>Result</code> types</li> <li>Abstract collection traits ‚Äî mirroring Python's <code>collections.abc</code> hierarchy to ensure protocol compatibility</li> </ol> <p>For concrete examples of these traits in action, see the interoperability section.</p>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#fluent-traits-mixins","level":3,"title":"Fluent Traits (Mixins)","text":"<p>Fluent traits are mixins that can be added to any class to enable functional method composition. They depend only on <code>Self</code> for their implementation, making them universally applicable.</p> Trait Purpose Main Capabilities Inherited by <code>Pipeable</code> Functional chaining <code>into()</code>, <code>inspect()</code> for fluent method composition All pyochain objects <code>Checkable</code> Conditional operations <code>then()</code>, <code>ok_or()</code>, <code>err_or()</code> for wrapping in <code>Option</code>/<code>Result</code> All pyochain iterables + <code>Option</code> + <code>Result</code>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#abstract-collection-traits","level":3,"title":"Abstract Collection Traits","text":"<p>Abstract collection traits form a hierarchy that mirrors Python's <code>collections.abc</code> module. Each trait extends a specific protocol from <code>collections.abc</code>, inheriting its interface while adding pyochain-specific functionality through fluent traits.</p> <p>Concrete types must implement the required methods (dunders) to satisfy the protocol contract.</p> Trait Extends Inherits from <code>collections.abc</code> Required Methods (for concrete types) Concrete Types <code>PyoIterable[T]</code> <code>Pipeable</code>, <code>Checkable</code> <code>Iterable[T]</code> <code>__iter__</code> All pyochain collections <code>PyoIterator[T]</code> <code>PyoIterable[T]</code> <code>Iterator[T]</code> <code>__iter__</code>, <code>__next__</code> <code>Iter[T]</code> <code>PyoCollection[T]</code> <code>PyoIterable[T]</code> <code>Collection[T]</code> <code>__contains__</code>, <code>__iter__</code>, <code>__len__</code> All eager collections <code>PyoSequence[T]</code> <code>PyoCollection[T]</code> <code>Sequence[T]</code> <code>__getitem__</code>, <code>__len__</code> <code>Seq[T]</code> <code>PyoMutableSequence[T]</code> <code>PyoSequence[T]</code> <code>MutableSequence[T]</code> <code>__setitem__</code>, <code>__delitem__</code>, <code>insert</code> <code>Vec[T]</code> <code>PyoSet[T]</code> <code>PyoCollection[T]</code> <code>Set[T]</code> <code>__contains__</code>, <code>__iter__</code>, <code>__len__</code> <code>Set[T]</code>, <code>PyoKeysView[K]</code>, <code>PyoItemsView[K,V]</code> <code>PyoMappingView[T]</code> <code>PyoCollection[T]</code> <code>MappingView</code> <code>__len__</code> All mapping views <code>PyoMapping[K, V]</code> <code>PyoCollection[K]</code> <code>Mapping[K, V]</code> <code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code> <code>Dict[K,V]</code> (read-only interface) <code>PyoMutableMapping[K, V]</code> <code>PyoMapping[K, V]</code> <code>MutableMapping[K, V]</code> <code>__setitem__</code>, <code>__delitem__</code> <code>Dict[K,V]</code>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#concrete-collections-iterators","level":2,"title":"Concrete Collections &amp; Iterators","text":"<p>Pyochain provides concrete collection types that implement the abstract traits described above. All collections can be created from any object implementing Python's <code>Iterable</code> protocol.</p> <p>Since these types fully implement their corresponding <code>collections.abc</code> protocols by providing all required dunder methods, they can act as drop-in replacements for their Python standard library counterparts.</p>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#concrete-collection-types","level":3,"title":"Concrete Collection Types","text":"Type Underlying Structure Implements <code>collections.abc</code> Ordered Uniqueness Mutability <code>Iter[T]</code> <code>Iterator[T]</code> <code>Iterator[T]</code> N/A N/A N/A <code>Seq[T]</code> <code>tuple[T]</code> <code>Sequence[T]</code> Yes No No <code>Vec[T]</code> <code>list[T]</code> <code>MutableSequence[T]</code> Yes No Yes <code>Set[T]</code> <code>frozenset[T]</code> <code>Set[T]</code> No Yes No <code>SetMut[T]</code> <code>set[T]</code> <code>MutableSet[T]</code> No Yes Yes <code>Dict[K,V]</code> <code>dict[K, V]</code> <code>MutableMapping[K, V]</code> Yes Keys Yes <code>PyoKeysView[K]</code> <code>KeysView[K]</code> <code>KeysView[K]</code>, <code>Set[K]</code> No Yes No <code>PyoValuesView[V]</code> <code>ValuesView[V]</code> <code>ValuesView[V]</code> No No No <code>PyoItemsView[K,V]</code> <code>ItemsView[K,V]</code> <code>ItemsView[K,V]</code>, <code>Set[tuple[K,V]]</code> No Yes No","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#option-result-types","level":2,"title":"Option &amp; Result Types","text":"<p>Pyochain provides two fundamental types for explicit handling of nullable values and errors, both implementing the fluent traits (<code>Pipeable</code> and <code>Checkable</code>).</p>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#optiont","level":3,"title":"Option[T]","text":"<p><code>Option[T]</code> represents values that may or may not be present, serving as a type-safe alternative to using <code>None</code>. It provides methods to handle absence safely and fluently through method chaining.</p> <p>An <code>Option[T]</code> is either <code>Some(value)</code> when a value is present, or <code>NONE</code> when absent.</p>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#resultt-e","level":3,"title":"Result[T, E]","text":"<p><code>Result[T, E]</code> represents the outcome of operations that can succeed or fail, promoting explicit error handling without exceptions.</p> <p>A <code>Result[T, E]</code> is either <code>Ok(value)</code> for successful operations, or <code>Err(error)</code> for failures. Using <code>Result</code> as a return type clearly signals to callers that error handling is required.</p> Type Description Creation Python Equivalent <code>Option[T]</code> Optional value container (abstract) <code>Option(value)</code> - auto-dispatches to <code>Some</code> or <code>NONE</code> <code>T \\| None</code> <code>Some[T]</code> Represents a present value <code>Some(value)</code> or via <code>Option(value)</code> when value is not <code>None</code> <code>T</code> <code>NONE</code> Represents absence of value <code>NONE</code> (singleton) or via <code>Option(None)</code> <code>None</code> <code>Result[T, E]</code> Success or failure container (abstract) In functions with try/except pattern <code>T \\| E</code> <code>Ok[T]</code> Represents a successful result <code>Ok(value)</code> in try block or success path <code>T</code> <code>Err[E]</code> Represents a failed result <code>Err(error)</code> in except block or error path <code>Exception</code>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"core-types-overview/#graphical-overview","level":2,"title":"Graphical Overview","text":"<p>Below is a diagram showing the inheritance structure and trait implementation of shared types.</p> <pre><code>---\nconfig:\n  layout: elk\n---\nflowchart TB\n    Pipeable[\"Pipeable\"] ==&gt; PyoIterable[\"PyoIterable[T]\"] &amp; Result[\"Result[T, E]\"] &amp; Option[\"Option[T]\"]\n    Checkable[\"Checkable\"] ==&gt; PyoIterable\n    PyoIterable --&gt; PyoIterator[\"PyoIterator[T]\"] &amp; PyoCollection[\"PyoCollection[T]\"]\n    PyoIterator ==&gt; Iter[\"Iter[T]\"]\n    PyoCollection --&gt; PyoSequence[\"PyoSequence[T]\"] &amp; PyoSet[\"PyoSet[T]\"] &amp; PyoMappingView[\"PyoMappingView[T]\"] &amp; PyoMapping[\"PyoMapping[K,V]\"]\n    PyoSequence --&gt; PyoMutableSequence[\"PyoMutableSequence[T]\"]\n    PyoSequence ==&gt; Seq[\"Seq[T]\"]\n    PyoMutableSequence ==&gt; Vec[\"Vec[T]\"]\n    PyoSet ==&gt; Set[\"Set[T]\"] &amp; PyoKeysView[\"PyoKeysView[K]\"] &amp; PyoItemsView[\"PyoItemsView[K,V]\"]\n    PyoMappingView ==&gt; PyoKeysView &amp; PyoValuesView[\"PyoValuesView[V]\"] &amp; PyoItemsView\n    PyoMapping ==&gt; PyoMutableMapping[\"PyoMutableMapping[K,V]\"]\n    PyoMutableMapping ==&gt; Dict[\"Dict[K,V]\"]\n    Result ==&gt; Ok[\"Ok[T]\"] &amp; Err[\"Err[E]\"]\n    Option ==&gt; Some[\"Some[T]\"] &amp; NONE[\"NONE\"]\n    Set ==&gt; SetMut[\"SetMut[T]\"]\n    Seq ==&gt; Vec\n\n    style Pipeable stroke:#9C27B0,stroke-width:2px\n    style PyoIterable stroke:#00C853,stroke-width:2px\n    style Result stroke:#E53935,stroke-width:2px\n    style Option stroke:#FDD835,stroke-width:2px\n    style Checkable stroke:#9C27B0,stroke-width:2px\n    style PyoIterator stroke:#00C853,stroke-width:2px\n    style PyoCollection stroke:#00C853,stroke-width:2px\n    style Iter stroke:#1E88E5,stroke-width:2px\n    style PyoSequence stroke:#00C853,stroke-width:2px\n    style PyoSet stroke:#00C853,stroke-width:2px\n    style PyoMappingView stroke:#00C853,stroke-width:2px\n    style PyoMapping stroke:#00C853,stroke-width:2px\n    style PyoMutableSequence stroke:#00C853,stroke-width:2px\n    style Seq stroke:#1E88E5,stroke-width:2px\n    style Vec stroke:#1E88E5,stroke-width:2px\n    style Set stroke:#1E88E5,stroke-width:2px\n    style PyoKeysView stroke:#1E88E5,stroke-width:2px\n    style PyoItemsView stroke:#1E88E5,stroke-width:2px\n    style SetMut stroke:#1E88E5,stroke-width:2px\n    style PyoValuesView stroke:#1E88E5,stroke-width:2px\n    style PyoMutableMapping stroke:#00C853,stroke-width:2px\n    style Dict stroke:#1E88E5,stroke-width:2px\n    style Ok stroke:#E53935,stroke-width:2px\n    style Err stroke:#E53935,stroke-width:2px\n    style Some stroke:#FDD835,stroke-width:2px\n    style NONE stroke:#FDD835,stroke-width:2px\n    linkStyle 0 stroke:#9C27B0,stroke-width:2px,fill:none\n    linkStyle 1 stroke:#9C27B0,stroke-width:2px,fill:none\n    linkStyle 2 stroke:#AA00FF,stroke-width:2px,fill:none\n    linkStyle 3 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 4 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 5 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 6 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 7 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 8 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 9 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 10 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 11 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 12 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 13 stroke:#00C853,fill:none,stroke-width:2px\n    linkStyle 14 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 15 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 16 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 17 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 18 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 19 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 20 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 21 stroke:#00C853,stroke-width:2px,fill:none\n    linkStyle 22 stroke:#D50000,stroke-width:2px,fill:none\n    linkStyle 23 stroke:#D50000,stroke-width:2px,fill:none\n    linkStyle 24 stroke:#FFD600,stroke-width:2px,fill:none\n    linkStyle 25 stroke:#FFD600,stroke-width:2px,fill:none\n    linkStyle 26 stroke:#2962FF,fill:none,stroke-width:2px\n    linkStyle 27 stroke:#2962FF,fill:none,stroke-width:2px</code></pre>","path":["Getting Started","Types Overview"],"tags":[]},{"location":"examples/","level":1,"title":"Cookbook","text":"<p>This cookbook provides practical examples of how to use the <code>pyochain</code> library for various data manipulation tasks in Python. Each example demonstrates a specific use case, showcasing the power and flexibility of <code>pyochain</code> for functional programming and data processing.</p>","path":["Getting Started","Cookbook"],"tags":[]},{"location":"examples/#combining-option-result-and-iterators-in-data-pipelines","level":2,"title":"Combining Option, Result and Iterators in Data Pipelines","text":"<p>Classes have been designed to work seamlessly together, enabling complex data processing pipelines with clear error handling.</p> <p>Note: We return pc.Ok(None) for simplicity.</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; def safe_parse_int(s: str) -&gt; pc.Result[int, str]:\n...     try:\n...         return pc.Ok(int(s))\n...     except ValueError:\n...         return pc.Err(f\"Invalid integer: {s}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; def _run_ok(lf: pl.LazyFrame) -&gt; pc.Result[pl.LazyFrame, str]:\n...     \"\"\"Collect and run the pipeline.\"\"\"\n...     try:\n...         return pc.Ok(lf.filter(pl.col(\"value\").gt(15)))\n...     except (pl.exceptions.ComputeError) as e:\n...         return pc.Err(f\"Failed to write to file: {e}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = [\"10\", \"20\", \"foo\", \"30\", \"bar\"]\n&gt;&gt;&gt; results = (\n...    pc.Iter(data)\n...    .map(safe_parse_int)  # Parse each string safely\n...    .filter_map(lambda r: r.ok())  # Keep only successful parses\n...    .enumerate()  # Add indices\n...    .collect()  # Materialize the results\n...    .inspect(\n...        lambda seq: print(f\"Parsed integers: {seq}\") # Log parsed integers\n...    )\n...    .into(pl.LazyFrame, schema=[\"index\", \"value\"], orient=\"row\")  # Pass to Polars LazyFrame\n...    .pipe(_run_ok)  # Run the pipeline\n...    .map_err(lambda e: print(f\"Error: {e}\"))  # Print error message\n...    .map(lambda _: None)\n... )\nParsed integers: Seq((0, 10), (1, 20), (2, 30))\n&gt;&gt;&gt; results\nOk(None)\n</code></pre>","path":["Getting Started","Cookbook"],"tags":[]},{"location":"examples/#determining-all-public-methods-of-a-class","level":3,"title":"Determining All Public Methods of a Class","text":"<p>Below is an example of using pyochain to:</p> <p>1. extract all public methods of a class. 2. enumerate them 3. sort them by name 4. convert the first three into a dictionary.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; \n&gt;&gt;&gt; def get_public_methods(cls: type) -&gt; dict[int, str]:\n...     return (\n...         pc.Iter(cls.mro())\n...         .flat_map(lambda x: x.__dict__.values())\n...         .filter(lambda f: callable(f) and not f.__name__.startswith(\"_\"))\n...         .map(lambda f: f.__name__)\n...         .enumerate()\n...         .sort(key=lambda pair: pair[1])\n...         .iter()\n...         .take(3)\n...         .find(lambda x: x[1] ==\"all\")\n...         .unwrap()[1]\n...     )\n&gt;&gt;&gt;\n&gt;&gt;&gt; get_public_methods(pc.Iter)\n'all'\n</code></pre> <p>For comparison, here's the equivalent using pure Python:</p> <pre><code>&gt;&gt;&gt; import itertools\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; def get_public_methods_pure(cls: type) -&gt; tuple[int, str]:\n...     return next(\n...         filter(\n...             lambda pair: pair[1] == \"all\",\n...             itertools.islice(\n...                 sorted(\n...                     enumerate(\n...                         f.__name__\n...                         for f in itertools.chain.from_iterable(\n...                             map(lambda x: x.__dict__.values(), cls.mro())\n...                         )\n...                         if callable(f) and not f.__name__.startswith(\"_\")\n...                     ),\n...                     key=lambda pair: pair[1],\n...                 ),\n...                 3,\n...             ),\n...         )\n...     )[1]\n&gt;&gt;&gt;\n&gt;&gt;&gt; get_public_methods_pure(pc.Iter)\n'all'\n</code></pre>","path":["Getting Started","Cookbook"],"tags":[]},{"location":"getting-started/","level":1,"title":"Getting Started","text":"","path":["Getting Started"],"tags":[]},{"location":"getting-started/#installation","level":2,"title":"Installation","text":"<pre><code>uv add pyochain\n</code></pre>","path":["Getting Started"],"tags":[]},{"location":"getting-started/#quick-start","level":2,"title":"Quick start","text":"<pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; res: pc.Seq[int] = (\n...     pc.Iter.from_count(1)\n...     .filter(lambda x: x % 2 != 0)\n...     .map(lambda x: x**2)\n...     .take(5)\n...     .collect()\n... )\n&gt;&gt;&gt; res\nSeq(1, 9, 25, 49, 81)\n</code></pre>","path":["Getting Started"],"tags":[]},{"location":"getting-started/#next-steps","level":2,"title":"Next steps","text":"<ul> <li>Core Types Overview: choose between the various provided types</li> <li>Interoperability: convert between types with various methods</li> <li>Examples &amp; Cookbook: practical patterns and concrete examples</li> </ul>","path":["Getting Started"],"tags":[]},{"location":"interoperability/","level":1,"title":"Interoperability &amp; Chaining Guide","text":"<p>Pyochain is designed for fluent API usage. Most types can be converted into others seamlessly, allowing you to chain operations without breaking the flow.</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#shared-features","level":2,"title":"Shared Features","text":"<p>To enable this flexibility, Pyochain provides two core traits (mixins) that extend all types with powerful chaining and conditional logic capabilities.</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#pipeable-trait","level":3,"title":"Pipeable trait","text":"<p>All pyochain types implement <code>Pipeable</code>, providing universal methods to continue a chain:</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#intofunc-args-kwargs-r","level":4,"title":"<code>.into(func, *args, **kwargs) -&gt; R</code>","text":"<p>Convert <code>Self</code> to any type <code>R</code> via a function, maintaining fluent chaining.</p> <p>Conceptually, this replaces <code>f(x, args, kwargs)</code> with <code>x.into(f, args, kwargs)</code>.</p> <p>This is particularly useful when you need to pass the result to a function you don't control (like a library function), or to convert to a type not native to Pyochain.</p> <pre><code>&gt;&gt;&gt; import json\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Flow is broken, nested function calls, read from middle -&gt; right -&gt; left -&gt; right\n&gt;&gt;&gt; nested = json.dumps(\n...     dict(\n...         pc.Dict({\"id\": 1, \"name\": \"Alice\"})\n...         .items()\n...         .iter()\n...         .map_star(lambda k, v: (k.upper(), v))\n...     )\n... )\n&gt;&gt;&gt; nested\n'{\"ID\": 1, \"NAME\": \"Alice\"}'\n&gt;&gt;&gt; # Fluent chaining with .into(), read left -&gt; right\n&gt;&gt;&gt; fluent = (\n...     pc.Dict({\"id\": 1, \"name\": \"Alice\"})\n...     .items()\n...     .iter()\n...     .map_star(lambda k, v: (k.upper(), v))\n...     .into(lambda d: json.dumps(dict(d)))\n... )\n&gt;&gt;&gt; fluent\n'{\"ID\": 1, \"NAME\": \"Alice\"}'\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#inspectfunc-args-kwargs-self","level":4,"title":"<code>.inspect(func, *args, **kwargs) -&gt; Self</code>","text":"<p>Pass <code>Self</code> to a function for side effects (logging, debugging, metrics) without breaking the chain. The instance is returned unchanged.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).inspect(print).iter().map(lambda x: x * 2).collect()\nSeq(1, 2, 3)\nSeq(2, 4, 6)\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#checkable-trait","level":3,"title":"Checkable trait","text":"<p>Collections (<code>Seq</code>, <code>Vec</code>, <code>Set</code>, <code>SetMut</code>, <code>Dict</code>) and iterators (<code>Iter</code>) implement <code>Checkable</code>, providing conditional chaining based on truthiness (usually emptiness):</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#thenfunc-args-kwargs-optionr","level":4,"title":"<code>.then(func, *args, **kwargs) -&gt; Option[R]</code>","text":"<p>Call func and wrap result in <code>Some</code> only if the instance is truthy.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#then_some-optionself","level":4,"title":"<code>.then_some() -&gt; Option[Self]</code>","text":"<p>Wrap the instance in <code>Some</code> if truthy, otherwise <code>NONE</code>.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#ok_orerr-resultself-e","level":4,"title":"<code>.ok_or(err) -&gt; Result[Self, E]</code>","text":"<p>Wrap in <code>Ok</code> if truthy, otherwise wrap the error in <code>Err</code>.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty list\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty list\")\nErr('empty list')\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#ok_or_elsefunc-args-kwargs-resultself-e","level":4,"title":"<code>.ok_or_else(func, *args, **kwargs) -&gt; Result[Self, E]</code>","text":"<p>Wrap in <code>Ok</code> if truthy, otherwise call func and wrap result in <code>Err</code> (lazy evaluation).</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda _: \"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda _: \"empty\")\nErr('empty')\n</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#pyoiterable-pyocollection-traits","level":3,"title":"PyoIterable &amp; PyoCollection traits","text":"<p><code>PyoIterable[T]</code> and <code>PyoCollection[T]</code> are the foundational traits for all collection and iterator types in Pyochain.</p> <p>PyoIterable[T] extends <code>Pipeable</code>, <code>Checkable</code>, and Python's <code>Iterable[T]</code> protocol:</p> <ul> <li>Provides the base interface shared by all pyochain types (both lazy iterators and eager collections)</li> <li>Concrete types only need to implement <code>__iter__()</code> to satisfy the <code>Iterable[T]</code> protocol</li> <li>Adds common methods like <code>.length()</code>, <code>.sum()</code>, <code>.min()</code>, <code>.max()</code>, <code>.all()</code>, <code>.any()</code>, etc.</li> </ul> <p>PyoCollection[T] extends <code>PyoIterable[T]</code> and Python's <code>Collection[T]</code> protocol:</p> <ul> <li>Represents eager (in-memory) collections: <code>Seq</code>, <code>Vec</code>, <code>Set</code>, <code>SetMut</code>, <code>Dict</code>, and mapping views</li> <li>Concrete types must implement <code>__contains__()</code>, <code>__iter__()</code>, and <code>__len__()</code> to satisfy the protocol</li> <li><code>Iter[T]</code> (lazy iterator) does not extend this trait, only <code>PyoIterator[T]</code></li> </ul>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#from_ref-for-mutable-collections","level":4,"title":"from_ref() for mutable collections","text":"<p>All mutable collection types (<code>Vec</code>, <code>SetMut</code>, <code>Dict</code>) provide a <code>from_ref()</code> class method that creates a pyochain instance from a reference to an existing Python collection without copying.</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#examples","level":3,"title":"Examples","text":"<pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Vec from list\n&gt;&gt;&gt; py_list = [1, 2, 3]\n&gt;&gt;&gt; vec = pc.Vec.from_ref(py_list)\n&gt;&gt;&gt; vec.append(4)\n&gt;&gt;&gt; vec\nVec(1, 2, 3, 4)\n&gt;&gt;&gt; py_list  # original list is modified\n[1, 2, 3, 4]\n&gt;&gt;&gt; \n&gt;&gt;&gt; # SetMut from set\n&gt;&gt;&gt; py_set = {1, 2, 3}\n&gt;&gt;&gt; set_mut = pc.SetMut.from_ref(py_set)\n&gt;&gt;&gt; set_mut.add(4)\n&gt;&gt;&gt; set_mut\nSetMut(1, 2, 3, 4)\n&gt;&gt;&gt; py_set  # original set is modified\n{1, 2, 3, 4}\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Dict from dict\n&gt;&gt;&gt; py_dict = {\"a\": 1, \"b\": 2}\n&gt;&gt;&gt; pyo_dict = pc.Dict.from_ref(py_dict)\n&gt;&gt;&gt; pyo_dict.insert(\"c\", 3)\nNONE\n&gt;&gt;&gt; pyo_dict\nDict('a': 1, 'b': 2, 'c': 3)\n&gt;&gt;&gt; py_dict  # original dict is modified\n{'a': 1, 'b': 2, 'c': 3}\n</code></pre> <p>This allows fast, efficient no-copy conversions when dealing with external functions that return standard Python collections.</p> <p>Note: Immutable collections (<code>Seq</code>, <code>Set</code>) don't need <code>from_ref()</code> since their underlying types (<code>tuple</code>, <code>frozenset</code>) are already immutable and Python optimizes their creation automatically.</p>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"interoperability/#conversion-interoperability-map","level":2,"title":"Conversion &amp; Interoperability Map","text":"<p>The following graph illustrates all the built-in ways to convert between types in Pyochain.</p> <ul> <li>Types are grouped by category.</li> <li>Arrows color and direction represent conversion paths.</li> <li>Arrow labels represent methods.</li> </ul> <pre><code>---\nconfig:\n  layout: elk\n---\nflowchart TB\n subgraph Collections[\"üì¶ Collections (Eager)\"]\n    direction LR\n        Seq[\"&lt;b&gt;Seq[T]&lt;/b&gt;&lt;br&gt;immutable&lt;br&gt;tuple\"]\n        Vec[\"&lt;b&gt;Vec[T]&lt;/b&gt;&lt;br&gt;mutable&lt;br&gt;list\"]\n        Set[\"&lt;b&gt;Set[T]&lt;/b&gt;&lt;br&gt;immutable&lt;br&gt;frozenset\"]\n        SetMut[\"&lt;b&gt;SetMut[T]&lt;/b&gt;&lt;br&gt;mutable&lt;br&gt;set\"]\n  end\n subgraph Lazy[\"‚õìÔ∏è Lazy\"]\n    direction LR\n        Iter[\"&lt;b&gt;Iter[T]&lt;/b&gt;&lt;br&gt;lazy iterator&lt;br&gt;Iterator\"]\n  end\n subgraph DictGroup[\"üîë Dictionary\"]\n    direction LR\n        Dict[\"&lt;b&gt;Dict[K,V]&lt;/b&gt;&lt;br&gt;mutable&lt;br&gt;dict\"]\n  end\n subgraph OptionGroup[\"üéÅ Option Types\"]\n    direction LR\n        Option[\"&lt;b&gt;Option[T]&lt;/b&gt;\"]\n        Some[\"&lt;b&gt;Some[T]&lt;/b&gt;\"]\n        NONE[\"&lt;b&gt;NONE&lt;/b&gt;\"]\n  end\n subgraph ResultGroup[\"‚úÖ Result Types\"]\n    direction LR\n        Result[\"&lt;b&gt;Result[T,E]&lt;/b&gt;\"]\n        Ok[\"&lt;b&gt;Ok[T]&lt;/b&gt;\"]\n        Err[\"&lt;b&gt;Err[E]&lt;/b&gt;\"]\n  end\n subgraph External[\"üåê External Types\"]\n    direction LR\n        AnyType[\"&lt;b&gt;Any Type&lt;/b&gt;&lt;br&gt;via .into(func)\"]\n  end\n    Option -.-&gt; Some &amp; NONE\n    Result -.-&gt; Ok &amp; Err\n    Collections -- \".iter()\" --&gt; Lazy\n    Lazy -- \".collect()\" --&gt; Collections\n    Lazy -- \".collect(Dict)\" --&gt; DictGroup\n    DictGroup -- \".iter() ‚Üí Item[K,V]&lt;br&gt;.keys_iter() ‚Üí K&lt;br&gt;.values_iter() ‚Üí V\" --&gt; Lazy\n    OptionGroup -- \".iter()\" --&gt; Lazy\n    ResultGroup -- \".iter()\" --&gt; Lazy\n    DictGroup -- \".get_item(key)&lt;br&gt;.insert(key, val)&lt;br&gt;.remove(key)\" --&gt; OptionGroup\n    DictGroup -- \".try_insert(key, val)\" --&gt; ResultGroup\n    Collections -- \".then(func)&lt;br&gt;.then_some()\" --&gt; OptionGroup\n    Lazy -- \".then(func)&lt;br&gt;.then_some()\" --&gt; OptionGroup\n    DictGroup -- \".then(func)&lt;br&gt;.then_some()\" --&gt; OptionGroup\n    Collections -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    Lazy -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    DictGroup -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    OptionGroup -- \".ok_or(err)&lt;br&gt;.ok_or_else(func)\" --&gt; ResultGroup\n    ResultGroup -- \".ok()&lt;br&gt;.err()\" --&gt; OptionGroup\n    OptionGroup L_OptionGroup_ResultGroup_2@&lt;-- \".transpose()\" --&gt; ResultGroup\n    Collections -- \".into(func)\" --&gt; External\n    Lazy -- \".into(func)\" --&gt; External\n    DictGroup -- \".into(func)\" --&gt; External\n    OptionGroup -- \".into(func)\" --&gt; External\n    ResultGroup -- \".into(func)\" --&gt; External\n\n     Seq:::collectionsStyle\n     Vec:::collectionsStyle\n     Set:::collectionsStyle\n     SetMut:::collectionsStyle\n     Iter:::iterStyle\n     Dict:::dictStyle\n     Option:::optionStyle\n     Some:::optionStyle\n     NONE:::optionStyle\n     Result:::resultStyle\n     Ok:::resultStyle\n     Err:::resultStyle\n     AnyType:::externalStyle\n     Collections:::collectionsStyle\n     OptionGroup:::optionStyle\n     ResultGroup:::resultStyle\n    classDef collectionsStyle fill:#1e88e5,stroke:#0d47a1,stroke-width:2px,color:#fff\n    classDef iterStyle fill:#43a047,stroke:#1b5e20,stroke-width:2px,color:#fff\n    classDef dictStyle fill:#fb8c00,stroke:#e65100,stroke-width:2px,color:#fff\n    classDef optionStyle fill:#fdd835,stroke:#f57f17,stroke-width:2px,color:#000\n    classDef resultStyle fill:#e53935,stroke:#b71c1c,stroke-width:2px,color:#fff\n    classDef externalStyle fill:#9e9e9e,stroke:#424242,stroke-width:2px,color:#fff\n    style Seq color:none\n    style Vec color:none\n    style Set color:none\n    style SetMut color:none\n    style Dict fill:#FF6D00,color:none,stroke:#FF6D00\n    style Option color:#FFFFFF,fill:transparent,stroke:#FFD600\n    style Some color:#FFFFFF,fill:transparent,stroke:#FFD600\n    style NONE color:#FFFFFF,fill:transparent,stroke:#FFD600\n    style Result fill:#D50000\n    style Ok fill:#D50000\n    style Err fill:#D50000\n    style Collections fill:#000000,color:none,stroke:#2962FF\n    style Lazy fill:#000000,stroke:#00C853\n    style DictGroup fill:#000000,color:none,stroke:#FF6D00\n    style OptionGroup fill:#000000,color:#FFFFFF,stroke:#FFD600\n    style ResultGroup fill:#000000,stroke:#D50000\n    style External fill:#000000\n    linkStyle 0 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 1 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 2 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 3 stroke:#666,stroke-width:1px,stroke-dasharray:3,fill:none\n    linkStyle 4 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 5 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 6 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 7 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 8 stroke:#fdd835,stroke-width:2.5px,fill:none\n    linkStyle 9 stroke:#e53935,stroke-width:2.5px,fill:none\n    linkStyle 10 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 11 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 12 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 13 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 14 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 15 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 16 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 17 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 18 stroke:#fdd835,stroke-width:2.5px,fill:none\n    linkStyle 19 stroke:#e53935,stroke-width:2.5px,fill:none\n    linkStyle 20 stroke:#9c27b0,stroke-width:2.5px,fill:none\n    linkStyle 21 stroke:#1e88e5,stroke-width:2.5px,fill:none\n    linkStyle 22 stroke:#43a047,stroke-width:2.5px,fill:none\n    linkStyle 23 stroke:#fb8c00,stroke-width:2.5px,fill:none\n    linkStyle 24 stroke:#fdd835,stroke-width:2.5px,fill:none\n    linkStyle 25 stroke:#e53935,stroke-width:2.5px,fill:none\n\n    L_OptionGroup_ResultGroup_2@{ animation: none }</code></pre>","path":["Getting Started","Interoperability &amp; Chaining Guide"],"tags":[]},{"location":"reference/checkable/","level":1,"title":"Checkable","text":"<p>               Bases: <code>Protocol</code></p> <p>Mixin class providing conditional chaining methods based on truthiness.</p> <p>This class provides methods inspired by Rust's <code>bool</code> type for conditional execution and wrapping in <code>Option</code> or <code>Result</code> types.</p> <p>All methods evaluate the instance's truthiness to determine their behavior.</p>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.rs.Checkable.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to wrap in Err if self is falsy.</p> required <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: <code>Ok(self)</code> if self is truthy, <code>Err(err)</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or(\"empty\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or(\"empty\")\nErr('empty')\n</code></pre></p>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.rs.Checkable.ok_or_else","level":2,"title":"<code>ok_or_else(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in a <code>Result[Self, E]</code> based on its truthiness.</p> <p><code>E</code> being the return type of func.</p> <p>The function is only called if self evaluates to False.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], E]</code> <p>A callable that returns the error value to wrap in Err.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to the function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[Self, E]</code> <p>Result[Self, E]: Ok(self) if self is truthy, Err(f(...)) otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).ok_or_else(lambda s: f\"empty seq\")\nOk(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).ok_or_else(lambda s: f\"empty seq\")\nErr('empty seq')\n</code></pre></p>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.rs.Checkable.then","level":2,"title":"<code>then(func, *args, **kwargs)</code>","text":"<p>Wrap <code>Self</code> in an <code>Option[R]</code> based on its truthiness.</p> <p><code>R</code> being the return type of func.</p> <p>The function is only called if <code>Self</code> evaluates to <code>True</code> (lazy evaluation).</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>A callable that returns the value to wrap in Some.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: <code>Some(R)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then(lambda s: s.sum())\nSome(6)\n&gt;&gt;&gt; pc.Seq([]).then(lambda s: s.sum())\nNONE\n</code></pre></p>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/checkable/#pyochain.rs.Checkable.then_some","level":2,"title":"<code>then_some()</code>","text":"<p>Wraps <code>Self</code> in an <code>Option[Self]</code> based on its truthiness.</p> <p>Truthiness is determined by <code>__bool__()</code> if defined, otherwise by <code>__len__()</code> if defined (returning <code>False</code> if length is 0), otherwise all instances are truthy (Python's default behavior).</p> <p>Returns:</p> Type Description <code>Option[Self]</code> <p>Option[Self]: <code>Some(self)</code> if self is truthy, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).then_some()\nSome(Seq(1, 2, 3))\n&gt;&gt;&gt; pc.Seq([]).then_some()\nNONE\n</code></pre></p>","path":["API Reference","Traits & Mixins","Checkable"],"tags":[]},{"location":"reference/dict/","level":1,"title":"Dict","text":"<p>               Bases: <code>PyoMutableMapping[K, V]</code></p> <p>A <code>Dict</code> is a key-value store similar to Python's built-in <code>dict</code>, but with additional methods inspired by Rust's <code>HashMap</code>.</p> <p>Accept the same input types as the built-in <code>dict</code>, including <code>Mapping</code>, <code>Iterable</code> of key-value pairs, and objects implementing <code>__getitem__()</code> and <code>keys()</code>.</p> <p>Implement the <code>MutableMapping</code> interface, so all standard dictionary operations are supported.</p> Tip <p>Prefer using <code>Dict.from_ref</code> when wrapping existing dictionaries to avoid unnecessary copying.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DictConvertible[K, V]</code> <p>Initial data for the Dict that can converted to a dictionary.</p> required <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; dict_obj = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; dict_obj\nDict(1: 'a', 2: 'b')\n&gt;&gt;&gt; dict_obj.get_item(1)\nSome('a')\n&gt;&gt;&gt; dict_obj.items().iter().collect()\nSeq((1, 'a'), (2, 'b'))\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>class Dict[K, V](PyoMutableMapping[K, V]):\n    \"\"\"A `Dict` is a key-value store similar to Python's built-in `dict`, but with additional methods inspired by Rust's `HashMap`.\n\n    Accept the same input types as the built-in `dict`, including `Mapping`, `Iterable` of key-value pairs, and objects implementing `__getitem__()` and `keys()`.\n\n    Implement the `MutableMapping` interface, so all standard dictionary operations are supported.\n\n    Tip:\n        Prefer using `Dict.from_ref` when wrapping existing dictionaries to avoid unnecessary copying.\n\n    Args:\n        data (DictConvertible[K, V]): Initial data for the Dict that can converted to a dictionary.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; dict_obj = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; dict_obj\n    Dict(1: 'a', 2: 'b')\n    &gt;&gt;&gt; dict_obj.get_item(1)\n    Some('a')\n    &gt;&gt;&gt; dict_obj.items().iter().collect()\n    Seq((1, 'a'), (2, 'b'))\n\n    ```\n    \"\"\"\n\n    __slots__ = (\"_inner\",)\n    _inner: dict[K, V]\n\n    def __init__(self, data: DictConvertible[K, V]) -&gt; None:\n        self._inner = dict(data)\n\n    def __repr__(self) -&gt; str:\n        from pprint import pformat\n\n        return (\n            f\"{self.__class__.__name__}({pformat(self._inner, sort_dicts=False)[1:-1]})\"\n        )\n\n    def __iter__(self) -&gt; Iterator[K]:\n        return iter(self._inner)\n\n    def __len__(self) -&gt; int:\n        return len(self._inner)\n\n    def __getitem__(self, key: K) -&gt; V:\n        return self._inner[key]\n\n    def __setitem__(self, key: K, value: V) -&gt; None:\n        self._inner[key] = value\n\n    def __delitem__(self, key: K) -&gt; None:\n        del self._inner[key]\n\n    @staticmethod\n    def from_ref[K1, V1](data: dict[K1, V1]) -&gt; Dict[K1, V1]:\n        \"\"\"Wrap an existing `dict` without copying.\n\n        This is the recommended way to create a `Dict` from foreign functions that return a standard Python `dict`.\n\n        Warning:\n            Any modifications made to this `Dict` will also affect the original, and vice versa.\n\n        Args:\n            data (dict[K1, V1]): The dictionary to wrap.\n\n        Returns:\n            Dict[K1, V1]: A new `Dict` instance wrapping the provided dictionary.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; original_dict = {1: \"a\", 2: \"b\", 3: \"c\"}\n        &gt;&gt;&gt; dict_obj = pc.Dict.from_ref(original_dict)\n        &gt;&gt;&gt; dict_obj\n        Dict(1: 'a', 2: 'b', 3: 'c')\n        &gt;&gt;&gt; dict_obj.insert(1, \"z\")\n        Some('a')\n        &gt;&gt;&gt; original_dict\n        {1: 'z', 2: 'b', 3: 'c'}\n\n        ```\n        \"\"\"\n        instance: Dict[K1, V1] = Dict.__new__(Dict)  # pyright: ignore[reportUnknownVariableType]\n        instance._inner = data\n        return instance\n\n    @staticmethod\n    def from_kwargs[U](**kwargs: U) -&gt; Dict[str, U]:\n        \"\"\"Create a `Dict` from keyword arguments.\n\n        Args:\n            **kwargs (U): Key-value pairs to initialize the Dict.\n\n        Returns:\n            Dict[str, U]: A new Dict instance containing the provided key-value pairs.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Dict.from_kwargs(a=1, b=2)\n        Dict('a': 1, 'b': 2)\n\n        ```\n        \"\"\"\n        return Dict.from_ref(kwargs)\n\n    @staticmethod\n    def from_object(obj: object) -&gt; Dict[str, Any]:\n        \"\"\"Create a `Dict` from an object `__dict__` attribute.\n\n        We can't know in advance the values types, so we use `Any`.\n\n        Args:\n            obj (object): The object whose `__dict__` attribute will be used to create the Dict.\n\n        Returns:\n            Dict[str, Any]: A new Dict instance containing the attributes of the object.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; class Person:\n        ...     def __init__(self, name: str, age: int):\n        ...         self.name = name\n        ...         self.age = age\n        &gt;&gt;&gt; person = Person(\"Alice\", 30)\n        &gt;&gt;&gt; pc.Dict.from_object(person)\n        Dict('name': 'Alice', 'age': 30)\n\n        ```\n        \"\"\"\n        return Dict.from_ref(obj.__dict__)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.from_kwargs","level":2,"title":"<code>from_kwargs(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Create a <code>Dict</code> from keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <code>U</code> <p>Key-value pairs to initialize the Dict.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, U]</code> <p>Dict[str, U]: A new Dict instance containing the provided key-value pairs.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Dict.from_kwargs(a=1, b=2)\nDict('a': 1, 'b': 2)\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>@staticmethod\ndef from_kwargs[U](**kwargs: U) -&gt; Dict[str, U]:\n    \"\"\"Create a `Dict` from keyword arguments.\n\n    Args:\n        **kwargs (U): Key-value pairs to initialize the Dict.\n\n    Returns:\n        Dict[str, U]: A new Dict instance containing the provided key-value pairs.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Dict.from_kwargs(a=1, b=2)\n    Dict('a': 1, 'b': 2)\n\n    ```\n    \"\"\"\n    return Dict.from_ref(kwargs)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.from_object","level":2,"title":"<code>from_object(obj)</code>  <code>staticmethod</code>","text":"<p>Create a <code>Dict</code> from an object <code>__dict__</code> attribute.</p> <p>We can't know in advance the values types, so we use <code>Any</code>.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>The object whose <code>__dict__</code> attribute will be used to create the Dict.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: A new Dict instance containing the attributes of the object.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; class Person:\n...     def __init__(self, name: str, age: int):\n...         self.name = name\n...         self.age = age\n&gt;&gt;&gt; person = Person(\"Alice\", 30)\n&gt;&gt;&gt; pc.Dict.from_object(person)\nDict('name': 'Alice', 'age': 30)\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>@staticmethod\ndef from_object(obj: object) -&gt; Dict[str, Any]:\n    \"\"\"Create a `Dict` from an object `__dict__` attribute.\n\n    We can't know in advance the values types, so we use `Any`.\n\n    Args:\n        obj (object): The object whose `__dict__` attribute will be used to create the Dict.\n\n    Returns:\n        Dict[str, Any]: A new Dict instance containing the attributes of the object.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; class Person:\n    ...     def __init__(self, name: str, age: int):\n    ...         self.name = name\n    ...         self.age = age\n    &gt;&gt;&gt; person = Person(\"Alice\", 30)\n    &gt;&gt;&gt; pc.Dict.from_object(person)\n    Dict('name': 'Alice', 'age': 30)\n\n    ```\n    \"\"\"\n    return Dict.from_ref(obj.__dict__)\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/dict/#pyochain._dict.Dict.from_ref","level":2,"title":"<code>from_ref(data)</code>  <code>staticmethod</code>","text":"<p>Wrap an existing <code>dict</code> without copying.</p> <p>This is the recommended way to create a <code>Dict</code> from foreign functions that return a standard Python <code>dict</code>.</p> Warning <p>Any modifications made to this <code>Dict</code> will also affect the original, and vice versa.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[K1, V1]</code> <p>The dictionary to wrap.</p> required <p>Returns:</p> Type Description <code>Dict[K1, V1]</code> <p>Dict[K1, V1]: A new <code>Dict</code> instance wrapping the provided dictionary.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; original_dict = {1: \"a\", 2: \"b\", 3: \"c\"}\n&gt;&gt;&gt; dict_obj = pc.Dict.from_ref(original_dict)\n&gt;&gt;&gt; dict_obj\nDict(1: 'a', 2: 'b', 3: 'c')\n&gt;&gt;&gt; dict_obj.insert(1, \"z\")\nSome('a')\n&gt;&gt;&gt; original_dict\n{1: 'z', 2: 'b', 3: 'c'}\n</code></pre></p> Source code in <code>src/pyochain/_dict.py</code> <pre><code>@staticmethod\ndef from_ref[K1, V1](data: dict[K1, V1]) -&gt; Dict[K1, V1]:\n    \"\"\"Wrap an existing `dict` without copying.\n\n    This is the recommended way to create a `Dict` from foreign functions that return a standard Python `dict`.\n\n    Warning:\n        Any modifications made to this `Dict` will also affect the original, and vice versa.\n\n    Args:\n        data (dict[K1, V1]): The dictionary to wrap.\n\n    Returns:\n        Dict[K1, V1]: A new `Dict` instance wrapping the provided dictionary.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; original_dict = {1: \"a\", 2: \"b\", 3: \"c\"}\n    &gt;&gt;&gt; dict_obj = pc.Dict.from_ref(original_dict)\n    &gt;&gt;&gt; dict_obj\n    Dict(1: 'a', 2: 'b', 3: 'c')\n    &gt;&gt;&gt; dict_obj.insert(1, \"z\")\n    Some('a')\n    &gt;&gt;&gt; original_dict\n    {1: 'z', 2: 'b', 3: 'c'}\n\n    ```\n    \"\"\"\n    instance: Dict[K1, V1] = Dict.__new__(Dict)  # pyright: ignore[reportUnknownVariableType]\n    instance._inner = data\n    return instance\n</code></pre>","path":["API Reference","Collections","Dict"],"tags":[]},{"location":"reference/err/","level":1,"title":"Err","text":"<p>               Bases: <code>Result[T, E]</code></p> <p>Represents an error value.</p> <p>For more documentation, see the <code>Result[T, E]</code> class.</p> <p>Attributes:</p> Name Type Description <code>error</code> <code>E</code> <p>The contained error value.</p>","path":["API Reference","Error Handling","Err"],"tags":[]},{"location":"reference/iter/","level":1,"title":"Iter","text":"<p>               Bases: <code>PyoIterator[T]</code></p> <p>A superset around Python's built-in <code>Iterator</code> Protocol, providing a rich set of functional programming tools.</p> <p>Implements the <code>Iterator</code> Protocol from <code>collections.abc</code>, so it can be used as a standard iterator.</p> <p>It also provides a <code>__bool__()</code> method to check for emptiness without consuming elements.</p> <ul> <li>An <code>Iterable</code> is any object capable of returning its members one at a time, permitting it to be iterated over in a for-loop.</li> <li>An <code>Iterator</code> is an object representing a stream of data; returned by calling <code>iter()</code> on an <code>Iterable</code>.</li> <li>Once an <code>Iterator</code> is exhausted, it cannot be reused or reset.</li> </ul> <p>It's designed around lazy evaluation, allowing for efficient processing of large datasets.</p> <p>Instanciating it from any <code>Iterable</code> (like lists, sets, generators, etc.) is free and efficient (it only calls the builtin <code>iter()</code> on the input).</p> <p>Once an <code>Iter</code> is created, it can be transformed and manipulated using a variety of chainable methods.</p> <p>However, keep in mind that <code>Iter</code> instances are single-use; once exhausted, they cannot be reused or reset.</p> <p>If you need to reuse the data, consider collecting it into a collection first with <code>.collect()</code>, or clone it <code>.cloned()</code> to create an independent copy.</p> <p>You can always convert back to an <code>Iter</code> using <code>.iter()</code> for free on any pyochain collection type.</p> <p>In general, avoid intermediate references when dealing with lazy iterators, and prioritize method chaining instead.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>Any object that can be iterated over.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Iter[T](PyoIterator[T]):\n    \"\"\"A superset around Python's built-in `Iterator` Protocol, providing a rich set of functional programming tools.\n\n    Implements the `Iterator` Protocol from `collections.abc`, so it can be used as a standard iterator.\n\n    It also provides a `__bool__()` method to check for emptiness without consuming elements.\n\n    - An `Iterable` is any object capable of returning its members one at a time, permitting it to be iterated over in a for-loop.\n    - An `Iterator` is an object representing a stream of data; returned by calling `iter()` on an `Iterable`.\n    - Once an `Iterator` is exhausted, it cannot be reused or reset.\n\n    It's designed around lazy evaluation, allowing for efficient processing of large datasets.\n\n    Instanciating it from any `Iterable` (like lists, sets, generators, etc.) is free and efficient (it only calls the builtin `iter()` on the input).\n\n    Once an `Iter` is created, it can be transformed and manipulated using a variety of chainable methods.\n\n    However, keep in mind that `Iter` instances are single-use; once exhausted, they cannot be reused or reset.\n\n    If you need to reuse the data, consider collecting it into a collection first with `.collect()`, or clone it `.cloned()` to create an independent copy.\n\n    You can always convert back to an `Iter` using `.iter()` for free on any pyochain collection type.\n\n    In general, avoid intermediate references when dealing with lazy iterators, and prioritize method chaining instead.\n\n    Args:\n        data (Iterable[T]): Any object that can be iterated over.\n    \"\"\"\n\n    _inner: Iterator[T]\n    __slots__ = (\"_inner\",)\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = iter(data)\n\n    def __iter__(self) -&gt; Iterator[T]:\n        return self._inner\n\n    def __next__(self) -&gt; T:\n        return next(self._inner)\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Check if the `Iterator` has at least one element (mutates **self**).\n\n        After calling this, the `Iterator` still contains all elements.\n\n        Returns:\n            bool: True if the `Iterator` has at least one element, False otherwise.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; it = pc.Iter([1, 2, 3])\n        &gt;&gt;&gt; bool(it)\n        True\n        &gt;&gt;&gt; it.collect()  # All elements still available\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        first = tuple(itertools.islice(self._inner, 1))\n        self._inner = itertools.chain(first, self._inner)\n        return len(first) &gt; 0\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self._inner.__repr__()})\"\n\n    @classmethod\n    def from_ref(cls, other: Self) -&gt; Self:\n        \"\"\"Create an independent lazy copy from another `Iter`.\n\n        Both the original and the returned `Iter` can be consumed independently, in a lazy manner.\n\n        Note:\n            Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.\n\n            This is the unavoidable cost of having two independent iterators over the same source.\n\n            However, once both iterators have passed a value, it's freed from memory.\n\n        See Also:\n            - `Iter.cloned()` which is the instance method version of this function.\n\n        Args:\n            other (Self): An `Iter` instance to copy.\n\n        Returns:\n            Self: A new `Iter` instance that is independent from the original.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; original = pc.Iter([1, 2, 3])\n        &gt;&gt;&gt; copy = pc.Iter.from_ref(original)\n        &gt;&gt;&gt; copy.map(lambda x: x * 2).collect()\n        Seq(2, 4, 6)\n        &gt;&gt;&gt; original.next()\n        Some(1)\n\n        ```\n        \"\"\"\n        it1, it2 = itertools.tee(other._inner)\n        other._inner = it1\n        return cls(it2)\n\n    @staticmethod\n    def once[V](value: V) -&gt; Iter[V]:\n        \"\"\"Create an `Iter` that yields a single value.\n\n        If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n        This can be considered the equivalent of `.insert()` but as a constructor.\n\n        Args:\n            value (V): The single value to yield.\n\n        Returns:\n            Iter[V]: An iterator yielding the specified value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter.once(42).collect()\n        Seq(42,)\n\n        ```\n        \"\"\"\n        return Iter((value,))\n\n    @staticmethod\n    def once_with[**P, R](\n        func: Callable[P, R], *args: P.args, **kwargs: P.kwargs\n    ) -&gt; Iter[R]:\n        \"\"\"Create an `Iter`  that lazily generates a value exactly once by invoking the provided closure.\n\n        If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n        This can be considered the equivalent of `.insert()` but as a constructor.\n\n        Unlike `.once()`, this function will lazily generate the value on request.\n\n        Args:\n            func (Callable[P, R]): The single value to yield.\n            *args (P.args): Positional arguments to pass to **func**.\n            **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n        Returns:\n            Iter[R]: An iterator yielding the specified value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter.once(42).collect()\n        Seq(42,)\n\n        ```\n        \"\"\"\n\n        def _once_with() -&gt; Generator[R]:\n            yield func(*args, **kwargs)\n\n        return Iter(_once_with())\n\n    @staticmethod\n    def from_count(start: int = 0, step: int = 1) -&gt; Iter[int]:\n        \"\"\"Create an infinite `Iterator` of evenly spaced values.\n\n        Warning:\n            This creates an infinite iterator.\n\n            Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n        Args:\n            start (int): Starting value of the sequence.\n            step (int): Difference between consecutive values.\n\n        Returns:\n            Iter[int]: An iterator generating the sequence.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter.from_count(10, 2).take(3).collect()\n        Seq(10, 12, 14)\n\n        ```\n        \"\"\"\n        return Iter(itertools.count(start, step))\n\n    @staticmethod\n    def from_fn[R](f: Callable[[], Option[R]]) -&gt; Iter[R]:\n        \"\"\"Create an `Iter` from a nullary generator function.\n\n        The callable must return:\n\n        - `Some(value)` to yield a value\n        - `NONE` to stop\n\n\n        Args:\n            f (Callable[[], Option[R]]): Callable that returns the next item wrapped in `Option`.\n\n        Returns:\n            Iter[R]: An iterator yielding values produced by **f**.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; counter = 0\n        &gt;&gt;&gt; def gen() -&gt; pc.Option[int]:\n        ...     global counter\n        ...     counter += 1\n        ...     return pc.Some(counter) if counter &lt; 6 else pc.NONE\n        &gt;&gt;&gt; pc.Iter.from_fn(gen).collect()\n        Seq(1, 2, 3, 4, 5)\n\n        ```\n        \"\"\"\n\n        def _from_fn() -&gt; Iterator[R]:\n            while True:\n                item = f()\n                if item.is_none():\n                    return\n                yield item.unwrap()\n\n        return Iter(_from_fn())\n\n    @staticmethod\n    def successors[U](first: Option[U], succ: Callable[[U], Option[U]]) -&gt; Iter[U]:\n        \"\"\"Create an iterator of successive values computed from the previous one.\n\n        The iterator yields `first` (if it is `Some`), then repeatedly applies **succ** to the\n        previous yielded value until it returns `NONE`.\n\n        Args:\n            first (Option[U]): Initial item.\n            succ (Callable[[U], Option[U]]): Successor function.\n\n        Returns:\n            Iter[U]: Iterator yielding `first` and its successors.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def next_pow10(x: int) -&gt; pc.Option[int]:\n        ...     return pc.Some(x * 10) if x &lt; 10_000 else pc.NONE\n        &gt;&gt;&gt; pc.Iter.successors(pc.Some(1), next_pow10).collect()\n        Seq(1, 10, 100, 1000, 10000)\n\n        ```\n        \"\"\"\n\n        def _successors() -&gt; Iterator[U]:\n            current = first\n            while current.is_some():\n                value = current.unwrap()\n                yield value\n                current = succ(value)\n\n        return Iter(_successors())\n\n    def collect[R: Collection[Any]](\n        self, collector: Callable[[Iterator[T]], R] = Seq[T]\n    ) -&gt; R:\n        \"\"\"Transforms an `Iter` into a collection.\n\n        The most basic pattern in which collect() is used is to turn one collection into another.\n\n        You take a collection, call `iter()` on it, do a bunch of transformations, and then `collect()` at the end.\n\n        You can specify the target collection type by providing a **collector** function or type.\n\n        This can be any `Callable` that takes an `Iterator[T]` and returns a `Collection[T]` of those types.\n\n        Note:\n            This can be tought as `.into()` with a default value (`Seq[T]`), and a different constraint (`Collection[Any]`).\n            However, the runtime behavior is identical in both cases: pass **self** to the provided function, return the result.\n\n        Args:\n            collector (Callable[[Iterator[T]], R]): Function|type that defines the target collection. `R` is constrained to a `Collection`.\n\n        Returns:\n            R: A materialized collection containing the collected elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(range(5)).collect()\n        Seq(0, 1, 2, 3, 4)\n        &gt;&gt;&gt; iterator = pc.Iter((1, 2, 3))\n        &gt;&gt;&gt; iterator._inner.__class__.__name__\n        'tuple_iterator'\n        &gt;&gt;&gt; mapped = iterator.map(lambda x: x * 2)\n        &gt;&gt;&gt; mapped._inner.__class__.__name__\n        'map'\n        &gt;&gt;&gt; mapped.collect()\n        Seq(2, 4, 6)\n        &gt;&gt;&gt; # iterator is now exhausted\n        &gt;&gt;&gt; iterator.collect()\n        Seq()\n        &gt;&gt;&gt; pc.Iter(range(5)).collect(list)\n        [0, 1, 2, 3, 4]\n        &gt;&gt;&gt; pc.Iter(range(5)).collect(pc.Vec)\n        Vec(0, 1, 2, 3, 4)\n        &gt;&gt;&gt; iterator = pc.Iter([1, 2, 3])\n        &gt;&gt;&gt; iterator._inner.__class__.__name__\n        'list_iterator'\n\n        ```\n        \"\"\"\n        return collector(self._inner)\n\n    @overload\n    def collect_into(self, collection: Vec[T]) -&gt; Vec[T]: ...\n    @overload\n    def collect_into(self, collection: list[T]) -&gt; list[T]: ...\n    def collect_into(self, collection: MutableSequence[T]) -&gt; MutableSequence[T]:\n        \"\"\"Collects all the items from the `Iterator` into a `MutableSequence`.\n\n        This method consumes the `Iterator` and adds all its items to the passed `MutableSequence`.\n\n        The `MutableSequence` is then returned, so the call chain can be continued.\n\n        This is useful when you already have a `MutableSequence` and want to add the `Iterator` items to it.\n\n        This method is a convenience method to call `MutableSequence.extend()`, but instead of being called on a `MutableSequence`, it's called on an `Iterator`.\n\n        Args:\n            collection (MutableSequence[T]): A mutable collection to collect items into.\n\n        Returns:\n            MutableSequence[T]: The same mutable collection passed as argument, now containing the collected items.\n\n        Example:\n        Basic usage:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; a = pc.Seq([1, 2, 3])\n        &gt;&gt;&gt; vec = pc.Vec([0, 1])\n        &gt;&gt;&gt; a.iter().map(lambda x: x * 2).collect_into(vec)\n        Vec(0, 1, 2, 4, 6)\n        &gt;&gt;&gt; a.iter().map(lambda x: x * 10).collect_into(vec)\n        Vec(0, 1, 2, 4, 6, 10, 20, 30)\n\n        ```\n        The returned mutable sequence can be used to continue the call chain:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; a = pc.Seq([1, 2, 3])\n        &gt;&gt;&gt; vec = pc.Vec[int].new()\n        &gt;&gt;&gt; a.iter().collect_into(vec).length() == vec.length()\n        True\n        &gt;&gt;&gt; a.iter().collect_into(vec).length() == vec.length()\n        True\n\n        ```\n        \"\"\"\n        collection.extend(self._inner)\n        return collection\n\n    def try_collect[U](self: Iter[Option[U]] | Iter[Result[U, Any]]) -&gt; Option[Vec[U]]:\n        \"\"\"Fallibly transforms **self** into a `Vec`, short circuiting if a failure is encountered.\n\n        `try_collect()` is a variation of `collect()` that allows fallible conversions during collection.\n\n        Its main use case is simplifying conversions from iterators yielding `Option[T]` or `Result[T, E]` into `Option[Vec[T]]`.\n\n        Also, if a failure is encountered during `try_collect()`, the `Iter` is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure.\n\n        See the last example below for an example of how this works.\n\n        Note:\n            This method return `Vec[U]` instead of being customizable, because the underlying data structure must be mutable in order to build up the collection.\n\n        Returns:\n            Option[Vec[U]]: `Some[Vec[U]]` if all elements were successfully collected, or `NONE` if a failure was encountered.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Successfully collecting an iterator of Option[int] into Option[Vec[int]]:\n        &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.Some(3)]).try_collect()\n        Some(Vec(1, 2, 3))\n        &gt;&gt;&gt; # Failing to collect in the same way:\n        &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.NONE, pc.Some(3)]).try_collect()\n        NONE\n        &gt;&gt;&gt; # A similar example, but with Result:\n        &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Ok(2), pc.Ok(3)]).try_collect()\n        Some(Vec(1, 2, 3))\n        &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Err(\"error\"), pc.Ok(3)]).try_collect()\n        NONE\n        &gt;&gt;&gt; def external_fn(x: int) -&gt; pc.Option[int]:\n        ...     if x % 2 == 0:\n        ...         return pc.Some(x)\n        ...     return pc.NONE\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map(external_fn).try_collect()\n        NONE\n        &gt;&gt;&gt; # Demonstrating that the iterator remains usable after a failure:\n        &gt;&gt;&gt; it = pc.Iter([pc.Some(1), pc.NONE, pc.Some(3), pc.Some(4)])\n        &gt;&gt;&gt; it.try_collect()\n        NONE\n        &gt;&gt;&gt; it.try_collect()\n        Some(Vec(3, 4))\n\n        ```\n        \"\"\"\n        collected: list[U] = []\n        collected_add = collected.append\n        for item in self._inner:\n            match item:\n                case Ok(val) | Some(val):\n                    collected_add(val)\n                case _:\n                    return NONE\n        return Some(Vec.from_ref(collected))\n\n    def array_chunks(self, size: int) -&gt; Iter[Self]:\n        \"\"\"Yield subiterators (chunks) that each yield a fixed number elements, determined by size.\n\n        The last chunk will be shorter if there are not enough elements.\n\n        Args:\n            size (int): Number of elements in each chunk.\n\n        Returns:\n            Iter[Self]: An iterable of iterators, each yielding n elements.\n\n        If the sub-iterables are read in order, the elements of *iterable*\n        won't be stored in memory.\n\n        If they are read out of order, :func:`itertools.tee` is used to cache\n        elements as necessary.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; all_chunks = pc.Iter.from_count().array_chunks(4)\n        &gt;&gt;&gt; c_1, c_2, c_3 = all_chunks.next(), all_chunks.next(), all_chunks.next()\n        &gt;&gt;&gt; c_2.unwrap().collect()  # c_1's elements have been cached; c_3's haven't been\n        Seq(4, 5, 6, 7)\n        &gt;&gt;&gt; c_1.unwrap().collect()\n        Seq(0, 1, 2, 3)\n        &gt;&gt;&gt; c_3.unwrap().collect()\n        Seq(8, 9, 10, 11)\n        &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n        Seq(Seq(1, 2, 3), Seq(4, 5, 6))\n        &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6, 7, 8]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n        Seq(Seq(1, 2, 3), Seq(4, 5, 6), Seq(7, 8))\n\n        ```\n        \"\"\"\n        from collections import deque\n        from contextlib import suppress\n\n        def _chunks() -&gt; Iterator[Self]:\n            def _ichunk(\n                iterator: Iterator[T], n: int\n            ) -&gt; tuple[Iterator[T], Callable[[int], int]]:\n                cache: deque[T] = deque()\n                chunk = itertools.islice(iterator, n)\n\n                def _generator() -&gt; Iterator[T]:\n                    with suppress(StopIteration):\n                        while True:\n                            if cache:\n                                yield cache.popleft()\n                            else:\n                                yield next(chunk)\n\n                def _materialize_next(n: int) -&gt; int:\n                    to_cache = n - len(cache)\n\n                    # materialize up to n\n                    if to_cache &gt; 0:\n                        cache.extend(itertools.islice(chunk, to_cache))\n\n                    # return number materialized up to n\n                    return min(n, len(cache))\n\n                return (_generator(), _materialize_next)\n\n            new = self.__class__\n            while True:\n                # Create new chunk\n                chunk, _materialize_next = _ichunk(self._inner, size)\n\n                # Check to see whether we're at the end of the source iterable\n                if not _materialize_next(size):\n                    return\n\n                yield new(chunk)\n                _materialize_next(size)\n\n        return Iter(_chunks())\n\n    @overload\n    def flatten[U](self: Iter[KeysView[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Iterable[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Generator[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[ValuesView[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Iterator[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Collection[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Sequence[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[list[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[tuple[U, ...]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Iter[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Seq[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Set[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[SetMut[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten[U](self: Iter[Vec[U]]) -&gt; Iter[U]: ...\n    @overload\n    def flatten(self: Iter[range]) -&gt; Iter[int]: ...\n    def flatten[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Any]:\n        \"\"\"Creates an `Iter` that flattens nested structure.\n\n        Returns:\n            Iter[Any]: An `Iter` of flattened elements.\n\n        This is useful when you have an `Iter` of `Iterable` and you want to remove one level of indirection.\n\n        Examples:\n        Basic usage:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = [[1, 2, 3, 4], [5, 6]]\n        &gt;&gt;&gt; flattened = pc.Iter(data).flatten().collect()\n        &gt;&gt;&gt; flattened\n        Seq(1, 2, 3, 4, 5, 6)\n\n        ```\n        Mapping and then flattening:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; words = pc.Iter([\"alpha\", \"beta\", \"gamma\"])\n        &gt;&gt;&gt; merged = words.flatten().collect()\n        &gt;&gt;&gt; merged\n        Seq('a', 'l', 'p', 'h', 'a', 'b', 'e', 't', 'a', 'g', 'a', 'm', 'm', 'a')\n\n        ```\n        Flattening only removes one level of nesting at a time:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n        &gt;&gt;&gt; d2 = pc.Iter(d3).flatten().collect()\n        &gt;&gt;&gt; d2\n        Seq([1, 2], [3, 4], [5, 6], [7, 8])\n        &gt;&gt;&gt; d1 = pc.Iter(d3).flatten().flatten().collect()\n        &gt;&gt;&gt; d1\n        Seq(1, 2, 3, 4, 5, 6, 7, 8)\n\n        ```\n        Here we see that `flatten()` does not perform a ‚Äúdeep‚Äù flatten.\n\n        Instead, only **one** level of nesting is removed.\n\n        That is, if you `flatten()` a three-dimensional array, the result will be two-dimensional and not one-dimensional.\n\n        To get a one-dimensional structure, you have to `flatten()` again.\n\n        \"\"\"\n        return Iter(itertools.chain.from_iterable(self._inner))\n\n    def flat_map[R](self, func: Callable[[T], Iterable[R]]) -&gt; Iter[R]:\n        \"\"\"Creates an iterator that applies a function to each element of the original iterator and flattens the result.\n\n        This is useful when the **func** you want to pass to `.map()` itself returns an iterable, and you want to avoid having nested iterables in the output.\n\n        This is equivalent to calling `.map(func).flatten()`.\n\n        Args:\n            func (Callable[[T], Iterable[R]]): Function to apply to each element.\n\n        Returns:\n            Iter[R]: An iterable of flattened transformed elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).flat_map(lambda x: range(x)).collect()\n        Seq(0, 0, 1, 0, 1, 2)\n\n        ```\n        \"\"\"\n        return Iter(itertools.chain.from_iterable(map(func, self._inner)))\n\n    def unique_to_each[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Iter[U]]:\n        \"\"\"Return the elements from each of the iterators that aren't in the other iterators.\n\n        It is assumed that the elements of each iterable are hashable.\n\n        **Credits**\n\n            more_itertools.unique_to_each\n\n        Returns:\n            Iter[Iter[U]]: An iterator of iterators, each containing the unique elements from the corresponding input iterable.\n\n        For example, suppose you have a set of packages, each with a set of dependencies:\n\n        **{'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}**\n\n        If you remove one package, which dependencies can also be removed?\n\n        If pkg_1 is removed, then A is no longer necessary - it is not associated with pkg_2 or pkg_3.\n\n        Similarly, C is only needed for pkg_2, and D is only needed for pkg_3:\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = ({\"A\", \"B\"}, {\"B\", \"C\"}, {\"B\", \"D\"})\n        &gt;&gt;&gt; pc.Iter(data).unique_to_each().map(lambda x: x.into(list)).collect()\n        Seq(['A'], ['C'], ['D'])\n\n        ```\n\n        If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output.\n\n        Input order is preserved:\n        ```python\n        &gt;&gt;&gt; data = (\"mississippi\", \"missouri\")\n        &gt;&gt;&gt; pc.Seq(data).iter().unique_to_each().map(lambda x: x.into(list)).collect()\n        Seq(['p', 'p'], ['o', 'u', 'r'])\n\n        ```\n        \"\"\"\n        from collections import Counter\n\n        pool: tuple[Iterable[U], ...] = tuple(self._inner)\n        counts: Counter[U] = Counter(itertools.chain.from_iterable(map(set, pool)))\n        uniques: set[U] = {element for element in counts if counts[element] == 1}\n\n        return Iter((Iter(filter(uniques.__contains__, it))) for it in pool)\n\n    def split_into(self, *sizes: Option[int]) -&gt; Iter[Self]:\n        \"\"\"Yield a list of sequential items from iterable of length 'n' for each integer 'n' in sizes.\n\n        Args:\n            *sizes (Option[int]): `Some` integers specifying the sizes of each chunk. Use `NONE` for the remainder.\n\n        Returns:\n            Iter[Self]: An iterator of iterators, each containing a chunk of the original iterable.\n\n        If the sum of sizes is smaller than the length of iterable, then the remaining items of iterable will not be returned.\n\n        If the sum of sizes is larger than the length of iterable:\n\n        - fewer items will be returned in the iteration that overruns the iterable\n        - further lists will be empty\n\n        When a `NONE` object is encountered in sizes, the returned list will contain items up to the end of iterable the same way that itertools.slice does.\n\n        split_into can be useful for grouping a series of items where the sizes of the groups are not uniform.\n\n        An example would be where in a row from a table:\n\n        - multiple columns represent elements of the same feature (e.g. a point represented by x,y,z)\n        - the format is not the same for all columns.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _get_results(x: pc.Iter[pc.Iter[int]]) -&gt; pc.Seq[pc.Seq[int]]:\n        ...    return x.map(lambda x: x.collect()).collect()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6]\n        &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(1), pc.Some(2), pc.Some(3)).into(_get_results)\n        Seq(Seq(1,), Seq(2, 3), Seq(4, 5, 6))\n        &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3)).into(_get_results)\n        Seq(Seq(1, 2), Seq(3, 4, 5))\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).split_into(pc.Some(1), pc.Some(2), pc.Some(3), pc.Some(4)).into(_get_results)\n        Seq(Seq(1,), Seq(2, 3), Seq(4,), Seq())\n        &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n        &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3), pc.NONE).into(_get_results)\n        Seq(Seq(1, 2), Seq(3, 4, 5), Seq(6, 7, 8, 9, 0))\n\n        ```\n        \"\"\"\n\n        def _split_into(data: Iterator[T]) -&gt; Iterator[Self]:\n            \"\"\"Credits: more_itertools.split_into.\"\"\"\n            new = self.__class__\n            for size in sizes:\n                if size.is_none():\n                    yield new(data)\n                    return\n                else:\n                    yield new(itertools.islice(data, size.unwrap()))\n\n        return Iter(_split_into(self._inner))\n\n    def split_when(\n        self,\n        predicate: Callable[[T, T], bool],\n        max_split: int = -1,\n    ) -&gt; Iter[Self]:\n        \"\"\"Split iterable into pieces based on the output of a predicate function.\n\n        By default, no limit is placed on the number of splits.\n\n        Args:\n            predicate (Callable[[T, T], bool]): Function that takes successive pairs of items and returns True if the iterable should be split.\n            max_split (int): Maximum number of splits to perform.\n\n        Returns:\n            Iter[Self]: An iterator of iterators of items.\n\n        At most *max_split* splits are done.\n\n        If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n        The example below shows how to find runs of increasing numbers, by splitting the iterable when element i is larger than element i + 1.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Seq([1, 2, 3, 3, 2, 5, 2, 4, 2])\n        &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y).map(lambda x: x.collect()).collect()\n        Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4), Seq(2,))\n        &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y, max_split=2).map(lambda x: x.collect()).collect()\n        Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4, 2))\n\n        ```\n        \"\"\"\n\n        def _split_when(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n            \"\"\"Credits: more_itertools.split_when.\"\"\"\n            new = self.__class__\n            if max_split == 0:\n                yield self\n                return\n            try:\n                cur_item = next(data)\n            except StopIteration:\n                return\n\n            buf = [cur_item]\n            for next_item in data:\n                if predicate(cur_item, next_item):\n                    yield new(buf)\n                    if max_split == 1:\n                        yield new((next_item, *data))\n                        return\n                    buf = []\n                    max_split -= 1\n\n                buf.append(next_item)\n                cur_item = next_item\n\n            yield new(buf)\n\n        return Iter(_split_when(self._inner, max_split))\n\n    def split_at(\n        self,\n        predicate: Callable[[T], bool],\n        max_split: int = -1,\n        *,\n        keep_separator: bool = False,\n    ) -&gt; Iter[Self]:\n        \"\"\"Yield iterators of items from iterable, where each iterator is delimited by an item where `predicate` returns True.\n\n        By default, no limit is placed on the number of splits.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine the split points.\n            max_split (int): Maximum number of splits to perform.\n            keep_separator (bool): Whether to include the separator in the output.\n\n        Returns:\n            Iter[Self]: An iterator of iterators, each containing a segment of the original iterable.\n\n        By default, the delimiting items are not included in the output.\n\n        To include them, set *keep_separator* to `True`.\n        At most *max_split* splits are done.\n\n        If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _to_res(x: pc.Iter[pc.Iter[str]]) -&gt; pc.Seq[pc.Seq[str]]:\n        ...     return x.map(lambda x: x.into(list)).collect()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(lambda x: x == \"b\").into(_to_res)\n        Seq(['a'], ['c', 'd', 'c'], ['a'])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1).into(_to_res)\n        Seq([0], [2], [4], [6], [8], [])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1, max_split=2).into(_to_res)\n        Seq([0], [2], [4, 5, 6, 7, 8, 9])\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def cond(x: str) -&gt; bool:\n        ...     return x == \"b\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(cond, keep_separator=True).into(_to_res)\n        Seq(['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a'])\n\n        ```\n        \"\"\"\n\n        def _split_at(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n            \"\"\"Credits: more_itertools.split_at.\"\"\"\n            new = self.__class__\n            if max_split == 0:\n                yield self\n                return\n\n            buf: list[T] = []\n            for item in data:\n                if predicate(item):\n                    yield new(buf)\n                    if keep_separator:\n                        yield new((item,))\n                    if max_split == 1:\n                        yield new(data)\n                        return\n                    buf = []\n                    max_split -= 1\n                else:\n                    buf.append(item)\n            yield new(buf)\n\n        return Iter(_split_at(self._inner, max_split))\n\n    def split_after(\n        self,\n        predicate: Callable[[T], bool],\n        max_split: int = -1,\n    ) -&gt; Iter[Self]:\n        \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n        By default, no limit is placed on the number of splits.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine the split points.\n            max_split (int): Maximum number of splits to perform.\n\n        Returns:\n            Iter[Self]: An iterable of lists of items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"one1two2\").split_after(str.isdigit).map(list).collect()\n        Seq(['o', 'n', 'e', '1'], ['t', 'w', 'o', '2'])\n\n        &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n        ...     return n % 3 == 0\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond).map(list).collect()\n        Seq([0], [1, 2, 3], [4, 5, 6], [7, 8, 9])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond, max_split=2).map(list).collect()\n        Seq([0], [1, 2, 3], [4, 5, 6, 7, 8, 9])\n\n        ```\n        \"\"\"\n\n        def _split_after(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n            \"\"\"Credits: more_itertools.split_after.\"\"\"\n            new = self.__class__\n            if max_split == 0:\n                yield new(data)\n                return\n\n            buf: list[T] = []\n            for item in data:\n                buf.append(item)\n                if predicate(item) and buf:\n                    yield new(buf)\n                    if max_split == 1:\n                        buf = list(data)\n                        if buf:\n                            yield new(buf)\n                        return\n                    buf = []\n                    max_split -= 1\n            if buf:\n                yield new(buf)\n\n        return Iter(_split_after(self._inner, max_split))\n\n    def split_before(\n        self,\n        predicate: Callable[[T], bool],\n        max_split: int = -1,\n    ) -&gt; Iter[Self]:\n        \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n        By default, no limit is placed on the number of splits.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine the split points.\n            max_split (int): Maximum number of splits to perform.\n\n        Returns:\n            Iter[Self]: An iterable of lists of items.\n\n\n        At most *max_split* are done.\n\n\n        If *max_split* is not specified or -1, then there is no limit on the number of splits:\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_before(lambda x: x == \"b\").map(list).collect()\n        Seq(['a'], ['b', 'c', 'd', 'c'], ['b', 'a'])\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n        ...     return n % 2 == 1\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond).map(list).collect()\n        Seq([0], [1, 2], [3, 4], [5, 6], [7, 8], [9])\n        &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond, max_split=2).map(list).collect()\n        Seq([0], [1, 2], [3, 4, 5, 6, 7, 8, 9])\n\n        ```\n        \"\"\"\n\n        def _split_before(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n            \"\"\"Credits: more_itertools.split_before.\"\"\"\n            new = self.__class__\n\n            if max_split == 0:\n                yield new(data)\n                return\n\n            buf: list[T] = []\n            for item in data:\n                if predicate(item) and buf:\n                    yield new(buf)\n                    if max_split == 1:\n                        yield new([item, *data])\n                        return\n                    buf = []\n                    max_split -= 1\n                buf.append(item)\n            if buf:\n                yield new(buf)\n\n        return Iter(_split_before(self._inner, max_split))\n\n    def find_map[R](self, func: Callable[[T], Option[R]]) -&gt; Option[R]:\n        \"\"\"Applies function to the elements of the `Iterator` and returns the first Some(R) result.\n\n        `Iter.find_map(f)` is equivalent to `Iter.filter_map(f).next()`.\n\n        Args:\n            func (Callable[[T], Option[R]]): Function to apply to each element, returning an `Option[R]`.\n\n        Returns:\n            Option[R]: The first `Some(R)` result from applying `func`, or `NONE` if no such result is found.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Option[int]:\n        ...     try:\n        ...         return pc.Some(int(s))\n        ...     except ValueError:\n        ...         return pc.NONE\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([\"lol\", \"NaN\", \"2\", \"5\"]).find_map(_parse)\n        Some(2)\n\n        ```\n        \"\"\"\n        return self.filter_map(func).next()\n\n    # map -----------------------------------------------------------------\n\n    def map[R](self, func: Callable[[T], R]) -&gt; Iter[R]:\n        \"\"\"Apply a function **func** to each element of the `Iter`.\n\n        If you are good at thinking in types, you can think of `Iter.map()` like this:\n\n        - You have an `Iterator` that gives you elements of some type `A`\n        - You want an `Iterator` of some other type `B`\n        - Thenyou can use `.map()`, passing a closure **func** that takes an `A` and returns a `B`.\n\n        `Iter.map()` is conceptually similar to a for loop.\n\n        However, as `Iter.map()` is lazy, it is best used when you are already working with other `Iter` instances.\n\n        If you are doing some sort of looping for a side effect, it is considered more idiomatic to use `Iter.for_each()` than `Iter.map().collect()`.\n\n        Args:\n            func (Callable[[T], R]): Function to apply to each element.\n\n        Returns:\n            Iter[R]: An iterator of transformed elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).map(lambda x: x + 1).collect()\n        Seq(2, 3)\n        &gt;&gt;&gt; # You can use methods on the class rather than on instance for convenience:\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).map(str.upper).collect()\n        Seq('A', 'B', 'C')\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).map(lambda s: s.upper()).collect()\n        Seq('A', 'B', 'C')\n\n        ```\n        \"\"\"\n        return Iter(map(func, self._inner))\n\n    @overload\n    def map_star[R](\n        self: Iter[tuple[Any]],\n        func: Callable[[Any], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, R](\n        self: Iter[tuple[T1, T2]],\n        func: Callable[[T1, T2], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, R](\n        self: Iter[tuple[T1, T2, T3]],\n        func: Callable[[T1, T2, T3], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, R](\n        self: Iter[tuple[T1, T2, T3, T4]],\n        func: Callable[[T1, T2, T3, T4], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5]],\n        func: Callable[[T1, T2, T3, T4, T5], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6]],\n        func: Callable[[T1, T2, T3, T4, T5, T6], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, T8, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R],\n    ) -&gt; Iter[R]: ...\n    def map_star[U: Iterable[Any], R](\n        self: Iter[U],\n        func: Callable[..., R],\n    ) -&gt; Iter[R]:\n        \"\"\"Applies a function to each element.where each element is an iterable.\n\n        Unlike `.map()`, which passes each element as a single argument, `.starmap()` unpacks each element into positional arguments for the function.\n\n        In short, for each element in the `Iter`, it computes `func(*element)`.\n\n        Note:\n            Always prefer using `.map_star()` over `.map()` when working with `Iter` of `tuple` elements.\n            Not only it is more readable, but it's also much more performant (up to 30% faster in benchmarks).\n\n        Args:\n            func (Callable[..., R]): Function to apply to unpacked elements.\n\n        Returns:\n            Iter[R]: An iterable of results from applying the function to unpacked elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def make_sku(color: str, size: str) -&gt; str:\n        ...     return f\"{color}-{size}\"\n        &gt;&gt;&gt; data = pc.Seq([\"blue\", \"red\"])\n        &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map_star(make_sku).collect()\n        Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n        &gt;&gt;&gt; # This is equivalent to:\n        &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map(lambda x: make_sku(*x)).collect()\n        Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n\n        ```\n        \"\"\"\n        return Iter(itertools.starmap(func, self._inner))\n\n    def map_while[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n        \"\"\"Creates an iterator that both yields elements based on a predicate and maps.\n\n        `map_while()` takes a closure as an argument. It will call this closure on each element of\n        the iterator, and yield elements while it returns `Some(_)`.\n\n        After `NONE` is returned, `map_while()` stops and the rest of the elements are ignored.\n\n        Args:\n            func (Callable[[T], Option[R]]): Function to apply to each element that returns `Option[R]`.\n\n        Returns:\n            Iter[R]: An iterator of transformed elements until `NONE` is encountered.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def checked_div(x: int) -&gt; pc.Option[int]:\n        ...     return pc.Some(16 // x) if x != 0 else pc.NONE\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = pc.Iter([-1, 4, 0, 1])\n        &gt;&gt;&gt; data.map_while(checked_div).collect()\n        Seq(-16, 4)\n        &gt;&gt;&gt; data = pc.Iter([0, 1, 2, -3, 4, 5, -6])\n        &gt;&gt;&gt; # Convert to positive ints, stop at first negative\n        &gt;&gt;&gt; data.map_while(lambda x: pc.Some(x) if x &gt;= 0 else pc.NONE).collect()\n        Seq(0, 1, 2)\n\n        ```\n        \"\"\"\n\n        def _gen() -&gt; Generator[R]:\n            for opt in map(func, self._inner):\n                if opt.is_none():\n                    return\n                yield opt.unwrap()\n\n        return Iter(_gen())\n\n    def repeat(self, n: int | None = None) -&gt; Iter[Self]:\n        \"\"\"Repeat the entire `Iter` **n** times (as elements).\n\n        If **n** is `None`, repeat indefinitely.\n\n        Operates lazily, hence if you need to get the underlying elements, you will need to collect each repeated `Iter` via `.map(lambda x: x.collect())` or similar.\n\n        Warning:\n            If **n** is `None`, this will create an infinite `Iterator`.\n\n            Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n        See Also:\n            `Iter.cycle()` to repeat the *elements* of the `Iter` indefinitely.\n\n        Args:\n            n (int | None): Optional number of repetitions.\n\n        Returns:\n            Iter[Self]: An `Iter` of repeated `Iter`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).repeat(3).map(list).collect()\n        Seq([1, 2], [1, 2], [1, 2])\n\n        ```\n        \"\"\"\n        new = self.__class__\n\n        def _repeat_infinite() -&gt; Generator[Self]:\n            tee = functools.partial(itertools.tee, self._inner, 1)\n            iterators = tee()\n            while True:\n                yield new(iterators[0])\n                iterators = tee()\n\n        if n is None:\n            return Iter(_repeat_infinite())\n        return Iter(map(new, itertools.tee(self._inner, n)))\n\n    def scan[U](self, initial: U, func: Callable[[U, T], Option[U]]) -&gt; Iter[U]:\n        \"\"\"Transform elements by sharing state between iterations.\n\n        `scan` takes two arguments:\n            - an **initial** value which seeds the internal state\n            - a **func** with two arguments\n\n        The first being a reference to the internal state and the second an iterator element.\n\n        The **func** can assign to the internal state to share state between iterations.\n\n        On iteration, the **func** will be applied to each element of the iterator and the return value from the func, an Option, is returned by the next method.\n\n        Thus the **func** can return `Some(value)` to yield value, or `NONE` to end the iteration.\n\n        Args:\n            initial (U): Initial state.\n            func (Callable[[U, T], Option[U]]): Function that takes the current state and an item, and returns an Option.\n\n        Returns:\n            Iter[U]: An iterable of the yielded values.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def accumulate_until_limit(state: int, item: int) -&gt; pc.Option[int]:\n        ...     new_state = state + item\n        ...     match new_state:\n        ...         case _ if new_state &lt;= 10:\n        ...             return pc.Some(new_state)\n        ...         case _:\n        ...             return pc.NONE\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).scan(0, accumulate_until_limit).collect()\n        Seq(1, 3, 6, 10)\n\n        ```\n        \"\"\"\n\n        def _gen(data: Iterable[T]) -&gt; Iterator[U]:\n            current: U = initial\n            for item in data:\n                res = func(current, item)\n                if res.is_none():\n                    break\n                current = res.unwrap()\n                yield res.unwrap()\n\n        return Iter(_gen(self._inner))\n\n    # filters ------------------------------------------------------------\n    @overload\n    def filter[U](self, func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]: ...\n    @overload\n    def filter(self, func: Callable[[T], bool]) -&gt; Iter[T]: ...\n    def filter[U](self, func: Callable[[T], bool | TypeIs[U]]) -&gt; Iter[T] | Iter[U]:\n        \"\"\"Creates an `Iter` which uses a closure to determine if an element should be yielded.\n\n        Given an element the closure must return true or false.\n\n        The returned `Iter` will yield only the elements for which the closure returns true.\n\n        The closure can return a `TypeIs` to narrow the type of the returned iterable.\n\n        This won't have any runtime effect, but allows for better type inference.\n\n        Note:\n            `Iter.filter(f).next()` is equivalent to `Iter.find(f)`.\n\n        Args:\n            func (Callable[[T], bool | TypeIs[U]]): Function to evaluate each item.\n\n        Returns:\n            Iter[T] | Iter[U]: An iterable of the items that satisfy the predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = (1, 2, 3)\n        &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).collect()\n        Seq(2, 3)\n        &gt;&gt;&gt; # See the equivalence of next and find:\n        &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).next()\n        Some(2)\n        &gt;&gt;&gt; pc.Iter(data).find(lambda x: x &gt; 1)\n        Some(2)\n        &gt;&gt;&gt; # Using TypeIs to narrow type:\n        &gt;&gt;&gt; from typing import TypeIs\n        &gt;&gt;&gt; def _is_str(x: object) -&gt; TypeIs[str]:\n        ...     return isinstance(x, str)\n        &gt;&gt;&gt; mixed_data = [1, \"two\", 3.0, \"four\"]\n        &gt;&gt;&gt; pc.Iter(mixed_data).filter(_is_str).collect()\n        Seq('two', 'four')\n\n        ```\n        \"\"\"\n        return Iter(filter(func, self._inner))\n\n    @overload\n    def filter_star(\n        self: Iter[tuple[Any]],\n        func: Callable[[Any], bool],\n    ) -&gt; Iter[tuple[Any]]: ...\n    @overload\n    def filter_star[T1, T2](\n        self: Iter[tuple[T1, T2]],\n        func: Callable[[T1, T2], bool],\n    ) -&gt; Iter[tuple[T1, T2]]: ...\n    @overload\n    def filter_star[T1, T2, T3](\n        self: Iter[tuple[T1, T2, T3]],\n        func: Callable[[T1, T2, T3], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4](\n        self: Iter[tuple[T1, T2, T3, T4]],\n        func: Callable[[T1, T2, T3, T4], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5](\n        self: Iter[tuple[T1, T2, T3, T4, T5]],\n        func: Callable[[T1, T2, T3, T4, T5], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6]],\n        func: Callable[[T1, T2, T3, T4, T5, T6], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7, T8](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7, T8, T9](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]]: ...\n    @overload\n    def filter_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], bool],\n    ) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]]: ...\n\n    def filter_star[U: Iterable[Any]](\n        self: Iter[U],\n        func: Callable[..., bool],\n    ) -&gt; Iter[U]:\n        \"\"\"Creates an `Iter` which uses a closure **func** to determine if an element should be yielded, where each element is an iterable.\n\n        Unlike `.filter()`, which passes each element as a single argument, `.filter_star()` unpacks each element into positional arguments for the **func**.\n\n        In short, for each element in the `Iter`, it computes `func(*element)`.\n\n        This is useful after using methods like `.zip()`, `.product()`, or `.enumerate()` that yield tuples.\n\n        Args:\n            func (Callable[..., bool]): Function to evaluate unpacked elements.\n\n        Returns:\n            Iter[U]: An `Iter` of the items that satisfy the predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Seq([\"apple\", \"banana\", \"cherry\", \"date\"])\n        &gt;&gt;&gt; data.iter().enumerate().filter_star(lambda index, fruit: index % 2 == 0).map_star(lambda index, fruit: fruit.title()).collect()\n        Seq('Apple', 'Cherry')\n\n        ```\n        \"\"\"\n        return Iter(filter(lambda x: func(*x), self._inner))\n\n    @overload\n    def filter_false[U](self, func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]: ...\n    @overload\n    def filter_false(self, func: Callable[[T], bool]) -&gt; Iter[T]: ...\n    def filter_false[U](\n        self, func: Callable[[T], bool | TypeIs[U]]\n    ) -&gt; Iter[T] | Iter[U]:\n        \"\"\"Return elements for which **func** is `False`.\n\n        The **func** can return a `TypeIs` to narrow the type of the returned `Iter`.\n\n        This won't have any runtime effect, but allows for better type inference.\n\n        Args:\n            func (Callable[[T], bool | TypeIs[U]]): Function to evaluate each item.\n\n        Returns:\n            Iter[T] | Iter[U]: An `Iter` of the items that do not satisfy the predicate.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).filter_false(lambda x: x &gt; 1).collect()\n        Seq(1,)\n\n        ```\n        \"\"\"\n        return Iter(itertools.filterfalse(func, self._inner))\n\n    def filter_map[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n        \"\"\"Creates an iterator that both filters and maps.\n\n        The returned iterator yields only the values for which the supplied closure returns Some(value).\n\n        `filter_map` can be used to make chains of `filter` and map more concise.\n\n        The example below shows how a `map().filter().map()` can be shortened to a single call to `filter_map`.\n\n        Args:\n            func (Callable[[T], Option[R]]): Function to apply to each item.\n\n        Returns:\n            Iter[R]: An iterable of the results where func returned `Some`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Result[int, str]:\n        ...     try:\n        ...         return pc.Ok(int(s))\n        ...     except ValueError:\n        ...         return pc.Err(f\"Invalid integer, got {s!r}\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = pc.Seq([\"1\", \"two\", \"NaN\", \"four\", \"5\"])\n        &gt;&gt;&gt; data.iter().filter_map(lambda s: _parse(s).ok()).collect()\n        Seq(1, 5)\n        &gt;&gt;&gt; # Equivalent to:\n        &gt;&gt;&gt; (\n        ...     data.iter()\n        ...    .map(lambda s: _parse(s).ok())\n        ...    .filter(lambda s: s.is_some())\n        ...    .map(lambda s: s.unwrap())\n        ...    .collect()\n        ... )\n        Seq(1, 5)\n\n        ```\n        \"\"\"\n\n        def _filter_map(data: Iterable[T]) -&gt; Iterator[R]:\n            for item in data:\n                res = func(item)\n                if res.is_some():\n                    yield res.unwrap()\n\n        return Iter(_filter_map(self._inner))\n\n    @overload\n    def filter_map_star[R](\n        self: Iter[tuple[Any]],\n        func: Callable[[Any], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, R](\n        self: Iter[tuple[T1, T2]],\n        func: Callable[[T1, T2], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, R](\n        self: Iter[tuple[T1, T2, T3]],\n        func: Callable[[T1, T2, T3], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, T4, R](\n        self: Iter[tuple[T1, T2, T3, T4]],\n        func: Callable[[T1, T2, T3, T4], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, T4, T5, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5]],\n        func: Callable[[T1, T2, T3, T4, T5], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, T4, T5, T6, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6]],\n        func: Callable[[T1, T2, T3, T4, T5, T6], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, T4, T5, T6, T7, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, T4, T5, T6, T7, T8, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], Option[R]],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def filter_map_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](\n        self: Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], Option[R]],\n    ) -&gt; Iter[R]: ...\n    def filter_map_star[U: Iterable[Any], R](\n        self: Iter[U],\n        func: Callable[..., Option[R]],\n    ) -&gt; Iter[R]:\n        \"\"\"Creates an iterator that both filters and maps, where each element is an iterable.\n\n        Unlike `.filter_map()`, which passes each element as a single argument, `.filter_map_star()` unpacks each element into positional arguments for the function.\n\n        In short, for each `element` in the sequence, it computes `func(*element)`.\n\n        This is useful after using methods like `zip`, `product`, or `enumerate` that yield tuples.\n\n        Args:\n            func (Callable[..., Option[R]]): Function to apply to unpacked elements.\n\n        Returns:\n            Iter[R]: An iterable of the results where func returned `Some`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Seq([(\"1\", \"10\"), (\"two\", \"20\"), (\"3\", \"thirty\")])\n        &gt;&gt;&gt; def _parse_pair(s1: str, s2: str) -&gt; pc.Result[tuple[int, int], str]:\n        ...     try:\n        ...         return pc.Ok((int(s1), int(s2)))\n        ...     except ValueError:\n        ...         return pc.Err(f\"Invalid integer pair: {s1!r}, {s2!r}\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data.iter().filter_map_star(lambda s1, s2: _parse_pair(s1, s2).ok()).collect()\n        Seq((1, 10),)\n\n        ```\n        \"\"\"\n\n        def _filter_map_star(data: Iterable[U]) -&gt; Iterator[R]:\n            for item in data:\n                res = func(*item)\n                if res.is_some():\n                    yield res.unwrap()\n\n        return Iter(_filter_map_star(self._inner))\n\n    # joins and zips ------------------------------------------------------------\n    @overload\n    def zip[T1](\n        self,\n        iter1: Iterable[T1],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1]]: ...\n    @overload\n    def zip[T1, T2](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1, T2]]: ...\n    @overload\n    def zip[T1, T2, T3](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1, T2, T3]]: ...\n    @overload\n    def zip[T1, T2, T3, T4](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        /,\n        *,\n        strict: bool = ...,\n    ) -&gt; Iter[tuple[T, T1, T2, T3, T4]]: ...\n    def zip(\n        self,\n        *others: Iterable[Any],\n        strict: bool = False,\n    ) -&gt; Iter[tuple[Any, ...]]:\n        \"\"\"Yields n-length tuples, where n is the number of iterables passed as positional arguments.\n\n        The i-th element in every tuple comes from the i-th iterable argument to `.zip()`.\n\n        This continues until the shortest argument is exhausted.\n\n        Note:\n            `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n            This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to zip with.\n            strict (bool): If `True` and one of the arguments is exhausted before the others, raise a ValueError.\n\n        Returns:\n            Iter[tuple[Any, ...]]: An `Iter` of tuples containing elements from the zipped Iter and other iterables.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).zip([10, 20]).collect()\n        Seq((1, 10), (2, 20))\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).zip([1, 2, 3]).collect()\n        Seq(('a', 1), ('b', 2))\n\n        ```\n        \"\"\"\n        return Iter(zip(self._inner, *others, strict=strict))\n\n    @overload\n    def zip_longest[T2](\n        self, iter2: Iterable[T2], /\n    ) -&gt; Iter[tuple[Option[T], Option[T2]]]: ...\n    @overload\n    def zip_longest[T2, T3](\n        self, iter2: Iterable[T2], iter3: Iterable[T3], /\n    ) -&gt; Iter[tuple[Option[T], Option[T2], Option[T3]]]: ...\n    @overload\n    def zip_longest[T2, T3, T4](\n        self,\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        /,\n    ) -&gt; Iter[tuple[Option[T], Option[T2], Option[T3], Option[T4]]]: ...\n    @overload\n    def zip_longest[T2, T3, T4, T5](\n        self,\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        iter5: Iterable[T5],\n        /,\n    ) -&gt; Iter[\n        tuple[\n            Option[T],\n            Option[T2],\n            Option[T3],\n            Option[T4],\n            Option[T5],\n        ]\n    ]: ...\n    @overload\n    def zip_longest(\n        self,\n        iter2: Iterable[T],\n        iter3: Iterable[T],\n        iter4: Iterable[T],\n        iter5: Iterable[T],\n        iter6: Iterable[T],\n        /,\n        *iterables: Iterable[T],\n    ) -&gt; Iter[tuple[Option[T], ...]]: ...\n    def zip_longest(self, *others: Iterable[Any]) -&gt; Iter[tuple[Option[Any], ...]]:\n        \"\"\"Return a zip Iterator who yield a tuple where the i-th element comes from the i-th iterable argument.\n\n        Yield values until the longest iterable in the argument sequence is exhausted, and then it raises StopIteration.\n\n        The longest iterable determines the length of the returned iterator, and will return `Some[T]` until exhaustion.\n\n        When the shorter iterables are exhausted, they yield `NONE`.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to zip with.\n\n        Returns:\n            Iter[tuple[Option[Any], ...]]: An iterable of tuples containing optional elements from the zipped iterables.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).collect()\n        Seq((Some(1), Some(10)), (Some(2), NONE))\n        &gt;&gt;&gt; # Can be combined with try collect to filter out the NONE:\n        &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).map(lambda x: pc.Iter(x).try_collect()).collect()\n        Seq(Some(Vec(1, 10)), NONE)\n\n        ```\n        \"\"\"\n        return Iter(\n            tuple(Option(t) for t in tup)\n            for tup in itertools.zip_longest(self._inner, *others, fillvalue=None)\n        )\n\n    def unzip[U, V](self: Iter[tuple[U, V]]) -&gt; Unzipped[U, V]:\n        \"\"\"Converts an iterator of pairs into a pair of iterators.\n\n        Returns:\n            Unzipped[U, V]: dataclass with first and second iterators.\n\n\n        Returns an `Unzipped` dataclass, containing two iterators:\n\n        - one from the left elements of the pairs\n        - one from the right elements.\n\n        This function is, in some sense, the opposite of `.zip()`.\n\n        Note:\n            Both iterators share the same underlying source.\n\n            Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.\n\n            This is the unavoidable cost of having two independent iterators over the same source.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n        &gt;&gt;&gt; unzipped = pc.Iter(data).unzip()\n        &gt;&gt;&gt; unzipped.left.collect()\n        Seq(1, 2, 3)\n        &gt;&gt;&gt; unzipped.right.collect()\n        Seq('a', 'b', 'c')\n\n        ```\n        \"\"\"\n        left, right = itertools.tee(self._inner, 2)\n        return Unzipped(Iter(x[0] for x in left), Iter(x[1] for x in right))\n\n    def cloned(self) -&gt; Self:\n        \"\"\"Clone the `Iter` into a new independent `Iter` using `itertools.tee`.\n\n        After calling this method, the original `Iter` will continue to yield elements independently of the cloned one.\n\n        Note:\n            Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.\n\n            This is the unavoidable cost of having two independent iterators over the same source.\n\n            However, once both iterators have passed a value, it's freed from memory.\n\n        Returns:\n            Self: A new independent cloned iterator.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; it = pc.Iter([1, 2, 3])\n        &gt;&gt;&gt; cloned = it.cloned()\n        &gt;&gt;&gt; cloned.collect()\n        Seq(1, 2, 3)\n        &gt;&gt;&gt; it.collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        it1, it2 = itertools.tee(self._inner)\n        self._inner = it1\n        return self.__class__(it2)\n\n    @overload\n    def product(self) -&gt; Iter[tuple[T]]: ...\n    @overload\n    def product[T1](self, iter1: Iterable[T1], /) -&gt; Iter[tuple[T, T1]]: ...\n    @overload\n    def product[T1, T2](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        /,\n    ) -&gt; Iter[tuple[T, T1, T2]]: ...\n    @overload\n    def product[T1, T2, T3](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        /,\n    ) -&gt; Iter[tuple[T, T1, T2, T3]]: ...\n    @overload\n    def product[T1, T2, T3, T4](\n        self,\n        iter1: Iterable[T1],\n        iter2: Iterable[T2],\n        iter3: Iterable[T3],\n        iter4: Iterable[T4],\n        /,\n    ) -&gt; Iter[tuple[T, T1, T2, T3, T4]]: ...\n\n    def product(self, *others: Iterable[Any]) -&gt; Iter[tuple[Any, ...]]:\n        \"\"\"Computes the Cartesian product with another iterable.\n\n        This is the declarative equivalent of nested for-loops.\n\n        It pairs every element from the source iterable with every element from the\n        other iterable.\n\n        Args:\n            *others (Iterable[Any]): Other iterables to compute the Cartesian product with.\n\n        Returns:\n            Iter[tuple[Any, ...]]: An iterable of tuples containing elements from the Cartesian product.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).product([\"S\", \"M\"]).collect()\n        Seq(('blue', 'S'), ('blue', 'M'), ('red', 'S'), ('red', 'M'))\n        &gt;&gt;&gt; res = (\n        ...     pc.Iter([\"blue\", \"red\"])\n        ...     .product([\"S\", \"M\"])\n        ...     .map_star(lambda color, size: f\"{color}-{size}\")\n        ...     .collect()\n        ... )\n        &gt;&gt;&gt; res\n        Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n        &gt;&gt;&gt; res = (\n        ...     pc.Iter([1, 2, 3])\n        ...     .product([10, 20])\n        ...     .filter_star(lambda a, b: a * b &gt;= 40)\n        ...     .map_star(lambda a, b: a * b)\n        ...     .collect()\n        ... )\n        &gt;&gt;&gt; res\n        Seq(40, 60)\n        &gt;&gt;&gt; res = (\n        ...     pc.Iter([1])\n        ...     .product([\"a\", \"b\"], [True])\n        ...     .filter_star(lambda _a, b, _c: b != \"a\")\n        ...     .map_star(lambda a, b, c: f\"{a}{b} is {c}\")\n        ...     .collect()\n        ... )\n        &gt;&gt;&gt; res\n        Seq('1b is True',)\n\n        ```\n        \"\"\"\n        return Iter(itertools.product(self._inner, *others))\n\n    def diff_at[R](\n        self, other: Iterable[T], key: Callable[[T], R] | None = None\n    ) -&gt; Iter[tuple[Option[T], Option[T]]]:\n        \"\"\"Yields pairs of differing elements from two iterables.\n\n        Compares elements from the source iterable and another iterable at corresponding positions.\n\n        If elements differ (based on equality or a provided key function), yields a tuple containing the differing elements wrapped in `Option`.\n\n        If one iterable is shorter, yields `NONE` for missing elements.\n\n        Args:\n            other (Iterable[T]): Other `Iterable` to compare with.\n            key (Callable[[T], R] | None): Function to apply to each item for comparison.\n\n        Returns:\n            Iter[tuple[Option[T], Option[T]]]: An `Iter` of item pairs containing differing elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Seq([1, 2, 3])\n        &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100]).collect()\n        Seq((Some(3), Some(10)), (NONE, Some(100)))\n        &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100, 2, 6, 7]).collect() # doctest: +NORMALIZE_WHITESPACE\n        Seq((Some(3), Some(10)),\n        (NONE, Some(100)),\n        (NONE, Some(2)),\n        (NONE, Some(6)),\n        (NONE, Some(7)))\n        &gt;&gt;&gt; pc.Iter([\"apples\", \"bananas\"]).diff_at([\"Apples\", \"Oranges\"], key=str.lower).collect(list)\n        [(Some('bananas'), Some('Oranges'))]\n\n        ```\n        \"\"\"\n        if key is None:\n\n            def _gen_no_key() -&gt; Iterator[tuple[Option[T], Option[T]]]:\n                for first, second in itertools.zip_longest(\n                    map(Some, self), map(Some, other), fillvalue=NONE\n                ):\n                    if first.ne(second):\n                        yield first, second\n\n            return Iter(_gen_no_key())\n\n        def _gen_with_key() -&gt; Iterator[tuple[Option[T], Option[T]]]:\n            for first, second in itertools.zip_longest(\n                map(Some, self), map(Some, other), fillvalue=NONE\n            ):\n                if first.map(key).ne(second.map(key)):\n                    yield first, second\n\n        return Iter(_gen_with_key())\n\n    @overload\n    def map_windows[R](\n        self, length: Literal[1], func: Callable[[tuple[T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[2], func: Callable[[tuple[T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[3], func: Callable[[tuple[T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[4], func: Callable[[tuple[T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[5], func: Callable[[tuple[T, T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[6], func: Callable[[tuple[T, T, T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[7], func: Callable[[tuple[T, T, T, T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[8], func: Callable[[tuple[T, T, T, T, T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: Literal[9], func: Callable[[tuple[T, T, T, T, T, T, T, T, T]], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self,\n        length: Literal[10],\n        func: Callable[[tuple[T, T, T, T, T, T, T, T, T, T]], R],\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows[R](\n        self, length: int, func: Callable[[tuple[T, ...]], R]\n    ) -&gt; Iter[R]: ...\n    def map_windows[R](\n        self, length: int, func: Callable[[tuple[Any, ...]], R]\n    ) -&gt; Iter[R]:\n        r\"\"\"Calls the given *func* for each contiguous window of size *length* over **self**.\n\n        The windows during mapping overlaps.\n\n        The provided function is called with the entire window as a single tuple argument.\n\n        Args:\n            length (int): The length of each window.\n            func (Callable[[tuple[Any, ...]], R]): Function to apply to each window.\n\n        Returns:\n            Iter[R]: An iterator over the outputs of func.\n\n        See Also:\n            `.map_windows_star()` for a version that unpacks the window into separate arguments.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; import statistics\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, statistics.mean).collect()\n        Seq(1.5, 2.5, 3.5)\n        &gt;&gt;&gt; pc.Iter(\"abcd\").map_windows(3, lambda window: \"\".join(window).upper()).collect()\n        Seq('ABC', 'BCD')\n        &gt;&gt;&gt; pc.Iter([10, 20, 30, 40, 50]).map_windows(4, sum).collect()\n        Seq(100, 140)\n        &gt;&gt;&gt; from pathlib import Path\n        &gt;&gt;&gt; pc.Iter([\"home\", \"src\", \"pyochain\"]).map_windows(2, lambda p: str(Path(*p))).collect()\n        Seq('home\\\\src', 'src\\\\pyochain')\n\n\n        ```\n        \"\"\"\n        return Iter(map(func, cz.itertoolz.sliding_window(length, self._inner)))\n\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[1], func: Callable[[T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[2], func: Callable[[T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[3], func: Callable[[T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[4], func: Callable[[T, T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[5], func: Callable[[T, T, T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[6], func: Callable[[T, T, T, T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[7], func: Callable[[T, T, T, T, T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[8], func: Callable[[T, T, T, T, T, T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[9], func: Callable[[T, T, T, T, T, T, T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    @overload\n    def map_windows_star[R](\n        self, length: Literal[10], func: Callable[[T, T, T, T, T, T, T, T, T, T], R]\n    ) -&gt; Iter[R]: ...\n    def map_windows_star[R](self, length: int, func: Callable[..., R]) -&gt; Iter[R]:\n        \"\"\"Calls the given *func* for each contiguous window of size *length* over **self**.\n\n        The windows during mapping overlaps.\n\n        The provided function is called with each element of the window as separate arguments.\n\n        Args:\n            length (int): The length of each window.\n            func (Callable[..., R]): Function to apply to each window.\n\n        Returns:\n            Iter[R]: An iterator over the outputs of func.\n\n        See Also:\n            `.map_windows()` for a version that passes the entire window as a single tuple argument.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"abcd\").map_windows_star(2, lambda x, y: f\"{x}+{y}\").collect()\n        Seq('a+b', 'b+c', 'c+d')\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows_star(2, lambda x, y: x + y).collect()\n        Seq(3, 5, 7)\n\n        ```\n        \"\"\"\n        return Iter(\n            itertools.starmap(func, cz.itertoolz.sliding_window(length, self._inner))\n        )\n\n    @overload\n    def partition(self, n: Literal[1], pad: None = None) -&gt; Iter[tuple[T]]: ...\n    @overload\n    def partition(self, n: Literal[2], pad: None = None) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def partition(self, n: Literal[3], pad: None = None) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def partition(self, n: Literal[4], pad: None = None) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def partition(\n        self,\n        n: Literal[5],\n        pad: None = None,\n    ) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    @overload\n    def partition(self, n: int, pad: T) -&gt; Iter[tuple[T, ...]]: ...\n    def partition(self, n: int, pad: T | None = None) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Partition **self** into `tuples` of length **n**.\n\n        Args:\n            n (int): Length of each partition.\n            pad (T | None): Value to pad the last partition if needed.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition(2).collect()\n        Seq((1, 2), (3, 4))\n\n        ```\n        If the length of seq is not evenly divisible by n, the final tuple is dropped if pad is not specified, or filled to length n by pad:\n        ```python\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition(2).collect()\n        Seq((1, 2), (3, 4), (5, None))\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.partition(n, self._inner, pad=pad))\n\n    def partition_all(self, n: int) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Partition all elements of sequence into tuples of length at most n.\n\n        The final tuple may be shorter to accommodate extra elements.\n\n        Args:\n            n (int): Maximum length of each partition.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition_all(2).collect()\n        Seq((1, 2), (3, 4))\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition_all(2).collect()\n        Seq((1, 2), (3, 4), (5,))\n\n        ```\n        \"\"\"\n        return Iter(cz.itertoolz.partition_all(n, self._inner))\n\n    def partition_by(self, predicate: Callable[[T], bool]) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Partition the `Iterator` into a sequence of `tuples` according to a predicate function.\n\n        Every time the output of `predicate` changes, a new `tuple` is started,\n        and subsequent items are collected into that `tuple`.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to determine partition boundaries.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"I have space\").partition_by(lambda c: c == \" \").collect()\n        Seq(('I',), (' ',), ('h', 'a', 'v', 'e'), (' ',), ('s', 'p', 'a', 'c', 'e'))\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; data = [1, 2, 1, 99, 88, 33, 99, -1, 5]\n        &gt;&gt;&gt; pc.Iter(data).partition_by(lambda x: x &gt; 10).collect()\n        Seq((1, 2, 1), (99, 88, 33, 99), (-1, 5))\n\n        ```\n        \"\"\"\n        return Iter(cz.recipes.partitionby(predicate, self._inner))\n\n    def batch(self, n: int, *, strict: bool = False) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Batch elements into tuples of length n and return a new Iter.\n\n        - The last batch may be shorter than n.\n        - The data is consumed lazily, just enough to fill a batch.\n        - The result is yielded as soon as a batch is full or when the input iterable is exhausted.\n\n        Args:\n            n (int): Number of elements in each batch.\n            strict (bool): If `True`, raises a ValueError if the last batch is not of length n.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of batched tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"ABCDEFG\").batch(3).collect()\n        Seq(('A', 'B', 'C'), ('D', 'E', 'F'), ('G',))\n\n        ```\n        \"\"\"\n        return Iter(itertools.batched(self._inner, n, strict=strict))\n\n    def peekable(self, n: int) -&gt; Peekable[T]:\n        \"\"\"Retrieve the next **n** elements from the `Iterator`, and return a `Seq` of the retrieved elements along with the original `Iterator`, unconsumed.\n\n        The returned `Peekable` object contains two attributes:\n        - *peek*: A `Seq` of the next **n** elements.\n        - *values*: An `Iter` that includes the peeked elements followed by the remaining elements of the original `Iterator`.\n\n        `Peekable` implement `Checkable` on the *peek* attribute.\n\n        Args:\n            n (int): Number of items to peek.\n\n        Returns:\n            Peekable[T]: A `Peekable` object containing the peeked elements and the remaining iterator.\n\n        See Also:\n            `Iter.cloned()` to create an independent copy of the iterator.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Iter([1, 2, 3]).peekable(2)\n        &gt;&gt;&gt; data.peek\n        Seq(1, 2)\n        &gt;&gt;&gt; data.values.collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        peeked = Seq(itertools.islice(self._inner, n))\n        return Peekable(peeked, Iter(itertools.chain(peeked, self._inner)))\n\n    def is_strictly_n(self, n: int) -&gt; Iter[Result[T, ValueError]]:\n        \"\"\"Yield`Ok[T]` as long as the iterable has exactly *n* items.\n\n        If it has fewer than *n* items, yield `Err[ValueError]` with the actual number of items.\n\n        If it has more than *n* items, yield `Err[ValueError]` with the number `n + 1`.\n\n        Note that the returned iterable must be consumed in order for the check to\n        be made.\n\n        Args:\n            n (int): The exact number of items expected.\n\n        Returns:\n            Iter[Result[T, ValueError]]: A new Iterable wrapper yielding results based on the item count.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = [\"a\", \"b\", \"c\", \"d\"]\n        &gt;&gt;&gt; n = 4\n        &gt;&gt;&gt; pc.Iter(data).is_strictly_n(n).collect()\n        Seq(Ok('a'), Ok('b'), Ok('c'), Ok('d'))\n        &gt;&gt;&gt; pc.Iter(\"ab\").is_strictly_n(3).collect()  # doctest: +NORMALIZE_WHITESPACE\n        Seq(Ok('a'), Ok('b'),\n        Err(ValueError('Too few items in iterable (got 2)')))\n        &gt;&gt;&gt; pc.Iter(\"abc\").is_strictly_n(2).collect()  # doctest: +NORMALIZE_WHITESPACE\n        Seq(Ok('a'), Ok('b'),\n        Err(ValueError('Too many items in iterable (got at least 3)')))\n\n        ```\n        You can easily combine this with `.map(lambda r: r.map_err(...))` to handle the errors as you wish.\n        ```python\n        &gt;&gt;&gt; def _my_err(e: ValueError) -&gt; str:\n        ...     return f\"custom error: {e}\"\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([1]).is_strictly_n(0).map(lambda r: r.map_err(_my_err)).collect()\n        Seq(Err('custom error: Too many items in iterable (got at least 1)'),)\n\n        ```\n        Or use `.filter_map(...)` to only keep the `Ok` values.\n        ```python\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).is_strictly_n(2).filter_map(lambda r: r.ok()).collect()\n        Seq(1, 2)\n\n        ```\n        \"\"\"\n\n        def _strictly_n_(data: Iterator[T]) -&gt; Iterator[Result[T, ValueError]]:\n            sent = 0\n            for item in itertools.islice(data, n):\n                yield Ok(item)\n                sent += 1\n\n            if sent &lt; n:\n                e = ValueError(f\"Too few items in iterable (got {sent})\")\n                yield Err(e)\n\n            for _ in data:\n                e = ValueError(f\"Too many items in iterable (got at least {n + 1})\")\n                yield Err(e)\n\n        return Iter(_strictly_n_(self._inner))\n\n    def enumerate(self, start: int = 0) -&gt; Iter[tuple[int, T]]:\n        \"\"\"Return a `Iter` of (index, value) pairs.\n\n        Each value in the `Iter` is paired with its index, starting from 0.\n\n        Tip:\n            `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n            This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n        Args:\n            start (int): The starting index.\n\n        Returns:\n            Iter[tuple[int, T]]: An `Iter` of (index, value) pairs.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().collect()\n        Seq((0, 'a'), (1, 'b'))\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().map_star(lambda idx, val: (idx, val.upper())).collect()\n        Seq((0, 'A'), (1, 'B'))\n\n        ```\n        \"\"\"\n        return Iter(enumerate(self._inner, start))\n\n    @overload\n    def combinations(self, r: Literal[2]) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def combinations(self, r: Literal[3]) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def combinations(self, r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def combinations(self, r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    def combinations(self, r: int) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Return all combinations of length r.\n\n        Args:\n            r (int): Length of each combination.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of combinations.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations(2).collect()\n        Seq((1, 2), (1, 3), (2, 3))\n\n        ```\n        \"\"\"\n        return Iter(itertools.combinations(self._inner, r))\n\n    @overload\n    def permutations(self, r: Literal[2]) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def permutations(self, r: Literal[3]) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def permutations(self, r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def permutations(self, r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    def permutations(self, r: int | None = None) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Return all permutations of length r.\n\n        Args:\n            r (int | None): Length of each permutation. Defaults to the length of the iterable.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of permutations.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).permutations(2).collect()\n        Seq((1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2))\n\n        ```\n        \"\"\"\n        return Iter(itertools.permutations(self._inner, r))\n\n    @overload\n    def combinations_with_replacement(self, r: Literal[2]) -&gt; Iter[tuple[T, T]]: ...\n    @overload\n    def combinations_with_replacement(self, r: Literal[3]) -&gt; Iter[tuple[T, T, T]]: ...\n    @overload\n    def combinations_with_replacement(\n        self,\n        r: Literal[4],\n    ) -&gt; Iter[tuple[T, T, T, T]]: ...\n    @overload\n    def combinations_with_replacement(\n        self,\n        r: Literal[5],\n    ) -&gt; Iter[tuple[T, T, T, T, T]]: ...\n    def combinations_with_replacement(self, r: int) -&gt; Iter[tuple[T, ...]]:\n        \"\"\"Return all combinations with replacement of length r.\n\n        Args:\n            r (int): Length of each combination.\n\n        Returns:\n            Iter[tuple[T, ...]]: An iterable of combinations with replacement.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations_with_replacement(2).collect()\n        Seq((1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3))\n\n        ```\n        \"\"\"\n        return Iter(itertools.combinations_with_replacement(self._inner, r))\n\n    def pairwise(self) -&gt; Iter[tuple[T, T]]:\n        \"\"\"Return an iterator over pairs of consecutive elements.\n\n        Returns:\n            Iter[tuple[T, T]]: An iterable of pairs of consecutive elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).pairwise().collect()\n        Seq((1, 2), (2, 3))\n\n        ```\n        \"\"\"\n        return Iter(itertools.pairwise(self._inner))\n\n    @overload\n    def map_juxt[R1, R2](\n        self,\n        func1: Callable[[T], R1],\n        func2: Callable[[T], R2],\n        /,\n    ) -&gt; Iter[tuple[R1, R2]]: ...\n    @overload\n    def map_juxt[R1, R2, R3](\n        self,\n        func1: Callable[[T], R1],\n        func2: Callable[[T], R2],\n        func3: Callable[[T], R3],\n        /,\n    ) -&gt; Iter[tuple[R1, R2, R3]]: ...\n    @overload\n    def map_juxt[R1, R2, R3, R4](\n        self,\n        func1: Callable[[T], R1],\n        func2: Callable[[T], R2],\n        func3: Callable[[T], R3],\n        func4: Callable[[T], R4],\n        /,\n    ) -&gt; Iter[tuple[R1, R2, R3, R4]]: ...\n    def map_juxt(self, *funcs: Callable[[T], object]) -&gt; Iter[tuple[object, ...]]:\n        \"\"\"Apply several functions to each item.\n\n        Returns a new Iter where each item is a tuple of the results of applying each function to the original item.\n\n        Args:\n            *funcs (Callable[[T], object]): Functions to apply to each item.\n\n        Returns:\n            Iter[tuple[object, ...]]: An iterable of tuples containing the results of each function.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n        ...     return n % 2 == 0\n        &gt;&gt;&gt; def is_positive(n: int) -&gt; bool:\n        ...     return n &gt; 0\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([1, -2, 3]).map_juxt(is_even, is_positive).collect()\n        Seq((False, True), (True, False), (False, True))\n\n        ```\n        \"\"\"\n        return Iter(map(cz.functoolz.juxt(*funcs), self._inner))\n\n    def with_position(self) -&gt; Iter[tuple[Position, T]]:\n        \"\"\"Return an iterable over (`Position`, `T`) tuples.\n\n        The `Position` indicates whether the item `T` is the first, middle, last, or only element in the iterable.\n\n        Returns:\n            Iter[tuple[Position, T]]: An iterable of (`Position`, item) tuples.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).with_position().collect()\n        Seq(('first', 'a'), ('middle', 'b'), ('last', 'c'))\n        &gt;&gt;&gt; pc.Iter([\"a\"]).with_position().collect()\n        Seq(('only', 'a'),)\n\n        ```\n        \"\"\"\n\n        def _gen(data: Iterator[T]) -&gt; Iterator[tuple[Position, T]]:\n            try:\n                first = next(data)\n            except StopIteration:\n                return\n\n            try:\n                second = next(data)\n            except StopIteration:\n                yield (\"only\", first)\n                return\n            yield (\"first\", first)\n\n            current: T = second\n            for nxt in self._inner:\n                yield (\"middle\", current)\n                current = nxt\n            yield (\"last\", current)\n\n        return Iter(_gen(self._inner))\n\n    @overload\n    def group_by(self, key: None = None) -&gt; Iter[tuple[T, Self]]: ...\n    @overload\n    def group_by[K](self, key: Callable[[T], K]) -&gt; Iter[tuple[K, Self]]: ...\n    @overload\n    def group_by[K](\n        self, key: Callable[[T], K] | None = None\n    ) -&gt; Iter[tuple[K, Self] | tuple[T, Self]]: ...\n    def group_by(\n        self, key: Callable[[T], Any] | None = None\n    ) -&gt; Iter[tuple[Any | T, Self]]:\n        \"\"\"Make an `Iter` that returns consecutive keys and groups from the iterable.\n\n        Args:\n            key (Callable[[T], Any] | None): Function computing a key value for each element..\n        If not specified or is None, **key** defaults to an identity function and returns the element unchanged.\n\n        Returns:\n            Iter[tuple[Any | T, Self]]: An `Iter` of `(key, value)` tuples.\n\n        The values yielded are `(K, Self)` tuples, where the first element is the group key and the second element is an `Iter` of type `T` over the group values.\n\n        The `Iter` needs to already be sorted on the same key function.\n\n        This is due to the fact that it generates a new `Group` every time the value of the **key** function changes.\n\n        That behavior differs from SQL's `GROUP BY` which aggregates common elements regardless of their input order.\n\n        Warning:\n            You must materialize the second element of the tuple immediately when iterating over groups.\n\n            Because `.group_by()` uses Python's `itertools.groupby` under the hood, each group's iterator shares internal state.\n\n            When you advance to the next group, the previous group's iterator becomes invalid and will yield empty results.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Example 1: Group even and odd numbers\n        &gt;&gt;&gt; (\n        ... pc.Iter.from_count() # create an infinite iterator of integers\n        ... .take(8) # take the first 8\n        ... .map(lambda x: (x % 2 == 0, x)) # map to (is_even, value)\n        ... .sort(key=lambda x: x[0]) # sort by is_even\n        ... .iter() # Since sort collect to a Vec, we need to convert back to Iter\n        ... .group_by(lambda x: x[0]) # group by is_even\n        ... .map_star(lambda g, vals: (g, vals.map_star(lambda _, y: y).into(list))) # extract values from groups, discarding keys, and materializing them to lists\n        ... .collect() # collect the result\n        ... .into(dict) # convert to dict\n        ... )\n        {False: [1, 3, 5, 7], True: [0, 2, 4, 6]}\n        &gt;&gt;&gt; # Example 2: Group by a common key, already sorted\n        &gt;&gt;&gt; data = [\n        ...     {\"name\": \"Alice\", \"gender\": \"F\"},\n        ...     {\"name\": \"Bob\", \"gender\": \"M\"},\n        ...     {\"name\": \"Charlie\", \"gender\": \"M\"},\n        ...     {\"name\": \"Dan\", \"gender\": \"M\"},\n        ... ]\n        &gt;&gt;&gt; (\n        ... pc.Iter(data)\n        ... .group_by(lambda x: x[\"gender\"]) # group by the gender key\n        ... .map_star(lambda g, vals: (g, vals.length())) # get the length of each group\n        ... .collect()\n        ... )\n        Seq(('F', 1), ('M', 3))\n        &gt;&gt;&gt; # Example 3: Incorrect usage with LATE materialization:\n        &gt;&gt;&gt; groups = pc.Iter([\"a1\", \"a2\", \"b1\"]).group_by(lambda x: x[0]).collect()\n        &gt;&gt;&gt; # Now iterate - TOO LATE! The group iterators are consumed\n        &gt;&gt;&gt; for g in groups:\n        ...     print(g[1].collect())  # ‚ùå Empty!\n        Seq()\n        Seq()\n        &gt;&gt;&gt; # Example 4: Correct usage with intermediate materialization:\n        &gt;&gt;&gt; groups = (\n        ...     pc.Iter([\"a1\", \"a2\", \"b1\"])\n        ...     .group_by(lambda x: x[0])\n        ...     .map_star(lambda g, vals: (g, vals.collect()))  # ‚úÖ Materialize NOW\n        ...     .collect()\n        ...     .iter()\n        ...     .for_each(lambda x: print(f\"{x[0]}: {x[1]}\"))\n        ... )\n        a: Seq('a1', 'a2')\n        b: Seq('b1',)\n\n        ```\n        \"\"\"\n        new = self.__class__\n        return Iter((x, new(y)) for x, y in itertools.groupby(self._inner, key))\n\n    @overload\n    def sort[U: SupportsRichComparison[Any]](\n        self: Iter[U],\n        *,\n        key: None = None,\n        reverse: bool = False,\n    ) -&gt; Vec[U]: ...\n    @overload\n    def sort(\n        self,\n        *,\n        key: Callable[[T], SupportsRichComparison[Any]],\n        reverse: bool = False,\n    ) -&gt; Vec[T]: ...\n    @overload\n    def sort(\n        self,\n        *,\n        key: None = None,\n        reverse: bool = False,\n    ) -&gt; Never: ...\n    def sort(\n        self,\n        *,\n        key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n        reverse: bool = False,\n    ) -&gt; Vec[Any]:\n        \"\"\"Sort the elements of the sequence.\n\n        If a key function is provided, it is used to extract a comparison key from each element.\n\n        Note:\n            This method must consume the entire `Iter` to perform the sort.\n            The result is a new `Vec` over the sorted sequence.\n\n        Args:\n            key (Callable[[T], SupportsRichComparison[Any]] | None): Function to extract a comparison key from each element.\n            reverse (bool): Whether to sort in descending order.\n\n        Returns:\n            Vec[Any]: A `Vec` with elements sorted.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([3, 1, 2]).sort()\n        Vec(1, 2, 3)\n\n        ```\n        \"\"\"\n        return Vec.from_ref(sorted(self._inner, reverse=reverse, key=key))\n\n    def tail(self, n: int) -&gt; Seq[T]:\n        \"\"\"Return a `Seq` of the last **n** elements of the `Iterator`.\n\n        Args:\n            n (int): Number of elements to return.\n\n        Returns:\n            Seq[T]: A `Seq` containing the last **n** elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).tail(2)\n        Seq(2, 3)\n\n        ```\n        \"\"\"\n        return Seq(cz.itertoolz.tail(n, self._inner))\n\n    def top_n(self, n: int, key: Callable[[T], Any] | None = None) -&gt; Seq[T]:\n        \"\"\"Return a tuple of the top-n items according to key.\n\n        Args:\n            n (int): Number of top elements to return.\n            key (Callable[[T], Any] | None): Function to extract a comparison key from each element.\n\n        Returns:\n            Seq[T]: A new Seq containing the top-n elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 3, 2]).top_n(2)\n        Seq(3, 2)\n\n        ```\n        \"\"\"\n        return Seq(cz.itertoolz.topk(n, self._inner, key=key))\n\n    def most_common(self, n: int | None = None) -&gt; Vec[tuple[T, int]]:\n        \"\"\"Return the **n** most common elements and their counts from the `Iterator`.\n\n        If **n** is `None`, then all elements are returned.\n\n        Args:\n            n (int | None): Number of most common elements to return. Defaults to None (all elements).\n\n        Returns:\n            Vec[tuple[T, int]]: A `Vec` containing tuples of (element, count).\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 1, 2, 3, 3, 3]).most_common(2)\n        Vec((3, 3), (1, 2))\n\n        ```\n        \"\"\"\n        from collections import Counter\n\n        return Vec.from_ref(Counter(self._inner).most_common(n))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.__bool__","level":2,"title":"<code>__bool__()</code>","text":"<p>Check if the <code>Iterator</code> has at least one element (mutates self).</p> <p>After calling this, the <code>Iterator</code> still contains all elements.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the <code>Iterator</code> has at least one element, False otherwise.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; it = pc.Iter([1, 2, 3])\n&gt;&gt;&gt; bool(it)\nTrue\n&gt;&gt;&gt; it.collect()  # All elements still available\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Check if the `Iterator` has at least one element (mutates **self**).\n\n    After calling this, the `Iterator` still contains all elements.\n\n    Returns:\n        bool: True if the `Iterator` has at least one element, False otherwise.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; it = pc.Iter([1, 2, 3])\n    &gt;&gt;&gt; bool(it)\n    True\n    &gt;&gt;&gt; it.collect()  # All elements still available\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    first = tuple(itertools.islice(self._inner, 1))\n    self._inner = itertools.chain(first, self._inner)\n    return len(first) &gt; 0\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.array_chunks","level":2,"title":"<code>array_chunks(size)</code>","text":"<p>Yield subiterators (chunks) that each yield a fixed number elements, determined by size.</p> <p>The last chunk will be shorter if there are not enough elements.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>Number of elements in each chunk.</p> required <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An iterable of iterators, each yielding n elements.</p> <p>If the sub-iterables are read in order, the elements of iterable won't be stored in memory.</p> <p>If they are read out of order, :func:<code>itertools.tee</code> is used to cache elements as necessary. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; all_chunks = pc.Iter.from_count().array_chunks(4)\n&gt;&gt;&gt; c_1, c_2, c_3 = all_chunks.next(), all_chunks.next(), all_chunks.next()\n&gt;&gt;&gt; c_2.unwrap().collect()  # c_1's elements have been cached; c_3's haven't been\nSeq(4, 5, 6, 7)\n&gt;&gt;&gt; c_1.unwrap().collect()\nSeq(0, 1, 2, 3)\n&gt;&gt;&gt; c_3.unwrap().collect()\nSeq(8, 9, 10, 11)\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\nSeq(Seq(1, 2, 3), Seq(4, 5, 6))\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6, 7, 8]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\nSeq(Seq(1, 2, 3), Seq(4, 5, 6), Seq(7, 8))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def array_chunks(self, size: int) -&gt; Iter[Self]:\n    \"\"\"Yield subiterators (chunks) that each yield a fixed number elements, determined by size.\n\n    The last chunk will be shorter if there are not enough elements.\n\n    Args:\n        size (int): Number of elements in each chunk.\n\n    Returns:\n        Iter[Self]: An iterable of iterators, each yielding n elements.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; all_chunks = pc.Iter.from_count().array_chunks(4)\n    &gt;&gt;&gt; c_1, c_2, c_3 = all_chunks.next(), all_chunks.next(), all_chunks.next()\n    &gt;&gt;&gt; c_2.unwrap().collect()  # c_1's elements have been cached; c_3's haven't been\n    Seq(4, 5, 6, 7)\n    &gt;&gt;&gt; c_1.unwrap().collect()\n    Seq(0, 1, 2, 3)\n    &gt;&gt;&gt; c_3.unwrap().collect()\n    Seq(8, 9, 10, 11)\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n    Seq(Seq(1, 2, 3), Seq(4, 5, 6))\n    &gt;&gt;&gt; pc.Seq([1, 2, 3, 4, 5, 6, 7, 8]).iter().array_chunks(3).map(lambda c: c.collect()).collect()\n    Seq(Seq(1, 2, 3), Seq(4, 5, 6), Seq(7, 8))\n\n    ```\n    \"\"\"\n    from collections import deque\n    from contextlib import suppress\n\n    def _chunks() -&gt; Iterator[Self]:\n        def _ichunk(\n            iterator: Iterator[T], n: int\n        ) -&gt; tuple[Iterator[T], Callable[[int], int]]:\n            cache: deque[T] = deque()\n            chunk = itertools.islice(iterator, n)\n\n            def _generator() -&gt; Iterator[T]:\n                with suppress(StopIteration):\n                    while True:\n                        if cache:\n                            yield cache.popleft()\n                        else:\n                            yield next(chunk)\n\n            def _materialize_next(n: int) -&gt; int:\n                to_cache = n - len(cache)\n\n                # materialize up to n\n                if to_cache &gt; 0:\n                    cache.extend(itertools.islice(chunk, to_cache))\n\n                # return number materialized up to n\n                return min(n, len(cache))\n\n            return (_generator(), _materialize_next)\n\n        new = self.__class__\n        while True:\n            # Create new chunk\n            chunk, _materialize_next = _ichunk(self._inner, size)\n\n            # Check to see whether we're at the end of the source iterable\n            if not _materialize_next(size):\n                return\n\n            yield new(chunk)\n            _materialize_next(size)\n\n    return Iter(_chunks())\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.batch","level":2,"title":"<code>batch(n, *, strict=False)</code>","text":"<p>Batch elements into tuples of length n and return a new Iter.</p> <ul> <li>The last batch may be shorter than n.</li> <li>The data is consumed lazily, just enough to fill a batch.</li> <li>The result is yielded as soon as a batch is full or when the input iterable is exhausted.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements in each batch.</p> required <code>strict</code> <code>bool</code> <p>If <code>True</code>, raises a ValueError if the last batch is not of length n.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of batched tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"ABCDEFG\").batch(3).collect()\nSeq(('A', 'B', 'C'), ('D', 'E', 'F'), ('G',))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def batch(self, n: int, *, strict: bool = False) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Batch elements into tuples of length n and return a new Iter.\n\n    - The last batch may be shorter than n.\n    - The data is consumed lazily, just enough to fill a batch.\n    - The result is yielded as soon as a batch is full or when the input iterable is exhausted.\n\n    Args:\n        n (int): Number of elements in each batch.\n        strict (bool): If `True`, raises a ValueError if the last batch is not of length n.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of batched tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"ABCDEFG\").batch(3).collect()\n    Seq(('A', 'B', 'C'), ('D', 'E', 'F'), ('G',))\n\n    ```\n    \"\"\"\n    return Iter(itertools.batched(self._inner, n, strict=strict))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.cloned","level":2,"title":"<code>cloned()</code>","text":"<p>Clone the <code>Iter</code> into a new independent <code>Iter</code> using <code>itertools.tee</code>.</p> <p>After calling this method, the original <code>Iter</code> will continue to yield elements independently of the cloned one.</p> Note <p>Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.</p> <p>This is the unavoidable cost of having two independent iterators over the same source.</p> <p>However, once both iterators have passed a value, it's freed from memory.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new independent cloned iterator.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; it = pc.Iter([1, 2, 3])\n&gt;&gt;&gt; cloned = it.cloned()\n&gt;&gt;&gt; cloned.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; it.collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def cloned(self) -&gt; Self:\n    \"\"\"Clone the `Iter` into a new independent `Iter` using `itertools.tee`.\n\n    After calling this method, the original `Iter` will continue to yield elements independently of the cloned one.\n\n    Note:\n        Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.\n\n        This is the unavoidable cost of having two independent iterators over the same source.\n\n        However, once both iterators have passed a value, it's freed from memory.\n\n    Returns:\n        Self: A new independent cloned iterator.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; it = pc.Iter([1, 2, 3])\n    &gt;&gt;&gt; cloned = it.cloned()\n    &gt;&gt;&gt; cloned.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; it.collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    it1, it2 = itertools.tee(self._inner)\n    self._inner = it1\n    return self.__class__(it2)\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.collect","level":2,"title":"<code>collect(collector=Seq[T])</code>","text":"<p>Transforms an <code>Iter</code> into a collection.</p> <p>The most basic pattern in which collect() is used is to turn one collection into another.</p> <p>You take a collection, call <code>iter()</code> on it, do a bunch of transformations, and then <code>collect()</code> at the end.</p> <p>You can specify the target collection type by providing a collector function or type.</p> <p>This can be any <code>Callable</code> that takes an <code>Iterator[T]</code> and returns a <code>Collection[T]</code> of those types.</p> Note <p>This can be tought as <code>.into()</code> with a default value (<code>Seq[T]</code>), and a different constraint (<code>Collection[Any]</code>). However, the runtime behavior is identical in both cases: pass self to the provided function, return the result.</p> <p>Parameters:</p> Name Type Description Default <code>collector</code> <code>Callable[[Iterator[T]], R]</code> <p>Function|type that defines the target collection. <code>R</code> is constrained to a <code>Collection</code>.</p> <code>Seq[T]</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>A materialized collection containing the collected elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(range(5)).collect()\nSeq(0, 1, 2, 3, 4)\n&gt;&gt;&gt; iterator = pc.Iter((1, 2, 3))\n&gt;&gt;&gt; iterator._inner.__class__.__name__\n'tuple_iterator'\n&gt;&gt;&gt; mapped = iterator.map(lambda x: x * 2)\n&gt;&gt;&gt; mapped._inner.__class__.__name__\n'map'\n&gt;&gt;&gt; mapped.collect()\nSeq(2, 4, 6)\n&gt;&gt;&gt; # iterator is now exhausted\n&gt;&gt;&gt; iterator.collect()\nSeq()\n&gt;&gt;&gt; pc.Iter(range(5)).collect(list)\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; pc.Iter(range(5)).collect(pc.Vec)\nVec(0, 1, 2, 3, 4)\n&gt;&gt;&gt; iterator = pc.Iter([1, 2, 3])\n&gt;&gt;&gt; iterator._inner.__class__.__name__\n'list_iterator'\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def collect[R: Collection[Any]](\n    self, collector: Callable[[Iterator[T]], R] = Seq[T]\n) -&gt; R:\n    \"\"\"Transforms an `Iter` into a collection.\n\n    The most basic pattern in which collect() is used is to turn one collection into another.\n\n    You take a collection, call `iter()` on it, do a bunch of transformations, and then `collect()` at the end.\n\n    You can specify the target collection type by providing a **collector** function or type.\n\n    This can be any `Callable` that takes an `Iterator[T]` and returns a `Collection[T]` of those types.\n\n    Note:\n        This can be tought as `.into()` with a default value (`Seq[T]`), and a different constraint (`Collection[Any]`).\n        However, the runtime behavior is identical in both cases: pass **self** to the provided function, return the result.\n\n    Args:\n        collector (Callable[[Iterator[T]], R]): Function|type that defines the target collection. `R` is constrained to a `Collection`.\n\n    Returns:\n        R: A materialized collection containing the collected elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(range(5)).collect()\n    Seq(0, 1, 2, 3, 4)\n    &gt;&gt;&gt; iterator = pc.Iter((1, 2, 3))\n    &gt;&gt;&gt; iterator._inner.__class__.__name__\n    'tuple_iterator'\n    &gt;&gt;&gt; mapped = iterator.map(lambda x: x * 2)\n    &gt;&gt;&gt; mapped._inner.__class__.__name__\n    'map'\n    &gt;&gt;&gt; mapped.collect()\n    Seq(2, 4, 6)\n    &gt;&gt;&gt; # iterator is now exhausted\n    &gt;&gt;&gt; iterator.collect()\n    Seq()\n    &gt;&gt;&gt; pc.Iter(range(5)).collect(list)\n    [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; pc.Iter(range(5)).collect(pc.Vec)\n    Vec(0, 1, 2, 3, 4)\n    &gt;&gt;&gt; iterator = pc.Iter([1, 2, 3])\n    &gt;&gt;&gt; iterator._inner.__class__.__name__\n    'list_iterator'\n\n    ```\n    \"\"\"\n    return collector(self._inner)\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.collect_into","level":2,"title":"<code>collect_into(collection)</code>","text":"<pre><code>collect_into(collection: Vec[T]) -&gt; Vec[T]\n</code></pre><pre><code>collect_into(collection: list[T]) -&gt; list[T]\n</code></pre> <p>Collects all the items from the <code>Iterator</code> into a <code>MutableSequence</code>.</p> <p>This method consumes the <code>Iterator</code> and adds all its items to the passed <code>MutableSequence</code>.</p> <p>The <code>MutableSequence</code> is then returned, so the call chain can be continued.</p> <p>This is useful when you already have a <code>MutableSequence</code> and want to add the <code>Iterator</code> items to it.</p> <p>This method is a convenience method to call <code>MutableSequence.extend()</code>, but instead of being called on a <code>MutableSequence</code>, it's called on an <code>Iterator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>collection</code> <code>MutableSequence[T]</code> <p>A mutable collection to collect items into.</p> required <p>Returns:</p> Type Description <code>MutableSequence[T]</code> <p>MutableSequence[T]: The same mutable collection passed as argument, now containing the collected items.</p> <p>Example: Basic usage: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; a = pc.Seq([1, 2, 3])\n&gt;&gt;&gt; vec = pc.Vec([0, 1])\n&gt;&gt;&gt; a.iter().map(lambda x: x * 2).collect_into(vec)\nVec(0, 1, 2, 4, 6)\n&gt;&gt;&gt; a.iter().map(lambda x: x * 10).collect_into(vec)\nVec(0, 1, 2, 4, 6, 10, 20, 30)\n</code></pre> The returned mutable sequence can be used to continue the call chain: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; a = pc.Seq([1, 2, 3])\n&gt;&gt;&gt; vec = pc.Vec[int].new()\n&gt;&gt;&gt; a.iter().collect_into(vec).length() == vec.length()\nTrue\n&gt;&gt;&gt; a.iter().collect_into(vec).length() == vec.length()\nTrue\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def collect_into(self, collection: MutableSequence[T]) -&gt; MutableSequence[T]:\n    \"\"\"Collects all the items from the `Iterator` into a `MutableSequence`.\n\n    This method consumes the `Iterator` and adds all its items to the passed `MutableSequence`.\n\n    The `MutableSequence` is then returned, so the call chain can be continued.\n\n    This is useful when you already have a `MutableSequence` and want to add the `Iterator` items to it.\n\n    This method is a convenience method to call `MutableSequence.extend()`, but instead of being called on a `MutableSequence`, it's called on an `Iterator`.\n\n    Args:\n        collection (MutableSequence[T]): A mutable collection to collect items into.\n\n    Returns:\n        MutableSequence[T]: The same mutable collection passed as argument, now containing the collected items.\n\n    Example:\n    Basic usage:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; a = pc.Seq([1, 2, 3])\n    &gt;&gt;&gt; vec = pc.Vec([0, 1])\n    &gt;&gt;&gt; a.iter().map(lambda x: x * 2).collect_into(vec)\n    Vec(0, 1, 2, 4, 6)\n    &gt;&gt;&gt; a.iter().map(lambda x: x * 10).collect_into(vec)\n    Vec(0, 1, 2, 4, 6, 10, 20, 30)\n\n    ```\n    The returned mutable sequence can be used to continue the call chain:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; a = pc.Seq([1, 2, 3])\n    &gt;&gt;&gt; vec = pc.Vec[int].new()\n    &gt;&gt;&gt; a.iter().collect_into(vec).length() == vec.length()\n    True\n    &gt;&gt;&gt; a.iter().collect_into(vec).length() == vec.length()\n    True\n\n    ```\n    \"\"\"\n    collection.extend(self._inner)\n    return collection\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.combinations","level":2,"title":"<code>combinations(r)</code>","text":"<pre><code>combinations(r: Literal[2]) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>combinations(r: Literal[3]) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>combinations(r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>combinations(r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre> <p>Return all combinations of length r.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Length of each combination.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of combinations.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations(2).collect()\nSeq((1, 2), (1, 3), (2, 3))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combinations(self, r: int) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Return all combinations of length r.\n\n    Args:\n        r (int): Length of each combination.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of combinations.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations(2).collect()\n    Seq((1, 2), (1, 3), (2, 3))\n\n    ```\n    \"\"\"\n    return Iter(itertools.combinations(self._inner, r))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.combinations_with_replacement","level":2,"title":"<code>combinations_with_replacement(r)</code>","text":"<pre><code>combinations_with_replacement(\n    r: Literal[2],\n) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>combinations_with_replacement(\n    r: Literal[3],\n) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>combinations_with_replacement(\n    r: Literal[4],\n) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>combinations_with_replacement(\n    r: Literal[5],\n) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre> <p>Return all combinations with replacement of length r.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int</code> <p>Length of each combination.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of combinations with replacement.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations_with_replacement(2).collect()\nSeq((1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def combinations_with_replacement(self, r: int) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Return all combinations with replacement of length r.\n\n    Args:\n        r (int): Length of each combination.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of combinations with replacement.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).combinations_with_replacement(2).collect()\n    Seq((1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3))\n\n    ```\n    \"\"\"\n    return Iter(itertools.combinations_with_replacement(self._inner, r))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.diff_at","level":2,"title":"<code>diff_at(other, key=None)</code>","text":"<p>Yields pairs of differing elements from two iterables.</p> <p>Compares elements from the source iterable and another iterable at corresponding positions.</p> <p>If elements differ (based on equality or a provided key function), yields a tuple containing the differing elements wrapped in <code>Option</code>.</p> <p>If one iterable is shorter, yields <code>NONE</code> for missing elements.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>Other <code>Iterable</code> to compare with.</p> required <code>key</code> <code>Callable[[T], R] | None</code> <p>Function to apply to each item for comparison.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[Option[T], Option[T]]]</code> <p>Iter[tuple[Option[T], Option[T]]]: An <code>Iter</code> of item pairs containing differing elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Seq([1, 2, 3])\n&gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100]).collect()\nSeq((Some(3), Some(10)), (NONE, Some(100)))\n&gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100, 2, 6, 7]).collect() # doctest: +NORMALIZE_WHITESPACE\nSeq((Some(3), Some(10)),\n(NONE, Some(100)),\n(NONE, Some(2)),\n(NONE, Some(6)),\n(NONE, Some(7)))\n&gt;&gt;&gt; pc.Iter([\"apples\", \"bananas\"]).diff_at([\"Apples\", \"Oranges\"], key=str.lower).collect(list)\n[(Some('bananas'), Some('Oranges'))]\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def diff_at[R](\n    self, other: Iterable[T], key: Callable[[T], R] | None = None\n) -&gt; Iter[tuple[Option[T], Option[T]]]:\n    \"\"\"Yields pairs of differing elements from two iterables.\n\n    Compares elements from the source iterable and another iterable at corresponding positions.\n\n    If elements differ (based on equality or a provided key function), yields a tuple containing the differing elements wrapped in `Option`.\n\n    If one iterable is shorter, yields `NONE` for missing elements.\n\n    Args:\n        other (Iterable[T]): Other `Iterable` to compare with.\n        key (Callable[[T], R] | None): Function to apply to each item for comparison.\n\n    Returns:\n        Iter[tuple[Option[T], Option[T]]]: An `Iter` of item pairs containing differing elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Seq([1, 2, 3])\n    &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100]).collect()\n    Seq((Some(3), Some(10)), (NONE, Some(100)))\n    &gt;&gt;&gt; data.iter().diff_at([1, 2, 10, 100, 2, 6, 7]).collect() # doctest: +NORMALIZE_WHITESPACE\n    Seq((Some(3), Some(10)),\n    (NONE, Some(100)),\n    (NONE, Some(2)),\n    (NONE, Some(6)),\n    (NONE, Some(7)))\n    &gt;&gt;&gt; pc.Iter([\"apples\", \"bananas\"]).diff_at([\"Apples\", \"Oranges\"], key=str.lower).collect(list)\n    [(Some('bananas'), Some('Oranges'))]\n\n    ```\n    \"\"\"\n    if key is None:\n\n        def _gen_no_key() -&gt; Iterator[tuple[Option[T], Option[T]]]:\n            for first, second in itertools.zip_longest(\n                map(Some, self), map(Some, other), fillvalue=NONE\n            ):\n                if first.ne(second):\n                    yield first, second\n\n        return Iter(_gen_no_key())\n\n    def _gen_with_key() -&gt; Iterator[tuple[Option[T], Option[T]]]:\n        for first, second in itertools.zip_longest(\n            map(Some, self), map(Some, other), fillvalue=NONE\n        ):\n            if first.map(key).ne(second.map(key)):\n                yield first, second\n\n    return Iter(_gen_with_key())\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.enumerate","level":2,"title":"<code>enumerate(start=0)</code>","text":"<p>Return a <code>Iter</code> of (index, value) pairs.</p> <p>Each value in the <code>Iter</code> is paired with its index, starting from 0.</p> Tip <p><code>Iter.map_star</code> can then be used for subsequent operations on the index and value, in a destructuring manner. This keep the code clean and readable, without index access like <code>[0]</code> and <code>[1]</code> for inline lambdas.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The starting index.</p> <code>0</code> <p>Returns:</p> Type Description <code>Iter[tuple[int, T]]</code> <p>Iter[tuple[int, T]]: An <code>Iter</code> of (index, value) pairs.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().collect()\nSeq((0, 'a'), (1, 'b'))\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().map_star(lambda idx, val: (idx, val.upper())).collect()\nSeq((0, 'A'), (1, 'B'))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def enumerate(self, start: int = 0) -&gt; Iter[tuple[int, T]]:\n    \"\"\"Return a `Iter` of (index, value) pairs.\n\n    Each value in the `Iter` is paired with its index, starting from 0.\n\n    Tip:\n        `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n        This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n    Args:\n        start (int): The starting index.\n\n    Returns:\n        Iter[tuple[int, T]]: An `Iter` of (index, value) pairs.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().collect()\n    Seq((0, 'a'), (1, 'b'))\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).enumerate().map_star(lambda idx, val: (idx, val.upper())).collect()\n    Seq((0, 'A'), (1, 'B'))\n\n    ```\n    \"\"\"\n    return Iter(enumerate(self._inner, start))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter","level":2,"title":"<code>filter(func)</code>","text":"<pre><code>filter(func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]\n</code></pre><pre><code>filter(func: Callable[[T], bool]) -&gt; Iter[T]\n</code></pre> <p>Creates an <code>Iter</code> which uses a closure to determine if an element should be yielded.</p> <p>Given an element the closure must return true or false.</p> <p>The returned <code>Iter</code> will yield only the elements for which the closure returns true.</p> <p>The closure can return a <code>TypeIs</code> to narrow the type of the returned iterable.</p> <p>This won't have any runtime effect, but allows for better type inference.</p> Note <p><code>Iter.filter(f).next()</code> is equivalent to <code>Iter.find(f)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool | TypeIs[U]]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Iter[T] | Iter[U]</code> <p>Iter[T] | Iter[U]: An iterable of the items that satisfy the predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = (1, 2, 3)\n&gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).collect()\nSeq(2, 3)\n&gt;&gt;&gt; # See the equivalence of next and find:\n&gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).next()\nSome(2)\n&gt;&gt;&gt; pc.Iter(data).find(lambda x: x &gt; 1)\nSome(2)\n&gt;&gt;&gt; # Using TypeIs to narrow type:\n&gt;&gt;&gt; from typing import TypeIs\n&gt;&gt;&gt; def _is_str(x: object) -&gt; TypeIs[str]:\n...     return isinstance(x, str)\n&gt;&gt;&gt; mixed_data = [1, \"two\", 3.0, \"four\"]\n&gt;&gt;&gt; pc.Iter(mixed_data).filter(_is_str).collect()\nSeq('two', 'four')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter[U](self, func: Callable[[T], bool | TypeIs[U]]) -&gt; Iter[T] | Iter[U]:\n    \"\"\"Creates an `Iter` which uses a closure to determine if an element should be yielded.\n\n    Given an element the closure must return true or false.\n\n    The returned `Iter` will yield only the elements for which the closure returns true.\n\n    The closure can return a `TypeIs` to narrow the type of the returned iterable.\n\n    This won't have any runtime effect, but allows for better type inference.\n\n    Note:\n        `Iter.filter(f).next()` is equivalent to `Iter.find(f)`.\n\n    Args:\n        func (Callable[[T], bool | TypeIs[U]]): Function to evaluate each item.\n\n    Returns:\n        Iter[T] | Iter[U]: An iterable of the items that satisfy the predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = (1, 2, 3)\n    &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).collect()\n    Seq(2, 3)\n    &gt;&gt;&gt; # See the equivalence of next and find:\n    &gt;&gt;&gt; pc.Iter(data).filter(lambda x: x &gt; 1).next()\n    Some(2)\n    &gt;&gt;&gt; pc.Iter(data).find(lambda x: x &gt; 1)\n    Some(2)\n    &gt;&gt;&gt; # Using TypeIs to narrow type:\n    &gt;&gt;&gt; from typing import TypeIs\n    &gt;&gt;&gt; def _is_str(x: object) -&gt; TypeIs[str]:\n    ...     return isinstance(x, str)\n    &gt;&gt;&gt; mixed_data = [1, \"two\", 3.0, \"four\"]\n    &gt;&gt;&gt; pc.Iter(mixed_data).filter(_is_str).collect()\n    Seq('two', 'four')\n\n    ```\n    \"\"\"\n    return Iter(filter(func, self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter_false","level":2,"title":"<code>filter_false(func)</code>","text":"<pre><code>filter_false(func: Callable[[T], TypeIs[U]]) -&gt; Iter[U]\n</code></pre><pre><code>filter_false(func: Callable[[T], bool]) -&gt; Iter[T]\n</code></pre> <p>Return elements for which func is <code>False</code>.</p> <p>The func can return a <code>TypeIs</code> to narrow the type of the returned <code>Iter</code>.</p> <p>This won't have any runtime effect, but allows for better type inference.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], bool | TypeIs[U]]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Iter[T] | Iter[U]</code> <p>Iter[T] | Iter[U]: An <code>Iter</code> of the items that do not satisfy the predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).filter_false(lambda x: x &gt; 1).collect()\nSeq(1,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter_false[U](\n    self, func: Callable[[T], bool | TypeIs[U]]\n) -&gt; Iter[T] | Iter[U]:\n    \"\"\"Return elements for which **func** is `False`.\n\n    The **func** can return a `TypeIs` to narrow the type of the returned `Iter`.\n\n    This won't have any runtime effect, but allows for better type inference.\n\n    Args:\n        func (Callable[[T], bool | TypeIs[U]]): Function to evaluate each item.\n\n    Returns:\n        Iter[T] | Iter[U]: An `Iter` of the items that do not satisfy the predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).filter_false(lambda x: x &gt; 1).collect()\n    Seq(1,)\n\n    ```\n    \"\"\"\n    return Iter(itertools.filterfalse(func, self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter_map","level":2,"title":"<code>filter_map(func)</code>","text":"<p>Creates an iterator that both filters and maps.</p> <p>The returned iterator yields only the values for which the supplied closure returns Some(value).</p> <p><code>filter_map</code> can be used to make chains of <code>filter</code> and map more concise.</p> <p>The example below shows how a <code>map().filter().map()</code> can be shortened to a single call to <code>filter_map</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Option[R]]</code> <p>Function to apply to each item.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterable of the results where func returned <code>Some</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _parse(s: str) -&gt; pc.Result[int, str]:\n...     try:\n...         return pc.Ok(int(s))\n...     except ValueError:\n...         return pc.Err(f\"Invalid integer, got {s!r}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = pc.Seq([\"1\", \"two\", \"NaN\", \"four\", \"5\"])\n&gt;&gt;&gt; data.iter().filter_map(lambda s: _parse(s).ok()).collect()\nSeq(1, 5)\n&gt;&gt;&gt; # Equivalent to:\n&gt;&gt;&gt; (\n...     data.iter()\n...    .map(lambda s: _parse(s).ok())\n...    .filter(lambda s: s.is_some())\n...    .map(lambda s: s.unwrap())\n...    .collect()\n... )\nSeq(1, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter_map[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n    \"\"\"Creates an iterator that both filters and maps.\n\n    The returned iterator yields only the values for which the supplied closure returns Some(value).\n\n    `filter_map` can be used to make chains of `filter` and map more concise.\n\n    The example below shows how a `map().filter().map()` can be shortened to a single call to `filter_map`.\n\n    Args:\n        func (Callable[[T], Option[R]]): Function to apply to each item.\n\n    Returns:\n        Iter[R]: An iterable of the results where func returned `Some`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Result[int, str]:\n    ...     try:\n    ...         return pc.Ok(int(s))\n    ...     except ValueError:\n    ...         return pc.Err(f\"Invalid integer, got {s!r}\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = pc.Seq([\"1\", \"two\", \"NaN\", \"four\", \"5\"])\n    &gt;&gt;&gt; data.iter().filter_map(lambda s: _parse(s).ok()).collect()\n    Seq(1, 5)\n    &gt;&gt;&gt; # Equivalent to:\n    &gt;&gt;&gt; (\n    ...     data.iter()\n    ...    .map(lambda s: _parse(s).ok())\n    ...    .filter(lambda s: s.is_some())\n    ...    .map(lambda s: s.unwrap())\n    ...    .collect()\n    ... )\n    Seq(1, 5)\n\n    ```\n    \"\"\"\n\n    def _filter_map(data: Iterable[T]) -&gt; Iterator[R]:\n        for item in data:\n            res = func(item)\n            if res.is_some():\n                yield res.unwrap()\n\n    return Iter(_filter_map(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter_map_star","level":2,"title":"<code>filter_map_star(func)</code>","text":"<pre><code>filter_map_star(\n    func: Callable[[Any], Option[R]],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[[T1, T2], Option[R]],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[[T1, T2, T3], Option[R]],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[[T1, T2, T3, T4], Option[R]],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[[T1, T2, T3, T4, T5], Option[R]],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], Option[R]],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], Option[R]],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8], Option[R]\n    ],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9], Option[R]\n    ],\n) -&gt; Iter[R]\n</code></pre><pre><code>filter_map_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], Option[R]\n    ],\n) -&gt; Iter[R]\n</code></pre> <p>Creates an iterator that both filters and maps, where each element is an iterable.</p> <p>Unlike <code>.filter_map()</code>, which passes each element as a single argument, <code>.filter_map_star()</code> unpacks each element into positional arguments for the function.</p> <p>In short, for each <code>element</code> in the sequence, it computes <code>func(*element)</code>.</p> <p>This is useful after using methods like <code>zip</code>, <code>product</code>, or <code>enumerate</code> that yield tuples.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Option[R]]</code> <p>Function to apply to unpacked elements.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterable of the results where func returned <code>Some</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Seq([(\"1\", \"10\"), (\"two\", \"20\"), (\"3\", \"thirty\")])\n&gt;&gt;&gt; def _parse_pair(s1: str, s2: str) -&gt; pc.Result[tuple[int, int], str]:\n...     try:\n...         return pc.Ok((int(s1), int(s2)))\n...     except ValueError:\n...         return pc.Err(f\"Invalid integer pair: {s1!r}, {s2!r}\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; data.iter().filter_map_star(lambda s1, s2: _parse_pair(s1, s2).ok()).collect()\nSeq((1, 10),)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter_map_star[U: Iterable[Any], R](\n    self: Iter[U],\n    func: Callable[..., Option[R]],\n) -&gt; Iter[R]:\n    \"\"\"Creates an iterator that both filters and maps, where each element is an iterable.\n\n    Unlike `.filter_map()`, which passes each element as a single argument, `.filter_map_star()` unpacks each element into positional arguments for the function.\n\n    In short, for each `element` in the sequence, it computes `func(*element)`.\n\n    This is useful after using methods like `zip`, `product`, or `enumerate` that yield tuples.\n\n    Args:\n        func (Callable[..., Option[R]]): Function to apply to unpacked elements.\n\n    Returns:\n        Iter[R]: An iterable of the results where func returned `Some`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Seq([(\"1\", \"10\"), (\"two\", \"20\"), (\"3\", \"thirty\")])\n    &gt;&gt;&gt; def _parse_pair(s1: str, s2: str) -&gt; pc.Result[tuple[int, int], str]:\n    ...     try:\n    ...         return pc.Ok((int(s1), int(s2)))\n    ...     except ValueError:\n    ...         return pc.Err(f\"Invalid integer pair: {s1!r}, {s2!r}\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data.iter().filter_map_star(lambda s1, s2: _parse_pair(s1, s2).ok()).collect()\n    Seq((1, 10),)\n\n    ```\n    \"\"\"\n\n    def _filter_map_star(data: Iterable[U]) -&gt; Iterator[R]:\n        for item in data:\n            res = func(*item)\n            if res.is_some():\n                yield res.unwrap()\n\n    return Iter(_filter_map_star(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.filter_star","level":2,"title":"<code>filter_star(func)</code>","text":"<pre><code>filter_star(\n    func: Callable[[Any], bool],\n) -&gt; Iter[tuple[Any]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2], bool],\n) -&gt; Iter[tuple[T1, T2]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3], bool],\n) -&gt; Iter[tuple[T1, T2, T3]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7]]\n</code></pre><pre><code>filter_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], bool],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8]]\n</code></pre><pre><code>filter_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9], bool\n    ],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]]\n</code></pre><pre><code>filter_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], bool\n    ],\n) -&gt; Iter[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]]\n</code></pre> <p>Creates an <code>Iter</code> which uses a closure func to determine if an element should be yielded, where each element is an iterable.</p> <p>Unlike <code>.filter()</code>, which passes each element as a single argument, <code>.filter_star()</code> unpacks each element into positional arguments for the func.</p> <p>In short, for each element in the <code>Iter</code>, it computes <code>func(*element)</code>.</p> <p>This is useful after using methods like <code>.zip()</code>, <code>.product()</code>, or <code>.enumerate()</code> that yield tuples.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., bool]</code> <p>Function to evaluate unpacked elements.</p> required <p>Returns:</p> Type Description <code>Iter[U]</code> <p>Iter[U]: An <code>Iter</code> of the items that satisfy the predicate.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Seq([\"apple\", \"banana\", \"cherry\", \"date\"])\n&gt;&gt;&gt; data.iter().enumerate().filter_star(lambda index, fruit: index % 2 == 0).map_star(lambda index, fruit: fruit.title()).collect()\nSeq('Apple', 'Cherry')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def filter_star[U: Iterable[Any]](\n    self: Iter[U],\n    func: Callable[..., bool],\n) -&gt; Iter[U]:\n    \"\"\"Creates an `Iter` which uses a closure **func** to determine if an element should be yielded, where each element is an iterable.\n\n    Unlike `.filter()`, which passes each element as a single argument, `.filter_star()` unpacks each element into positional arguments for the **func**.\n\n    In short, for each element in the `Iter`, it computes `func(*element)`.\n\n    This is useful after using methods like `.zip()`, `.product()`, or `.enumerate()` that yield tuples.\n\n    Args:\n        func (Callable[..., bool]): Function to evaluate unpacked elements.\n\n    Returns:\n        Iter[U]: An `Iter` of the items that satisfy the predicate.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Seq([\"apple\", \"banana\", \"cherry\", \"date\"])\n    &gt;&gt;&gt; data.iter().enumerate().filter_star(lambda index, fruit: index % 2 == 0).map_star(lambda index, fruit: fruit.title()).collect()\n    Seq('Apple', 'Cherry')\n\n    ```\n    \"\"\"\n    return Iter(filter(lambda x: func(*x), self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.find_map","level":2,"title":"<code>find_map(func)</code>","text":"<p>Applies function to the elements of the <code>Iterator</code> and returns the first Some(R) result.</p> <p><code>Iter.find_map(f)</code> is equivalent to <code>Iter.filter_map(f).next()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Option[R]]</code> <p>Function to apply to each element, returning an <code>Option[R]</code>.</p> required <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: The first <code>Some(R)</code> result from applying <code>func</code>, or <code>NONE</code> if no such result is found.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _parse(s: str) -&gt; pc.Option[int]:\n...     try:\n...         return pc.Some(int(s))\n...     except ValueError:\n...         return pc.NONE\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([\"lol\", \"NaN\", \"2\", \"5\"]).find_map(_parse)\nSome(2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def find_map[R](self, func: Callable[[T], Option[R]]) -&gt; Option[R]:\n    \"\"\"Applies function to the elements of the `Iterator` and returns the first Some(R) result.\n\n    `Iter.find_map(f)` is equivalent to `Iter.filter_map(f).next()`.\n\n    Args:\n        func (Callable[[T], Option[R]]): Function to apply to each element, returning an `Option[R]`.\n\n    Returns:\n        Option[R]: The first `Some(R)` result from applying `func`, or `NONE` if no such result is found.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _parse(s: str) -&gt; pc.Option[int]:\n    ...     try:\n    ...         return pc.Some(int(s))\n    ...     except ValueError:\n    ...         return pc.NONE\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([\"lol\", \"NaN\", \"2\", \"5\"]).find_map(_parse)\n    Some(2)\n\n    ```\n    \"\"\"\n    return self.filter_map(func).next()\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.flat_map","level":2,"title":"<code>flat_map(func)</code>","text":"<p>Creates an iterator that applies a function to each element of the original iterator and flattens the result.</p> <p>This is useful when the func you want to pass to <code>.map()</code> itself returns an iterable, and you want to avoid having nested iterables in the output.</p> <p>This is equivalent to calling <code>.map(func).flatten()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Iterable[R]]</code> <p>Function to apply to each element.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterable of flattened transformed elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).flat_map(lambda x: range(x)).collect()\nSeq(0, 0, 1, 0, 1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def flat_map[R](self, func: Callable[[T], Iterable[R]]) -&gt; Iter[R]:\n    \"\"\"Creates an iterator that applies a function to each element of the original iterator and flattens the result.\n\n    This is useful when the **func** you want to pass to `.map()` itself returns an iterable, and you want to avoid having nested iterables in the output.\n\n    This is equivalent to calling `.map(func).flatten()`.\n\n    Args:\n        func (Callable[[T], Iterable[R]]): Function to apply to each element.\n\n    Returns:\n        Iter[R]: An iterable of flattened transformed elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).flat_map(lambda x: range(x)).collect()\n    Seq(0, 0, 1, 0, 1, 2)\n\n    ```\n    \"\"\"\n    return Iter(itertools.chain.from_iterable(map(func, self._inner)))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.flatten","level":2,"title":"<code>flatten()</code>","text":"<pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[U]\n</code></pre><pre><code>flatten() -&gt; Iter[int]\n</code></pre> <p>Creates an <code>Iter</code> that flattens nested structure.</p> <p>Returns:</p> Type Description <code>Iter[Any]</code> <p>Iter[Any]: An <code>Iter</code> of flattened elements.</p> <p>This is useful when you have an <code>Iter</code> of <code>Iterable</code> and you want to remove one level of indirection.</p> <p>Examples: Basic usage: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [[1, 2, 3, 4], [5, 6]]\n&gt;&gt;&gt; flattened = pc.Iter(data).flatten().collect()\n&gt;&gt;&gt; flattened\nSeq(1, 2, 3, 4, 5, 6)\n</code></pre> Mapping and then flattening: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; words = pc.Iter([\"alpha\", \"beta\", \"gamma\"])\n&gt;&gt;&gt; merged = words.flatten().collect()\n&gt;&gt;&gt; merged\nSeq('a', 'l', 'p', 'h', 'a', 'b', 'e', 't', 'a', 'g', 'a', 'm', 'm', 'a')\n</code></pre> Flattening only removes one level of nesting at a time: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n&gt;&gt;&gt; d2 = pc.Iter(d3).flatten().collect()\n&gt;&gt;&gt; d2\nSeq([1, 2], [3, 4], [5, 6], [7, 8])\n&gt;&gt;&gt; d1 = pc.Iter(d3).flatten().flatten().collect()\n&gt;&gt;&gt; d1\nSeq(1, 2, 3, 4, 5, 6, 7, 8)\n</code></pre> Here we see that <code>flatten()</code> does not perform a ‚Äúdeep‚Äù flatten.</p> <p>Instead, only one level of nesting is removed.</p> <p>That is, if you <code>flatten()</code> a three-dimensional array, the result will be two-dimensional and not one-dimensional.</p> <p>To get a one-dimensional structure, you have to <code>flatten()</code> again.</p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def flatten[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Any]:\n    \"\"\"Creates an `Iter` that flattens nested structure.\n\n    Returns:\n        Iter[Any]: An `Iter` of flattened elements.\n\n    This is useful when you have an `Iter` of `Iterable` and you want to remove one level of indirection.\n\n    Examples:\n    Basic usage:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [[1, 2, 3, 4], [5, 6]]\n    &gt;&gt;&gt; flattened = pc.Iter(data).flatten().collect()\n    &gt;&gt;&gt; flattened\n    Seq(1, 2, 3, 4, 5, 6)\n\n    ```\n    Mapping and then flattening:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; words = pc.Iter([\"alpha\", \"beta\", \"gamma\"])\n    &gt;&gt;&gt; merged = words.flatten().collect()\n    &gt;&gt;&gt; merged\n    Seq('a', 'l', 'p', 'h', 'a', 'b', 'e', 't', 'a', 'g', 'a', 'm', 'm', 'a')\n\n    ```\n    Flattening only removes one level of nesting at a time:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; d3 = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]\n    &gt;&gt;&gt; d2 = pc.Iter(d3).flatten().collect()\n    &gt;&gt;&gt; d2\n    Seq([1, 2], [3, 4], [5, 6], [7, 8])\n    &gt;&gt;&gt; d1 = pc.Iter(d3).flatten().flatten().collect()\n    &gt;&gt;&gt; d1\n    Seq(1, 2, 3, 4, 5, 6, 7, 8)\n\n    ```\n    Here we see that `flatten()` does not perform a ‚Äúdeep‚Äù flatten.\n\n    Instead, only **one** level of nesting is removed.\n\n    That is, if you `flatten()` a three-dimensional array, the result will be two-dimensional and not one-dimensional.\n\n    To get a one-dimensional structure, you have to `flatten()` again.\n\n    \"\"\"\n    return Iter(itertools.chain.from_iterable(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.from_count","level":2,"title":"<code>from_count(start=0, step=1)</code>  <code>staticmethod</code>","text":"<p>Create an infinite <code>Iterator</code> of evenly spaced values.</p> Warning <p>This creates an infinite iterator.</p> <p>Be sure to use <code>Iter.take()</code> or <code>Iter.slice()</code> to limit the number of items taken.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>Starting value of the sequence.</p> <code>0</code> <code>step</code> <code>int</code> <p>Difference between consecutive values.</p> <code>1</code> <p>Returns:</p> Type Description <code>Iter[int]</code> <p>Iter[int]: An iterator generating the sequence.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter.from_count(10, 2).take(3).collect()\nSeq(10, 12, 14)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef from_count(start: int = 0, step: int = 1) -&gt; Iter[int]:\n    \"\"\"Create an infinite `Iterator` of evenly spaced values.\n\n    Warning:\n        This creates an infinite iterator.\n\n        Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n    Args:\n        start (int): Starting value of the sequence.\n        step (int): Difference between consecutive values.\n\n    Returns:\n        Iter[int]: An iterator generating the sequence.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter.from_count(10, 2).take(3).collect()\n    Seq(10, 12, 14)\n\n    ```\n    \"\"\"\n    return Iter(itertools.count(start, step))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.from_fn","level":2,"title":"<code>from_fn(f)</code>  <code>staticmethod</code>","text":"<p>Create an <code>Iter</code> from a nullary generator function.</p> <p>The callable must return:</p> <ul> <li><code>Some(value)</code> to yield a value</li> <li><code>NONE</code> to stop</li> </ul> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], Option[R]]</code> <p>Callable that returns the next item wrapped in <code>Option</code>.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator yielding values produced by f.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; counter = 0\n&gt;&gt;&gt; def gen() -&gt; pc.Option[int]:\n...     global counter\n...     counter += 1\n...     return pc.Some(counter) if counter &lt; 6 else pc.NONE\n&gt;&gt;&gt; pc.Iter.from_fn(gen).collect()\nSeq(1, 2, 3, 4, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef from_fn[R](f: Callable[[], Option[R]]) -&gt; Iter[R]:\n    \"\"\"Create an `Iter` from a nullary generator function.\n\n    The callable must return:\n\n    - `Some(value)` to yield a value\n    - `NONE` to stop\n\n\n    Args:\n        f (Callable[[], Option[R]]): Callable that returns the next item wrapped in `Option`.\n\n    Returns:\n        Iter[R]: An iterator yielding values produced by **f**.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; counter = 0\n    &gt;&gt;&gt; def gen() -&gt; pc.Option[int]:\n    ...     global counter\n    ...     counter += 1\n    ...     return pc.Some(counter) if counter &lt; 6 else pc.NONE\n    &gt;&gt;&gt; pc.Iter.from_fn(gen).collect()\n    Seq(1, 2, 3, 4, 5)\n\n    ```\n    \"\"\"\n\n    def _from_fn() -&gt; Iterator[R]:\n        while True:\n            item = f()\n            if item.is_none():\n                return\n            yield item.unwrap()\n\n    return Iter(_from_fn())\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.from_ref","level":2,"title":"<code>from_ref(other)</code>  <code>classmethod</code>","text":"<p>Create an independent lazy copy from another <code>Iter</code>.</p> <p>Both the original and the returned <code>Iter</code> can be consumed independently, in a lazy manner.</p> Note <p>Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.</p> <p>This is the unavoidable cost of having two independent iterators over the same source.</p> <p>However, once both iterators have passed a value, it's freed from memory.</p> See Also <ul> <li><code>Iter.cloned()</code> which is the instance method version of this function.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>An <code>Iter</code> instance to copy.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Iter</code> instance that is independent from the original.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; original = pc.Iter([1, 2, 3])\n&gt;&gt;&gt; copy = pc.Iter.from_ref(original)\n&gt;&gt;&gt; copy.map(lambda x: x * 2).collect()\nSeq(2, 4, 6)\n&gt;&gt;&gt; original.next()\nSome(1)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@classmethod\ndef from_ref(cls, other: Self) -&gt; Self:\n    \"\"\"Create an independent lazy copy from another `Iter`.\n\n    Both the original and the returned `Iter` can be consumed independently, in a lazy manner.\n\n    Note:\n        Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.\n\n        This is the unavoidable cost of having two independent iterators over the same source.\n\n        However, once both iterators have passed a value, it's freed from memory.\n\n    See Also:\n        - `Iter.cloned()` which is the instance method version of this function.\n\n    Args:\n        other (Self): An `Iter` instance to copy.\n\n    Returns:\n        Self: A new `Iter` instance that is independent from the original.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; original = pc.Iter([1, 2, 3])\n    &gt;&gt;&gt; copy = pc.Iter.from_ref(original)\n    &gt;&gt;&gt; copy.map(lambda x: x * 2).collect()\n    Seq(2, 4, 6)\n    &gt;&gt;&gt; original.next()\n    Some(1)\n\n    ```\n    \"\"\"\n    it1, it2 = itertools.tee(other._inner)\n    other._inner = it1\n    return cls(it2)\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.group_by","level":2,"title":"<code>group_by(key=None)</code>","text":"<pre><code>group_by(key: None = None) -&gt; Iter[tuple[T, Self]]\n</code></pre><pre><code>group_by(key: Callable[[T], K]) -&gt; Iter[tuple[K, Self]]\n</code></pre><pre><code>group_by(\n    key: Callable[[T], K] | None = None,\n) -&gt; Iter[tuple[K, Self] | tuple[T, Self]]\n</code></pre> <p>Make an <code>Iter</code> that returns consecutive keys and groups from the iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function computing a key value for each element..</p> <code>None</code> <p>If not specified or is None, key defaults to an identity function and returns the element unchanged.</p> <p>Returns:</p> Type Description <code>Iter[tuple[Any | T, Self]]</code> <p>Iter[tuple[Any | T, Self]]: An <code>Iter</code> of <code>(key, value)</code> tuples.</p> <p>The values yielded are <code>(K, Self)</code> tuples, where the first element is the group key and the second element is an <code>Iter</code> of type <code>T</code> over the group values.</p> <p>The <code>Iter</code> needs to already be sorted on the same key function.</p> <p>This is due to the fact that it generates a new <code>Group</code> every time the value of the key function changes.</p> <p>That behavior differs from SQL's <code>GROUP BY</code> which aggregates common elements regardless of their input order.</p> Warning <p>You must materialize the second element of the tuple immediately when iterating over groups.</p> <p>Because <code>.group_by()</code> uses Python's <code>itertools.groupby</code> under the hood, each group's iterator shares internal state.</p> <p>When you advance to the next group, the previous group's iterator becomes invalid and will yield empty results.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Example 1: Group even and odd numbers\n&gt;&gt;&gt; (\n... pc.Iter.from_count() # create an infinite iterator of integers\n... .take(8) # take the first 8\n... .map(lambda x: (x % 2 == 0, x)) # map to (is_even, value)\n... .sort(key=lambda x: x[0]) # sort by is_even\n... .iter() # Since sort collect to a Vec, we need to convert back to Iter\n... .group_by(lambda x: x[0]) # group by is_even\n... .map_star(lambda g, vals: (g, vals.map_star(lambda _, y: y).into(list))) # extract values from groups, discarding keys, and materializing them to lists\n... .collect() # collect the result\n... .into(dict) # convert to dict\n... )\n{False: [1, 3, 5, 7], True: [0, 2, 4, 6]}\n&gt;&gt;&gt; # Example 2: Group by a common key, already sorted\n&gt;&gt;&gt; data = [\n...     {\"name\": \"Alice\", \"gender\": \"F\"},\n...     {\"name\": \"Bob\", \"gender\": \"M\"},\n...     {\"name\": \"Charlie\", \"gender\": \"M\"},\n...     {\"name\": \"Dan\", \"gender\": \"M\"},\n... ]\n&gt;&gt;&gt; (\n... pc.Iter(data)\n... .group_by(lambda x: x[\"gender\"]) # group by the gender key\n... .map_star(lambda g, vals: (g, vals.length())) # get the length of each group\n... .collect()\n... )\nSeq(('F', 1), ('M', 3))\n&gt;&gt;&gt; # Example 3: Incorrect usage with LATE materialization:\n&gt;&gt;&gt; groups = pc.Iter([\"a1\", \"a2\", \"b1\"]).group_by(lambda x: x[0]).collect()\n&gt;&gt;&gt; # Now iterate - TOO LATE! The group iterators are consumed\n&gt;&gt;&gt; for g in groups:\n...     print(g[1].collect())  # ‚ùå Empty!\nSeq()\nSeq()\n&gt;&gt;&gt; # Example 4: Correct usage with intermediate materialization:\n&gt;&gt;&gt; groups = (\n...     pc.Iter([\"a1\", \"a2\", \"b1\"])\n...     .group_by(lambda x: x[0])\n...     .map_star(lambda g, vals: (g, vals.collect()))  # ‚úÖ Materialize NOW\n...     .collect()\n...     .iter()\n...     .for_each(lambda x: print(f\"{x[0]}: {x[1]}\"))\n... )\na: Seq('a1', 'a2')\nb: Seq('b1',)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def group_by(\n    self, key: Callable[[T], Any] | None = None\n) -&gt; Iter[tuple[Any | T, Self]]:\n    \"\"\"Make an `Iter` that returns consecutive keys and groups from the iterable.\n\n    Args:\n        key (Callable[[T], Any] | None): Function computing a key value for each element..\n    If not specified or is None, **key** defaults to an identity function and returns the element unchanged.\n\n    Returns:\n        Iter[tuple[Any | T, Self]]: An `Iter` of `(key, value)` tuples.\n\n    The values yielded are `(K, Self)` tuples, where the first element is the group key and the second element is an `Iter` of type `T` over the group values.\n\n    The `Iter` needs to already be sorted on the same key function.\n\n    This is due to the fact that it generates a new `Group` every time the value of the **key** function changes.\n\n    That behavior differs from SQL's `GROUP BY` which aggregates common elements regardless of their input order.\n\n    Warning:\n        You must materialize the second element of the tuple immediately when iterating over groups.\n\n        Because `.group_by()` uses Python's `itertools.groupby` under the hood, each group's iterator shares internal state.\n\n        When you advance to the next group, the previous group's iterator becomes invalid and will yield empty results.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Example 1: Group even and odd numbers\n    &gt;&gt;&gt; (\n    ... pc.Iter.from_count() # create an infinite iterator of integers\n    ... .take(8) # take the first 8\n    ... .map(lambda x: (x % 2 == 0, x)) # map to (is_even, value)\n    ... .sort(key=lambda x: x[0]) # sort by is_even\n    ... .iter() # Since sort collect to a Vec, we need to convert back to Iter\n    ... .group_by(lambda x: x[0]) # group by is_even\n    ... .map_star(lambda g, vals: (g, vals.map_star(lambda _, y: y).into(list))) # extract values from groups, discarding keys, and materializing them to lists\n    ... .collect() # collect the result\n    ... .into(dict) # convert to dict\n    ... )\n    {False: [1, 3, 5, 7], True: [0, 2, 4, 6]}\n    &gt;&gt;&gt; # Example 2: Group by a common key, already sorted\n    &gt;&gt;&gt; data = [\n    ...     {\"name\": \"Alice\", \"gender\": \"F\"},\n    ...     {\"name\": \"Bob\", \"gender\": \"M\"},\n    ...     {\"name\": \"Charlie\", \"gender\": \"M\"},\n    ...     {\"name\": \"Dan\", \"gender\": \"M\"},\n    ... ]\n    &gt;&gt;&gt; (\n    ... pc.Iter(data)\n    ... .group_by(lambda x: x[\"gender\"]) # group by the gender key\n    ... .map_star(lambda g, vals: (g, vals.length())) # get the length of each group\n    ... .collect()\n    ... )\n    Seq(('F', 1), ('M', 3))\n    &gt;&gt;&gt; # Example 3: Incorrect usage with LATE materialization:\n    &gt;&gt;&gt; groups = pc.Iter([\"a1\", \"a2\", \"b1\"]).group_by(lambda x: x[0]).collect()\n    &gt;&gt;&gt; # Now iterate - TOO LATE! The group iterators are consumed\n    &gt;&gt;&gt; for g in groups:\n    ...     print(g[1].collect())  # ‚ùå Empty!\n    Seq()\n    Seq()\n    &gt;&gt;&gt; # Example 4: Correct usage with intermediate materialization:\n    &gt;&gt;&gt; groups = (\n    ...     pc.Iter([\"a1\", \"a2\", \"b1\"])\n    ...     .group_by(lambda x: x[0])\n    ...     .map_star(lambda g, vals: (g, vals.collect()))  # ‚úÖ Materialize NOW\n    ...     .collect()\n    ...     .iter()\n    ...     .for_each(lambda x: print(f\"{x[0]}: {x[1]}\"))\n    ... )\n    a: Seq('a1', 'a2')\n    b: Seq('b1',)\n\n    ```\n    \"\"\"\n    new = self.__class__\n    return Iter((x, new(y)) for x, y in itertools.groupby(self._inner, key))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.is_strictly_n","level":2,"title":"<code>is_strictly_n(n)</code>","text":"<p>Yield<code>Ok[T]</code> as long as the iterable has exactly n items.</p> <p>If it has fewer than n items, yield <code>Err[ValueError]</code> with the actual number of items.</p> <p>If it has more than n items, yield <code>Err[ValueError]</code> with the number <code>n + 1</code>.</p> <p>Note that the returned iterable must be consumed in order for the check to be made.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The exact number of items expected.</p> required <p>Returns:</p> Type Description <code>Iter[Result[T, ValueError]]</code> <p>Iter[Result[T, ValueError]]: A new Iterable wrapper yielding results based on the item count.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [\"a\", \"b\", \"c\", \"d\"]\n&gt;&gt;&gt; n = 4\n&gt;&gt;&gt; pc.Iter(data).is_strictly_n(n).collect()\nSeq(Ok('a'), Ok('b'), Ok('c'), Ok('d'))\n&gt;&gt;&gt; pc.Iter(\"ab\").is_strictly_n(3).collect()  # doctest: +NORMALIZE_WHITESPACE\nSeq(Ok('a'), Ok('b'),\nErr(ValueError('Too few items in iterable (got 2)')))\n&gt;&gt;&gt; pc.Iter(\"abc\").is_strictly_n(2).collect()  # doctest: +NORMALIZE_WHITESPACE\nSeq(Ok('a'), Ok('b'),\nErr(ValueError('Too many items in iterable (got at least 3)')))\n</code></pre> You can easily combine this with <code>.map(lambda r: r.map_err(...))</code> to handle the errors as you wish. <pre><code>&gt;&gt;&gt; def _my_err(e: ValueError) -&gt; str:\n...     return f\"custom error: {e}\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([1]).is_strictly_n(0).map(lambda r: r.map_err(_my_err)).collect()\nSeq(Err('custom error: Too many items in iterable (got at least 1)'),)\n</code></pre> Or use <code>.filter_map(...)</code> to only keep the <code>Ok</code> values. <pre><code>&gt;&gt;&gt; pc.Iter([1, 2, 3]).is_strictly_n(2).filter_map(lambda r: r.ok()).collect()\nSeq(1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def is_strictly_n(self, n: int) -&gt; Iter[Result[T, ValueError]]:\n    \"\"\"Yield`Ok[T]` as long as the iterable has exactly *n* items.\n\n    If it has fewer than *n* items, yield `Err[ValueError]` with the actual number of items.\n\n    If it has more than *n* items, yield `Err[ValueError]` with the number `n + 1`.\n\n    Note that the returned iterable must be consumed in order for the check to\n    be made.\n\n    Args:\n        n (int): The exact number of items expected.\n\n    Returns:\n        Iter[Result[T, ValueError]]: A new Iterable wrapper yielding results based on the item count.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [\"a\", \"b\", \"c\", \"d\"]\n    &gt;&gt;&gt; n = 4\n    &gt;&gt;&gt; pc.Iter(data).is_strictly_n(n).collect()\n    Seq(Ok('a'), Ok('b'), Ok('c'), Ok('d'))\n    &gt;&gt;&gt; pc.Iter(\"ab\").is_strictly_n(3).collect()  # doctest: +NORMALIZE_WHITESPACE\n    Seq(Ok('a'), Ok('b'),\n    Err(ValueError('Too few items in iterable (got 2)')))\n    &gt;&gt;&gt; pc.Iter(\"abc\").is_strictly_n(2).collect()  # doctest: +NORMALIZE_WHITESPACE\n    Seq(Ok('a'), Ok('b'),\n    Err(ValueError('Too many items in iterable (got at least 3)')))\n\n    ```\n    You can easily combine this with `.map(lambda r: r.map_err(...))` to handle the errors as you wish.\n    ```python\n    &gt;&gt;&gt; def _my_err(e: ValueError) -&gt; str:\n    ...     return f\"custom error: {e}\"\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([1]).is_strictly_n(0).map(lambda r: r.map_err(_my_err)).collect()\n    Seq(Err('custom error: Too many items in iterable (got at least 1)'),)\n\n    ```\n    Or use `.filter_map(...)` to only keep the `Ok` values.\n    ```python\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).is_strictly_n(2).filter_map(lambda r: r.ok()).collect()\n    Seq(1, 2)\n\n    ```\n    \"\"\"\n\n    def _strictly_n_(data: Iterator[T]) -&gt; Iterator[Result[T, ValueError]]:\n        sent = 0\n        for item in itertools.islice(data, n):\n            yield Ok(item)\n            sent += 1\n\n        if sent &lt; n:\n            e = ValueError(f\"Too few items in iterable (got {sent})\")\n            yield Err(e)\n\n        for _ in data:\n            e = ValueError(f\"Too many items in iterable (got at least {n + 1})\")\n            yield Err(e)\n\n    return Iter(_strictly_n_(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map","level":2,"title":"<code>map(func)</code>","text":"<p>Apply a function func to each element of the <code>Iter</code>.</p> <p>If you are good at thinking in types, you can think of <code>Iter.map()</code> like this:</p> <ul> <li>You have an <code>Iterator</code> that gives you elements of some type <code>A</code></li> <li>You want an <code>Iterator</code> of some other type <code>B</code></li> <li>Thenyou can use <code>.map()</code>, passing a closure func that takes an <code>A</code> and returns a <code>B</code>.</li> </ul> <p><code>Iter.map()</code> is conceptually similar to a for loop.</p> <p>However, as <code>Iter.map()</code> is lazy, it is best used when you are already working with other <code>Iter</code> instances.</p> <p>If you are doing some sort of looping for a side effect, it is considered more idiomatic to use <code>Iter.for_each()</code> than <code>Iter.map().collect()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], R]</code> <p>Function to apply to each element.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator of transformed elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).map(lambda x: x + 1).collect()\nSeq(2, 3)\n&gt;&gt;&gt; # You can use methods on the class rather than on instance for convenience:\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).map(str.upper).collect()\nSeq('A', 'B', 'C')\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).map(lambda s: s.upper()).collect()\nSeq('A', 'B', 'C')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map[R](self, func: Callable[[T], R]) -&gt; Iter[R]:\n    \"\"\"Apply a function **func** to each element of the `Iter`.\n\n    If you are good at thinking in types, you can think of `Iter.map()` like this:\n\n    - You have an `Iterator` that gives you elements of some type `A`\n    - You want an `Iterator` of some other type `B`\n    - Thenyou can use `.map()`, passing a closure **func** that takes an `A` and returns a `B`.\n\n    `Iter.map()` is conceptually similar to a for loop.\n\n    However, as `Iter.map()` is lazy, it is best used when you are already working with other `Iter` instances.\n\n    If you are doing some sort of looping for a side effect, it is considered more idiomatic to use `Iter.for_each()` than `Iter.map().collect()`.\n\n    Args:\n        func (Callable[[T], R]): Function to apply to each element.\n\n    Returns:\n        Iter[R]: An iterator of transformed elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).map(lambda x: x + 1).collect()\n    Seq(2, 3)\n    &gt;&gt;&gt; # You can use methods on the class rather than on instance for convenience:\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).map(str.upper).collect()\n    Seq('A', 'B', 'C')\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).map(lambda s: s.upper()).collect()\n    Seq('A', 'B', 'C')\n\n    ```\n    \"\"\"\n    return Iter(map(func, self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_juxt","level":2,"title":"<code>map_juxt(*funcs)</code>","text":"<pre><code>map_juxt(\n    func1: Callable[[T], R1], func2: Callable[[T], R2]\n) -&gt; Iter[tuple[R1, R2]]\n</code></pre><pre><code>map_juxt(\n    func1: Callable[[T], R1],\n    func2: Callable[[T], R2],\n    func3: Callable[[T], R3],\n) -&gt; Iter[tuple[R1, R2, R3]]\n</code></pre><pre><code>map_juxt(\n    func1: Callable[[T], R1],\n    func2: Callable[[T], R2],\n    func3: Callable[[T], R3],\n    func4: Callable[[T], R4],\n) -&gt; Iter[tuple[R1, R2, R3, R4]]\n</code></pre> <p>Apply several functions to each item.</p> <p>Returns a new Iter where each item is a tuple of the results of applying each function to the original item.</p> <p>Parameters:</p> Name Type Description Default <code>*funcs</code> <code>Callable[[T], object]</code> <p>Functions to apply to each item.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[tuple[object, ...]]</code> <p>Iter[tuple[object, ...]]: An iterable of tuples containing the results of each function.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n...     return n % 2 == 0\n&gt;&gt;&gt; def is_positive(n: int) -&gt; bool:\n...     return n &gt; 0\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([1, -2, 3]).map_juxt(is_even, is_positive).collect()\nSeq((False, True), (True, False), (False, True))\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_juxt(self, *funcs: Callable[[T], object]) -&gt; Iter[tuple[object, ...]]:\n    \"\"\"Apply several functions to each item.\n\n    Returns a new Iter where each item is a tuple of the results of applying each function to the original item.\n\n    Args:\n        *funcs (Callable[[T], object]): Functions to apply to each item.\n\n    Returns:\n        Iter[tuple[object, ...]]: An iterable of tuples containing the results of each function.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n    ...     return n % 2 == 0\n    &gt;&gt;&gt; def is_positive(n: int) -&gt; bool:\n    ...     return n &gt; 0\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([1, -2, 3]).map_juxt(is_even, is_positive).collect()\n    Seq((False, True), (True, False), (False, True))\n\n    ```\n    \"\"\"\n    return Iter(map(cz.functoolz.juxt(*funcs), self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_star","level":2,"title":"<code>map_star(func)</code>","text":"<pre><code>map_star(func: Callable[[Any], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2, T3], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2, T3, T4], R]) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R\n    ],\n) -&gt; Iter[R]\n</code></pre> <p>Applies a function to each element.where each element is an iterable.</p> <p>Unlike <code>.map()</code>, which passes each element as a single argument, <code>.starmap()</code> unpacks each element into positional arguments for the function.</p> <p>In short, for each element in the <code>Iter</code>, it computes <code>func(*element)</code>.</p> Note <p>Always prefer using <code>.map_star()</code> over <code>.map()</code> when working with <code>Iter</code> of <code>tuple</code> elements. Not only it is more readable, but it's also much more performant (up to 30% faster in benchmarks).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>Function to apply to unpacked elements.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterable of results from applying the function to unpacked elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def make_sku(color: str, size: str) -&gt; str:\n...     return f\"{color}-{size}\"\n&gt;&gt;&gt; data = pc.Seq([\"blue\", \"red\"])\n&gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map_star(make_sku).collect()\nSeq('blue-S', 'blue-M', 'red-S', 'red-M')\n&gt;&gt;&gt; # This is equivalent to:\n&gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map(lambda x: make_sku(*x)).collect()\nSeq('blue-S', 'blue-M', 'red-S', 'red-M')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_star[U: Iterable[Any], R](\n    self: Iter[U],\n    func: Callable[..., R],\n) -&gt; Iter[R]:\n    \"\"\"Applies a function to each element.where each element is an iterable.\n\n    Unlike `.map()`, which passes each element as a single argument, `.starmap()` unpacks each element into positional arguments for the function.\n\n    In short, for each element in the `Iter`, it computes `func(*element)`.\n\n    Note:\n        Always prefer using `.map_star()` over `.map()` when working with `Iter` of `tuple` elements.\n        Not only it is more readable, but it's also much more performant (up to 30% faster in benchmarks).\n\n    Args:\n        func (Callable[..., R]): Function to apply to unpacked elements.\n\n    Returns:\n        Iter[R]: An iterable of results from applying the function to unpacked elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def make_sku(color: str, size: str) -&gt; str:\n    ...     return f\"{color}-{size}\"\n    &gt;&gt;&gt; data = pc.Seq([\"blue\", \"red\"])\n    &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map_star(make_sku).collect()\n    Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n    &gt;&gt;&gt; # This is equivalent to:\n    &gt;&gt;&gt; data.iter().product([\"S\", \"M\"]).map(lambda x: make_sku(*x)).collect()\n    Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n\n    ```\n    \"\"\"\n    return Iter(itertools.starmap(func, self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_while","level":2,"title":"<code>map_while(func)</code>","text":"<p>Creates an iterator that both yields elements based on a predicate and maps.</p> <p><code>map_while()</code> takes a closure as an argument. It will call this closure on each element of the iterator, and yield elements while it returns <code>Some(_)</code>.</p> <p>After <code>NONE</code> is returned, <code>map_while()</code> stops and the rest of the elements are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T], Option[R]]</code> <p>Function to apply to each element that returns <code>Option[R]</code>.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator of transformed elements until <code>NONE</code> is encountered.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def checked_div(x: int) -&gt; pc.Option[int]:\n...     return pc.Some(16 // x) if x != 0 else pc.NONE\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = pc.Iter([-1, 4, 0, 1])\n&gt;&gt;&gt; data.map_while(checked_div).collect()\nSeq(-16, 4)\n&gt;&gt;&gt; data = pc.Iter([0, 1, 2, -3, 4, 5, -6])\n&gt;&gt;&gt; # Convert to positive ints, stop at first negative\n&gt;&gt;&gt; data.map_while(lambda x: pc.Some(x) if x &gt;= 0 else pc.NONE).collect()\nSeq(0, 1, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_while[R](self, func: Callable[[T], Option[R]]) -&gt; Iter[R]:\n    \"\"\"Creates an iterator that both yields elements based on a predicate and maps.\n\n    `map_while()` takes a closure as an argument. It will call this closure on each element of\n    the iterator, and yield elements while it returns `Some(_)`.\n\n    After `NONE` is returned, `map_while()` stops and the rest of the elements are ignored.\n\n    Args:\n        func (Callable[[T], Option[R]]): Function to apply to each element that returns `Option[R]`.\n\n    Returns:\n        Iter[R]: An iterator of transformed elements until `NONE` is encountered.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def checked_div(x: int) -&gt; pc.Option[int]:\n    ...     return pc.Some(16 // x) if x != 0 else pc.NONE\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = pc.Iter([-1, 4, 0, 1])\n    &gt;&gt;&gt; data.map_while(checked_div).collect()\n    Seq(-16, 4)\n    &gt;&gt;&gt; data = pc.Iter([0, 1, 2, -3, 4, 5, -6])\n    &gt;&gt;&gt; # Convert to positive ints, stop at first negative\n    &gt;&gt;&gt; data.map_while(lambda x: pc.Some(x) if x &gt;= 0 else pc.NONE).collect()\n    Seq(0, 1, 2)\n\n    ```\n    \"\"\"\n\n    def _gen() -&gt; Generator[R]:\n        for opt in map(func, self._inner):\n            if opt.is_none():\n                return\n            yield opt.unwrap()\n\n    return Iter(_gen())\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_windows","level":2,"title":"<code>map_windows(length, func)</code>","text":"<pre><code>map_windows(\n    length: Literal[1], func: Callable[[tuple[T]], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[2], func: Callable[[tuple[T, T]], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[3], func: Callable[[tuple[T, T, T]], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[4],\n    func: Callable[[tuple[T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[5],\n    func: Callable[[tuple[T, T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[6],\n    func: Callable[[tuple[T, T, T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[7],\n    func: Callable[[tuple[T, T, T, T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[8],\n    func: Callable[[tuple[T, T, T, T, T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[9],\n    func: Callable[[tuple[T, T, T, T, T, T, T, T, T]], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: Literal[10],\n    func: Callable[\n        [tuple[T, T, T, T, T, T, T, T, T, T]], R\n    ],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows(\n    length: int, func: Callable[[tuple[T, ...]], R]\n) -&gt; Iter[R]\n</code></pre> <p>Calls the given func for each contiguous window of size length over self.</p> <p>The windows during mapping overlaps.</p> <p>The provided function is called with the entire window as a single tuple argument.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of each window.</p> required <code>func</code> <code>Callable[[tuple[Any, ...]], R]</code> <p>Function to apply to each window.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator over the outputs of func.</p> See Also <p><code>.map_windows_star()</code> for a version that unpacks the window into separate arguments.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; import statistics\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, statistics.mean).collect()\nSeq(1.5, 2.5, 3.5)\n&gt;&gt;&gt; pc.Iter(\"abcd\").map_windows(3, lambda window: \"\".join(window).upper()).collect()\nSeq('ABC', 'BCD')\n&gt;&gt;&gt; pc.Iter([10, 20, 30, 40, 50]).map_windows(4, sum).collect()\nSeq(100, 140)\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; pc.Iter([\"home\", \"src\", \"pyochain\"]).map_windows(2, lambda p: str(Path(*p))).collect()\nSeq('home\\\\src', 'src\\\\pyochain')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_windows[R](\n    self, length: int, func: Callable[[tuple[Any, ...]], R]\n) -&gt; Iter[R]:\n    r\"\"\"Calls the given *func* for each contiguous window of size *length* over **self**.\n\n    The windows during mapping overlaps.\n\n    The provided function is called with the entire window as a single tuple argument.\n\n    Args:\n        length (int): The length of each window.\n        func (Callable[[tuple[Any, ...]], R]): Function to apply to each window.\n\n    Returns:\n        Iter[R]: An iterator over the outputs of func.\n\n    See Also:\n        `.map_windows_star()` for a version that unpacks the window into separate arguments.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; import statistics\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows(2, statistics.mean).collect()\n    Seq(1.5, 2.5, 3.5)\n    &gt;&gt;&gt; pc.Iter(\"abcd\").map_windows(3, lambda window: \"\".join(window).upper()).collect()\n    Seq('ABC', 'BCD')\n    &gt;&gt;&gt; pc.Iter([10, 20, 30, 40, 50]).map_windows(4, sum).collect()\n    Seq(100, 140)\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; pc.Iter([\"home\", \"src\", \"pyochain\"]).map_windows(2, lambda p: str(Path(*p))).collect()\n    Seq('home\\\\src', 'src\\\\pyochain')\n\n\n    ```\n    \"\"\"\n    return Iter(map(func, cz.itertoolz.sliding_window(length, self._inner)))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.map_windows_star","level":2,"title":"<code>map_windows_star(length, func)</code>","text":"<pre><code>map_windows_star(\n    length: Literal[1], func: Callable[[T], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[2], func: Callable[[T, T], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[3], func: Callable[[T, T, T], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[4], func: Callable[[T, T, T, T], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[5], func: Callable[[T, T, T, T, T], R]\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[6],\n    func: Callable[[T, T, T, T, T, T], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[7],\n    func: Callable[[T, T, T, T, T, T, T], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[8],\n    func: Callable[[T, T, T, T, T, T, T, T], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[9],\n    func: Callable[[T, T, T, T, T, T, T, T, T], R],\n) -&gt; Iter[R]\n</code></pre><pre><code>map_windows_star(\n    length: Literal[10],\n    func: Callable[[T, T, T, T, T, T, T, T, T, T], R],\n) -&gt; Iter[R]\n</code></pre> <p>Calls the given func for each contiguous window of size length over self.</p> <p>The windows during mapping overlaps.</p> <p>The provided function is called with each element of the window as separate arguments.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length of each window.</p> required <code>func</code> <code>Callable[..., R]</code> <p>Function to apply to each window.</p> required <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator over the outputs of func.</p> See Also <p><code>.map_windows()</code> for a version that passes the entire window as a single tuple argument.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"abcd\").map_windows_star(2, lambda x, y: f\"{x}+{y}\").collect()\nSeq('a+b', 'b+c', 'c+d')\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows_star(2, lambda x, y: x + y).collect()\nSeq(3, 5, 7)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def map_windows_star[R](self, length: int, func: Callable[..., R]) -&gt; Iter[R]:\n    \"\"\"Calls the given *func* for each contiguous window of size *length* over **self**.\n\n    The windows during mapping overlaps.\n\n    The provided function is called with each element of the window as separate arguments.\n\n    Args:\n        length (int): The length of each window.\n        func (Callable[..., R]): Function to apply to each window.\n\n    Returns:\n        Iter[R]: An iterator over the outputs of func.\n\n    See Also:\n        `.map_windows()` for a version that passes the entire window as a single tuple argument.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"abcd\").map_windows_star(2, lambda x, y: f\"{x}+{y}\").collect()\n    Seq('a+b', 'b+c', 'c+d')\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map_windows_star(2, lambda x, y: x + y).collect()\n    Seq(3, 5, 7)\n\n    ```\n    \"\"\"\n    return Iter(\n        itertools.starmap(func, cz.itertoolz.sliding_window(length, self._inner))\n    )\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.most_common","level":2,"title":"<code>most_common(n=None)</code>","text":"<p>Return the n most common elements and their counts from the <code>Iterator</code>.</p> <p>If n is <code>None</code>, then all elements are returned.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of most common elements to return. Defaults to None (all elements).</p> <code>None</code> <p>Returns:</p> Type Description <code>Vec[tuple[T, int]]</code> <p>Vec[tuple[T, int]]: A <code>Vec</code> containing tuples of (element, count).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 1, 2, 3, 3, 3]).most_common(2)\nVec((3, 3), (1, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def most_common(self, n: int | None = None) -&gt; Vec[tuple[T, int]]:\n    \"\"\"Return the **n** most common elements and their counts from the `Iterator`.\n\n    If **n** is `None`, then all elements are returned.\n\n    Args:\n        n (int | None): Number of most common elements to return. Defaults to None (all elements).\n\n    Returns:\n        Vec[tuple[T, int]]: A `Vec` containing tuples of (element, count).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 1, 2, 3, 3, 3]).most_common(2)\n    Vec((3, 3), (1, 2))\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return Vec.from_ref(Counter(self._inner).most_common(n))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.once","level":2,"title":"<code>once(value)</code>  <code>staticmethod</code>","text":"<p>Create an <code>Iter</code> that yields a single value.</p> <p>If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like <code>Iter([value])</code>.</p> <p>This can be considered the equivalent of <code>.insert()</code> but as a constructor.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The single value to yield.</p> required <p>Returns:</p> Type Description <code>Iter[V]</code> <p>Iter[V]: An iterator yielding the specified value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter.once(42).collect()\nSeq(42,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef once[V](value: V) -&gt; Iter[V]:\n    \"\"\"Create an `Iter` that yields a single value.\n\n    If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n    This can be considered the equivalent of `.insert()` but as a constructor.\n\n    Args:\n        value (V): The single value to yield.\n\n    Returns:\n        Iter[V]: An iterator yielding the specified value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter.once(42).collect()\n    Seq(42,)\n\n    ```\n    \"\"\"\n    return Iter((value,))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.once_with","level":2,"title":"<code>once_with(func, *args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Create an <code>Iter</code>  that lazily generates a value exactly once by invoking the provided closure.</p> <p>If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like <code>Iter([value])</code>.</p> <p>This can be considered the equivalent of <code>.insert()</code> but as a constructor.</p> <p>Unlike <code>.once()</code>, this function will lazily generate the value on request.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[P, R]</code> <p>The single value to yield.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Iter[R]</code> <p>Iter[R]: An iterator yielding the specified value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter.once(42).collect()\nSeq(42,)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef once_with[**P, R](\n    func: Callable[P, R], *args: P.args, **kwargs: P.kwargs\n) -&gt; Iter[R]:\n    \"\"\"Create an `Iter`  that lazily generates a value exactly once by invoking the provided closure.\n\n    If you have a function which works on iterators, but you only need to process one value, you can use this method rather than doing something like `Iter([value])`.\n\n    This can be considered the equivalent of `.insert()` but as a constructor.\n\n    Unlike `.once()`, this function will lazily generate the value on request.\n\n    Args:\n        func (Callable[P, R]): The single value to yield.\n        *args (P.args): Positional arguments to pass to **func**.\n        **kwargs (P.kwargs): Keyword arguments to pass to **func**.\n\n    Returns:\n        Iter[R]: An iterator yielding the specified value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter.once(42).collect()\n    Seq(42,)\n\n    ```\n    \"\"\"\n\n    def _once_with() -&gt; Generator[R]:\n        yield func(*args, **kwargs)\n\n    return Iter(_once_with())\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.pairwise","level":2,"title":"<code>pairwise()</code>","text":"<p>Return an iterator over pairs of consecutive elements.</p> <p>Returns:</p> Type Description <code>Iter[tuple[T, T]]</code> <p>Iter[tuple[T, T]]: An iterable of pairs of consecutive elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).pairwise().collect()\nSeq((1, 2), (2, 3))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def pairwise(self) -&gt; Iter[tuple[T, T]]:\n    \"\"\"Return an iterator over pairs of consecutive elements.\n\n    Returns:\n        Iter[tuple[T, T]]: An iterable of pairs of consecutive elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).pairwise().collect()\n    Seq((1, 2), (2, 3))\n\n    ```\n    \"\"\"\n    return Iter(itertools.pairwise(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.partition","level":2,"title":"<code>partition(n, pad=None)</code>","text":"<pre><code>partition(\n    n: Literal[1], pad: None = None\n) -&gt; Iter[tuple[T]]\n</code></pre><pre><code>partition(\n    n: Literal[2], pad: None = None\n) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>partition(\n    n: Literal[3], pad: None = None\n) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>partition(\n    n: Literal[4], pad: None = None\n) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>partition(\n    n: Literal[5], pad: None = None\n) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre><pre><code>partition(n: int, pad: T) -&gt; Iter[tuple[T, ...]]\n</code></pre> <p>Partition self into <code>tuples</code> of length n.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Length of each partition.</p> required <code>pad</code> <code>T | None</code> <p>Value to pad the last partition if needed.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of partitioned tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition(2).collect()\nSeq((1, 2), (3, 4))\n</code></pre> If the length of seq is not evenly divisible by n, the final tuple is dropped if pad is not specified, or filled to length n by pad: <pre><code>&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition(2).collect()\nSeq((1, 2), (3, 4), (5, None))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def partition(self, n: int, pad: T | None = None) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Partition **self** into `tuples` of length **n**.\n\n    Args:\n        n (int): Length of each partition.\n        pad (T | None): Value to pad the last partition if needed.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition(2).collect()\n    Seq((1, 2), (3, 4))\n\n    ```\n    If the length of seq is not evenly divisible by n, the final tuple is dropped if pad is not specified, or filled to length n by pad:\n    ```python\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition(2).collect()\n    Seq((1, 2), (3, 4), (5, None))\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.partition(n, self._inner, pad=pad))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.partition_all","level":2,"title":"<code>partition_all(n)</code>","text":"<p>Partition all elements of sequence into tuples of length at most n.</p> <p>The final tuple may be shorter to accommodate extra elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Maximum length of each partition.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of partitioned tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition_all(2).collect()\nSeq((1, 2), (3, 4))\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition_all(2).collect()\nSeq((1, 2), (3, 4), (5,))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def partition_all(self, n: int) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Partition all elements of sequence into tuples of length at most n.\n\n    The final tuple may be shorter to accommodate extra elements.\n\n    Args:\n        n (int): Maximum length of each partition.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).partition_all(2).collect()\n    Seq((1, 2), (3, 4))\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).partition_all(2).collect()\n    Seq((1, 2), (3, 4), (5,))\n\n    ```\n    \"\"\"\n    return Iter(cz.itertoolz.partition_all(n, self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.partition_by","level":2,"title":"<code>partition_by(predicate)</code>","text":"<p>Partition the <code>Iterator</code> into a sequence of <code>tuples</code> according to a predicate function.</p> <p>Every time the output of <code>predicate</code> changes, a new <code>tuple</code> is started, and subsequent items are collected into that <code>tuple</code>.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine partition boundaries.</p> required <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of partitioned tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"I have space\").partition_by(lambda c: c == \" \").collect()\nSeq(('I',), (' ',), ('h', 'a', 'v', 'e'), (' ',), ('s', 'p', 'a', 'c', 'e'))\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = [1, 2, 1, 99, 88, 33, 99, -1, 5]\n&gt;&gt;&gt; pc.Iter(data).partition_by(lambda x: x &gt; 10).collect()\nSeq((1, 2, 1), (99, 88, 33, 99), (-1, 5))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def partition_by(self, predicate: Callable[[T], bool]) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Partition the `Iterator` into a sequence of `tuples` according to a predicate function.\n\n    Every time the output of `predicate` changes, a new `tuple` is started,\n    and subsequent items are collected into that `tuple`.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine partition boundaries.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of partitioned tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"I have space\").partition_by(lambda c: c == \" \").collect()\n    Seq(('I',), (' ',), ('h', 'a', 'v', 'e'), (' ',), ('s', 'p', 'a', 'c', 'e'))\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = [1, 2, 1, 99, 88, 33, 99, -1, 5]\n    &gt;&gt;&gt; pc.Iter(data).partition_by(lambda x: x &gt; 10).collect()\n    Seq((1, 2, 1), (99, 88, 33, 99), (-1, 5))\n\n    ```\n    \"\"\"\n    return Iter(cz.recipes.partitionby(predicate, self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.peekable","level":2,"title":"<code>peekable(n)</code>","text":"<p>Retrieve the next n elements from the <code>Iterator</code>, and return a <code>Seq</code> of the retrieved elements along with the original <code>Iterator</code>, unconsumed.</p> <p>The returned <code>Peekable</code> object contains two attributes: - peek: A <code>Seq</code> of the next n elements. - values: An <code>Iter</code> that includes the peeked elements followed by the remaining elements of the original <code>Iterator</code>.</p> <p><code>Peekable</code> implement <code>Checkable</code> on the peek attribute.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of items to peek.</p> required <p>Returns:</p> Type Description <code>Peekable[T]</code> <p>Peekable[T]: A <code>Peekable</code> object containing the peeked elements and the remaining iterator.</p> See Also <p><code>Iter.cloned()</code> to create an independent copy of the iterator.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Iter([1, 2, 3]).peekable(2)\n&gt;&gt;&gt; data.peek\nSeq(1, 2)\n&gt;&gt;&gt; data.values.collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def peekable(self, n: int) -&gt; Peekable[T]:\n    \"\"\"Retrieve the next **n** elements from the `Iterator`, and return a `Seq` of the retrieved elements along with the original `Iterator`, unconsumed.\n\n    The returned `Peekable` object contains two attributes:\n    - *peek*: A `Seq` of the next **n** elements.\n    - *values*: An `Iter` that includes the peeked elements followed by the remaining elements of the original `Iterator`.\n\n    `Peekable` implement `Checkable` on the *peek* attribute.\n\n    Args:\n        n (int): Number of items to peek.\n\n    Returns:\n        Peekable[T]: A `Peekable` object containing the peeked elements and the remaining iterator.\n\n    See Also:\n        `Iter.cloned()` to create an independent copy of the iterator.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Iter([1, 2, 3]).peekable(2)\n    &gt;&gt;&gt; data.peek\n    Seq(1, 2)\n    &gt;&gt;&gt; data.values.collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    peeked = Seq(itertools.islice(self._inner, n))\n    return Peekable(peeked, Iter(itertools.chain(peeked, self._inner)))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.permutations","level":2,"title":"<code>permutations(r=None)</code>","text":"<pre><code>permutations(r: Literal[2]) -&gt; Iter[tuple[T, T]]\n</code></pre><pre><code>permutations(r: Literal[3]) -&gt; Iter[tuple[T, T, T]]\n</code></pre><pre><code>permutations(r: Literal[4]) -&gt; Iter[tuple[T, T, T, T]]\n</code></pre><pre><code>permutations(r: Literal[5]) -&gt; Iter[tuple[T, T, T, T, T]]\n</code></pre> <p>Return all permutations of length r.</p> <p>Parameters:</p> Name Type Description Default <code>r</code> <code>int | None</code> <p>Length of each permutation. Defaults to the length of the iterable.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[tuple[T, ...]]</code> <p>Iter[tuple[T, ...]]: An iterable of permutations.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).permutations(2).collect()\nSeq((1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def permutations(self, r: int | None = None) -&gt; Iter[tuple[T, ...]]:\n    \"\"\"Return all permutations of length r.\n\n    Args:\n        r (int | None): Length of each permutation. Defaults to the length of the iterable.\n\n    Returns:\n        Iter[tuple[T, ...]]: An iterable of permutations.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).permutations(2).collect()\n    Seq((1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2))\n\n    ```\n    \"\"\"\n    return Iter(itertools.permutations(self._inner, r))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.product","level":2,"title":"<code>product(*others)</code>","text":"<pre><code>product() -&gt; Iter[tuple[T]]\n</code></pre><pre><code>product(iter1: Iterable[T1]) -&gt; Iter[tuple[T, T1]]\n</code></pre><pre><code>product(\n    iter1: Iterable[T1], iter2: Iterable[T2]\n) -&gt; Iter[tuple[T, T1, T2]]\n</code></pre><pre><code>product(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n) -&gt; Iter[tuple[T, T1, T2, T3]]\n</code></pre><pre><code>product(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n) -&gt; Iter[tuple[T, T1, T2, T3, T4]]\n</code></pre> <p>Computes the Cartesian product with another iterable.</p> <p>This is the declarative equivalent of nested for-loops.</p> <p>It pairs every element from the source iterable with every element from the other iterable.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to compute the Cartesian product with.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[tuple[Any, ...]]</code> <p>Iter[tuple[Any, ...]]: An iterable of tuples containing elements from the Cartesian product.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).product([\"S\", \"M\"]).collect()\nSeq(('blue', 'S'), ('blue', 'M'), ('red', 'S'), ('red', 'M'))\n&gt;&gt;&gt; res = (\n...     pc.Iter([\"blue\", \"red\"])\n...     .product([\"S\", \"M\"])\n...     .map_star(lambda color, size: f\"{color}-{size}\")\n...     .collect()\n... )\n&gt;&gt;&gt; res\nSeq('blue-S', 'blue-M', 'red-S', 'red-M')\n&gt;&gt;&gt; res = (\n...     pc.Iter([1, 2, 3])\n...     .product([10, 20])\n...     .filter_star(lambda a, b: a * b &gt;= 40)\n...     .map_star(lambda a, b: a * b)\n...     .collect()\n... )\n&gt;&gt;&gt; res\nSeq(40, 60)\n&gt;&gt;&gt; res = (\n...     pc.Iter([1])\n...     .product([\"a\", \"b\"], [True])\n...     .filter_star(lambda _a, b, _c: b != \"a\")\n...     .map_star(lambda a, b, c: f\"{a}{b} is {c}\")\n...     .collect()\n... )\n&gt;&gt;&gt; res\nSeq('1b is True',)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def product(self, *others: Iterable[Any]) -&gt; Iter[tuple[Any, ...]]:\n    \"\"\"Computes the Cartesian product with another iterable.\n\n    This is the declarative equivalent of nested for-loops.\n\n    It pairs every element from the source iterable with every element from the\n    other iterable.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to compute the Cartesian product with.\n\n    Returns:\n        Iter[tuple[Any, ...]]: An iterable of tuples containing elements from the Cartesian product.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([\"blue\", \"red\"]).product([\"S\", \"M\"]).collect()\n    Seq(('blue', 'S'), ('blue', 'M'), ('red', 'S'), ('red', 'M'))\n    &gt;&gt;&gt; res = (\n    ...     pc.Iter([\"blue\", \"red\"])\n    ...     .product([\"S\", \"M\"])\n    ...     .map_star(lambda color, size: f\"{color}-{size}\")\n    ...     .collect()\n    ... )\n    &gt;&gt;&gt; res\n    Seq('blue-S', 'blue-M', 'red-S', 'red-M')\n    &gt;&gt;&gt; res = (\n    ...     pc.Iter([1, 2, 3])\n    ...     .product([10, 20])\n    ...     .filter_star(lambda a, b: a * b &gt;= 40)\n    ...     .map_star(lambda a, b: a * b)\n    ...     .collect()\n    ... )\n    &gt;&gt;&gt; res\n    Seq(40, 60)\n    &gt;&gt;&gt; res = (\n    ...     pc.Iter([1])\n    ...     .product([\"a\", \"b\"], [True])\n    ...     .filter_star(lambda _a, b, _c: b != \"a\")\n    ...     .map_star(lambda a, b, c: f\"{a}{b} is {c}\")\n    ...     .collect()\n    ... )\n    &gt;&gt;&gt; res\n    Seq('1b is True',)\n\n    ```\n    \"\"\"\n    return Iter(itertools.product(self._inner, *others))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.repeat","level":2,"title":"<code>repeat(n=None)</code>","text":"<p>Repeat the entire <code>Iter</code> n times (as elements).</p> <p>If n is <code>None</code>, repeat indefinitely.</p> <p>Operates lazily, hence if you need to get the underlying elements, you will need to collect each repeated <code>Iter</code> via <code>.map(lambda x: x.collect())</code> or similar.</p> Warning <p>If n is <code>None</code>, this will create an infinite <code>Iterator</code>.</p> <p>Be sure to use <code>Iter.take()</code> or <code>Iter.slice()</code> to limit the number of items taken.</p> See Also <p><code>Iter.cycle()</code> to repeat the elements of the <code>Iter</code> indefinitely.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Optional number of repetitions.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An <code>Iter</code> of repeated <code>Iter</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).repeat(3).map(list).collect()\nSeq([1, 2], [1, 2], [1, 2])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def repeat(self, n: int | None = None) -&gt; Iter[Self]:\n    \"\"\"Repeat the entire `Iter` **n** times (as elements).\n\n    If **n** is `None`, repeat indefinitely.\n\n    Operates lazily, hence if you need to get the underlying elements, you will need to collect each repeated `Iter` via `.map(lambda x: x.collect())` or similar.\n\n    Warning:\n        If **n** is `None`, this will create an infinite `Iterator`.\n\n        Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n    See Also:\n        `Iter.cycle()` to repeat the *elements* of the `Iter` indefinitely.\n\n    Args:\n        n (int | None): Optional number of repetitions.\n\n    Returns:\n        Iter[Self]: An `Iter` of repeated `Iter`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).repeat(3).map(list).collect()\n    Seq([1, 2], [1, 2], [1, 2])\n\n    ```\n    \"\"\"\n    new = self.__class__\n\n    def _repeat_infinite() -&gt; Generator[Self]:\n        tee = functools.partial(itertools.tee, self._inner, 1)\n        iterators = tee()\n        while True:\n            yield new(iterators[0])\n            iterators = tee()\n\n    if n is None:\n        return Iter(_repeat_infinite())\n    return Iter(map(new, itertools.tee(self._inner, n)))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.scan","level":2,"title":"<code>scan(initial, func)</code>","text":"<p>Transform elements by sharing state between iterations.</p> <p><code>scan</code> takes two arguments:     - an initial value which seeds the internal state     - a func with two arguments</p> <p>The first being a reference to the internal state and the second an iterator element.</p> <p>The func can assign to the internal state to share state between iterations.</p> <p>On iteration, the func will be applied to each element of the iterator and the return value from the func, an Option, is returned by the next method.</p> <p>Thus the func can return <code>Some(value)</code> to yield value, or <code>NONE</code> to end the iteration.</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>U</code> <p>Initial state.</p> required <code>func</code> <code>Callable[[U, T], Option[U]]</code> <p>Function that takes the current state and an item, and returns an Option.</p> required <p>Returns:</p> Type Description <code>Iter[U]</code> <p>Iter[U]: An iterable of the yielded values.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def accumulate_until_limit(state: int, item: int) -&gt; pc.Option[int]:\n...     new_state = state + item\n...     match new_state:\n...         case _ if new_state &lt;= 10:\n...             return pc.Some(new_state)\n...         case _:\n...             return pc.NONE\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).scan(0, accumulate_until_limit).collect()\nSeq(1, 3, 6, 10)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def scan[U](self, initial: U, func: Callable[[U, T], Option[U]]) -&gt; Iter[U]:\n    \"\"\"Transform elements by sharing state between iterations.\n\n    `scan` takes two arguments:\n        - an **initial** value which seeds the internal state\n        - a **func** with two arguments\n\n    The first being a reference to the internal state and the second an iterator element.\n\n    The **func** can assign to the internal state to share state between iterations.\n\n    On iteration, the **func** will be applied to each element of the iterator and the return value from the func, an Option, is returned by the next method.\n\n    Thus the **func** can return `Some(value)` to yield value, or `NONE` to end the iteration.\n\n    Args:\n        initial (U): Initial state.\n        func (Callable[[U, T], Option[U]]): Function that takes the current state and an item, and returns an Option.\n\n    Returns:\n        Iter[U]: An iterable of the yielded values.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def accumulate_until_limit(state: int, item: int) -&gt; pc.Option[int]:\n    ...     new_state = state + item\n    ...     match new_state:\n    ...         case _ if new_state &lt;= 10:\n    ...             return pc.Some(new_state)\n    ...         case _:\n    ...             return pc.NONE\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).scan(0, accumulate_until_limit).collect()\n    Seq(1, 3, 6, 10)\n\n    ```\n    \"\"\"\n\n    def _gen(data: Iterable[T]) -&gt; Iterator[U]:\n        current: U = initial\n        for item in data:\n            res = func(current, item)\n            if res.is_none():\n                break\n            current = res.unwrap()\n            yield res.unwrap()\n\n    return Iter(_gen(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.sort","level":2,"title":"<code>sort(*, key=None, reverse=False)</code>","text":"<pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Vec[U]\n</code></pre><pre><code>sort(\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]],\n    reverse: bool = False,\n) -&gt; Vec[T]\n</code></pre><pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Never\n</code></pre> <p>Sort the elements of the sequence.</p> <p>If a key function is provided, it is used to extract a comparison key from each element.</p> Note <p>This method must consume the entire <code>Iter</code> to perform the sort. The result is a new <code>Vec</code> over the sorted sequence.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsRichComparison[Any]] | None</code> <p>Function to extract a comparison key from each element.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>Whether to sort in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>Vec[Any]</code> <p>Vec[Any]: A <code>Vec</code> with elements sorted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([3, 1, 2]).sort()\nVec(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sort(\n    self,\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n    reverse: bool = False,\n) -&gt; Vec[Any]:\n    \"\"\"Sort the elements of the sequence.\n\n    If a key function is provided, it is used to extract a comparison key from each element.\n\n    Note:\n        This method must consume the entire `Iter` to perform the sort.\n        The result is a new `Vec` over the sorted sequence.\n\n    Args:\n        key (Callable[[T], SupportsRichComparison[Any]] | None): Function to extract a comparison key from each element.\n        reverse (bool): Whether to sort in descending order.\n\n    Returns:\n        Vec[Any]: A `Vec` with elements sorted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([3, 1, 2]).sort()\n    Vec(1, 2, 3)\n\n    ```\n    \"\"\"\n    return Vec.from_ref(sorted(self._inner, reverse=reverse, key=key))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_after","level":2,"title":"<code>split_after(predicate, max_split=-1)</code>","text":"<p>Yield iterator of items from iterable, where each iterator ends with an item where <code>predicate</code> returns True.</p> <p>By default, no limit is placed on the number of splits.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine the split points.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An iterable of lists of items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"one1two2\").split_after(str.isdigit).map(list).collect()\nSeq(['o', 'n', 'e', '1'], ['t', 'w', 'o', '2'])\n\n&gt;&gt;&gt; def cond(n: int) -&gt; bool:\n...     return n % 3 == 0\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(range(10)).split_after(cond).map(list).collect()\nSeq([0], [1, 2, 3], [4, 5, 6], [7, 8, 9])\n&gt;&gt;&gt; pc.Iter(range(10)).split_after(cond, max_split=2).map(list).collect()\nSeq([0], [1, 2, 3], [4, 5, 6, 7, 8, 9])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_after(\n    self,\n    predicate: Callable[[T], bool],\n    max_split: int = -1,\n) -&gt; Iter[Self]:\n    \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n    By default, no limit is placed on the number of splits.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine the split points.\n        max_split (int): Maximum number of splits to perform.\n\n    Returns:\n        Iter[Self]: An iterable of lists of items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"one1two2\").split_after(str.isdigit).map(list).collect()\n    Seq(['o', 'n', 'e', '1'], ['t', 'w', 'o', '2'])\n\n    &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n    ...     return n % 3 == 0\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond).map(list).collect()\n    Seq([0], [1, 2, 3], [4, 5, 6], [7, 8, 9])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_after(cond, max_split=2).map(list).collect()\n    Seq([0], [1, 2, 3], [4, 5, 6, 7, 8, 9])\n\n    ```\n    \"\"\"\n\n    def _split_after(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n        \"\"\"Credits: more_itertools.split_after.\"\"\"\n        new = self.__class__\n        if max_split == 0:\n            yield new(data)\n            return\n\n        buf: list[T] = []\n        for item in data:\n            buf.append(item)\n            if predicate(item) and buf:\n                yield new(buf)\n                if max_split == 1:\n                    buf = list(data)\n                    if buf:\n                        yield new(buf)\n                    return\n                buf = []\n                max_split -= 1\n        if buf:\n            yield new(buf)\n\n    return Iter(_split_after(self._inner, max_split))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_at","level":2,"title":"<code>split_at(predicate, max_split=-1, *, keep_separator=False)</code>","text":"<p>Yield iterators of items from iterable, where each iterator is delimited by an item where <code>predicate</code> returns True.</p> <p>By default, no limit is placed on the number of splits.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine the split points.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform.</p> <code>-1</code> <code>keep_separator</code> <code>bool</code> <p>Whether to include the separator in the output.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An iterator of iterators, each containing a segment of the original iterable.</p> <p>By default, the delimiting items are not included in the output.</p> <p>To include them, set keep_separator to <code>True</code>. At most max_split splits are done.</p> <p>If max_split is not specified or -1, then there is no limit on the number of splits.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _to_res(x: pc.Iter[pc.Iter[str]]) -&gt; pc.Seq[pc.Seq[str]]:\n...     return x.map(lambda x: x.into(list)).collect()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(lambda x: x == \"b\").into(_to_res)\nSeq(['a'], ['c', 'd', 'c'], ['a'])\n&gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1).into(_to_res)\nSeq([0], [2], [4], [6], [8], [])\n&gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1, max_split=2).into(_to_res)\nSeq([0], [2], [4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt;\n&gt;&gt;&gt; def cond(x: str) -&gt; bool:\n...     return x == \"b\"\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(cond, keep_separator=True).into(_to_res)\nSeq(['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a'])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_at(\n    self,\n    predicate: Callable[[T], bool],\n    max_split: int = -1,\n    *,\n    keep_separator: bool = False,\n) -&gt; Iter[Self]:\n    \"\"\"Yield iterators of items from iterable, where each iterator is delimited by an item where `predicate` returns True.\n\n    By default, no limit is placed on the number of splits.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine the split points.\n        max_split (int): Maximum number of splits to perform.\n        keep_separator (bool): Whether to include the separator in the output.\n\n    Returns:\n        Iter[Self]: An iterator of iterators, each containing a segment of the original iterable.\n\n    By default, the delimiting items are not included in the output.\n\n    To include them, set *keep_separator* to `True`.\n    At most *max_split* splits are done.\n\n    If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _to_res(x: pc.Iter[pc.Iter[str]]) -&gt; pc.Seq[pc.Seq[str]]:\n    ...     return x.map(lambda x: x.into(list)).collect()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(lambda x: x == \"b\").into(_to_res)\n    Seq(['a'], ['c', 'd', 'c'], ['a'])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1).into(_to_res)\n    Seq([0], [2], [4], [6], [8], [])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_at(lambda n: n % 2 == 1, max_split=2).into(_to_res)\n    Seq([0], [2], [4, 5, 6, 7, 8, 9])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def cond(x: str) -&gt; bool:\n    ...     return x == \"b\"\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_at(cond, keep_separator=True).into(_to_res)\n    Seq(['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a'])\n\n    ```\n    \"\"\"\n\n    def _split_at(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n        \"\"\"Credits: more_itertools.split_at.\"\"\"\n        new = self.__class__\n        if max_split == 0:\n            yield self\n            return\n\n        buf: list[T] = []\n        for item in data:\n            if predicate(item):\n                yield new(buf)\n                if keep_separator:\n                    yield new((item,))\n                if max_split == 1:\n                    yield new(data)\n                    return\n                buf = []\n                max_split -= 1\n            else:\n                buf.append(item)\n        yield new(buf)\n\n    return Iter(_split_at(self._inner, max_split))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_before","level":2,"title":"<code>split_before(predicate, max_split=-1)</code>","text":"<p>Yield iterator of items from iterable, where each iterator ends with an item where <code>predicate</code> returns True.</p> <p>By default, no limit is placed on the number of splits.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to determine the split points.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An iterable of lists of items.</p> <p>At most max_split are done.</p> <p>If max_split is not specified or -1, then there is no limit on the number of splits:</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"abcdcba\").split_before(lambda x: x == \"b\").map(list).collect()\nSeq(['a'], ['b', 'c', 'd', 'c'], ['b', 'a'])\n&gt;&gt;&gt;\n&gt;&gt;&gt; def cond(n: int) -&gt; bool:\n...     return n % 2 == 1\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(range(10)).split_before(cond).map(list).collect()\nSeq([0], [1, 2], [3, 4], [5, 6], [7, 8], [9])\n&gt;&gt;&gt; pc.Iter(range(10)).split_before(cond, max_split=2).map(list).collect()\nSeq([0], [1, 2], [3, 4, 5, 6, 7, 8, 9])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_before(\n    self,\n    predicate: Callable[[T], bool],\n    max_split: int = -1,\n) -&gt; Iter[Self]:\n    \"\"\"Yield iterator of items from iterable, where each iterator ends with an item where `predicate` returns True.\n\n    By default, no limit is placed on the number of splits.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to determine the split points.\n        max_split (int): Maximum number of splits to perform.\n\n    Returns:\n        Iter[Self]: An iterable of lists of items.\n\n\n    At most *max_split* are done.\n\n\n    If *max_split* is not specified or -1, then there is no limit on the number of splits:\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"abcdcba\").split_before(lambda x: x == \"b\").map(list).collect()\n    Seq(['a'], ['b', 'c', 'd', 'c'], ['b', 'a'])\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def cond(n: int) -&gt; bool:\n    ...     return n % 2 == 1\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond).map(list).collect()\n    Seq([0], [1, 2], [3, 4], [5, 6], [7, 8], [9])\n    &gt;&gt;&gt; pc.Iter(range(10)).split_before(cond, max_split=2).map(list).collect()\n    Seq([0], [1, 2], [3, 4, 5, 6, 7, 8, 9])\n\n    ```\n    \"\"\"\n\n    def _split_before(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n        \"\"\"Credits: more_itertools.split_before.\"\"\"\n        new = self.__class__\n\n        if max_split == 0:\n            yield new(data)\n            return\n\n        buf: list[T] = []\n        for item in data:\n            if predicate(item) and buf:\n                yield new(buf)\n                if max_split == 1:\n                    yield new([item, *data])\n                    return\n                buf = []\n                max_split -= 1\n            buf.append(item)\n        if buf:\n            yield new(buf)\n\n    return Iter(_split_before(self._inner, max_split))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_into","level":2,"title":"<code>split_into(*sizes)</code>","text":"<p>Yield a list of sequential items from iterable of length 'n' for each integer 'n' in sizes.</p> <p>Parameters:</p> Name Type Description Default <code>*sizes</code> <code>Option[int]</code> <p><code>Some</code> integers specifying the sizes of each chunk. Use <code>NONE</code> for the remainder.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An iterator of iterators, each containing a chunk of the original iterable.</p> <p>If the sum of sizes is smaller than the length of iterable, then the remaining items of iterable will not be returned.</p> <p>If the sum of sizes is larger than the length of iterable:</p> <ul> <li>fewer items will be returned in the iteration that overruns the iterable</li> <li>further lists will be empty</li> </ul> <p>When a <code>NONE</code> object is encountered in sizes, the returned list will contain items up to the end of iterable the same way that itertools.slice does.</p> <p>split_into can be useful for grouping a series of items where the sizes of the groups are not uniform.</p> <p>An example would be where in a row from a table:</p> <ul> <li>multiple columns represent elements of the same feature (e.g. a point represented by x,y,z)</li> <li>the format is not the same for all columns.</li> </ul> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def _get_results(x: pc.Iter[pc.Iter[int]]) -&gt; pc.Seq[pc.Seq[int]]:\n...    return x.map(lambda x: x.collect()).collect()\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(1), pc.Some(2), pc.Some(3)).into(_get_results)\nSeq(Seq(1,), Seq(2, 3), Seq(4, 5, 6))\n&gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3)).into(_get_results)\nSeq(Seq(1, 2), Seq(3, 4, 5))\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).split_into(pc.Some(1), pc.Some(2), pc.Some(3), pc.Some(4)).into(_get_results)\nSeq(Seq(1,), Seq(2, 3), Seq(4,), Seq())\n&gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n&gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3), pc.NONE).into(_get_results)\nSeq(Seq(1, 2), Seq(3, 4, 5), Seq(6, 7, 8, 9, 0))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_into(self, *sizes: Option[int]) -&gt; Iter[Self]:\n    \"\"\"Yield a list of sequential items from iterable of length 'n' for each integer 'n' in sizes.\n\n    Args:\n        *sizes (Option[int]): `Some` integers specifying the sizes of each chunk. Use `NONE` for the remainder.\n\n    Returns:\n        Iter[Self]: An iterator of iterators, each containing a chunk of the original iterable.\n\n    If the sum of sizes is smaller than the length of iterable, then the remaining items of iterable will not be returned.\n\n    If the sum of sizes is larger than the length of iterable:\n\n    - fewer items will be returned in the iteration that overruns the iterable\n    - further lists will be empty\n\n    When a `NONE` object is encountered in sizes, the returned list will contain items up to the end of iterable the same way that itertools.slice does.\n\n    split_into can be useful for grouping a series of items where the sizes of the groups are not uniform.\n\n    An example would be where in a row from a table:\n\n    - multiple columns represent elements of the same feature (e.g. a point represented by x,y,z)\n    - the format is not the same for all columns.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def _get_results(x: pc.Iter[pc.Iter[int]]) -&gt; pc.Seq[pc.Seq[int]]:\n    ...    return x.map(lambda x: x.collect()).collect()\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6]\n    &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(1), pc.Some(2), pc.Some(3)).into(_get_results)\n    Seq(Seq(1,), Seq(2, 3), Seq(4, 5, 6))\n    &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3)).into(_get_results)\n    Seq(Seq(1, 2), Seq(3, 4, 5))\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).split_into(pc.Some(1), pc.Some(2), pc.Some(3), pc.Some(4)).into(_get_results)\n    Seq(Seq(1,), Seq(2, 3), Seq(4,), Seq())\n    &gt;&gt;&gt; data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n    &gt;&gt;&gt; pc.Iter(data).split_into(pc.Some(2), pc.Some(3), pc.NONE).into(_get_results)\n    Seq(Seq(1, 2), Seq(3, 4, 5), Seq(6, 7, 8, 9, 0))\n\n    ```\n    \"\"\"\n\n    def _split_into(data: Iterator[T]) -&gt; Iterator[Self]:\n        \"\"\"Credits: more_itertools.split_into.\"\"\"\n        new = self.__class__\n        for size in sizes:\n            if size.is_none():\n                yield new(data)\n                return\n            else:\n                yield new(itertools.islice(data, size.unwrap()))\n\n    return Iter(_split_into(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.split_when","level":2,"title":"<code>split_when(predicate, max_split=-1)</code>","text":"<p>Split iterable into pieces based on the output of a predicate function.</p> <p>By default, no limit is placed on the number of splits.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T, T], bool]</code> <p>Function that takes successive pairs of items and returns True if the iterable should be split.</p> required <code>max_split</code> <code>int</code> <p>Maximum number of splits to perform.</p> <code>-1</code> <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An iterator of iterators of items.</p> <p>At most max_split splits are done.</p> <p>If max_split is not specified or -1, then there is no limit on the number of splits.</p> <p>The example below shows how to find runs of increasing numbers, by splitting the iterable when element i is larger than element i + 1.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Seq([1, 2, 3, 3, 2, 5, 2, 4, 2])\n&gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y).map(lambda x: x.collect()).collect()\nSeq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4), Seq(2,))\n&gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y, max_split=2).map(lambda x: x.collect()).collect()\nSeq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4, 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def split_when(\n    self,\n    predicate: Callable[[T, T], bool],\n    max_split: int = -1,\n) -&gt; Iter[Self]:\n    \"\"\"Split iterable into pieces based on the output of a predicate function.\n\n    By default, no limit is placed on the number of splits.\n\n    Args:\n        predicate (Callable[[T, T], bool]): Function that takes successive pairs of items and returns True if the iterable should be split.\n        max_split (int): Maximum number of splits to perform.\n\n    Returns:\n        Iter[Self]: An iterator of iterators of items.\n\n    At most *max_split* splits are done.\n\n    If *max_split* is not specified or -1, then there is no limit on the number of splits.\n\n    The example below shows how to find runs of increasing numbers, by splitting the iterable when element i is larger than element i + 1.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Seq([1, 2, 3, 3, 2, 5, 2, 4, 2])\n    &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y).map(lambda x: x.collect()).collect()\n    Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4), Seq(2,))\n    &gt;&gt;&gt; data.iter().split_when(lambda x, y: x &gt; y, max_split=2).map(lambda x: x.collect()).collect()\n    Seq(Seq(1, 2, 3, 3), Seq(2, 5), Seq(2, 4, 2))\n\n    ```\n    \"\"\"\n\n    def _split_when(data: Iterator[T], max_split: int) -&gt; Iterator[Self]:\n        \"\"\"Credits: more_itertools.split_when.\"\"\"\n        new = self.__class__\n        if max_split == 0:\n            yield self\n            return\n        try:\n            cur_item = next(data)\n        except StopIteration:\n            return\n\n        buf = [cur_item]\n        for next_item in data:\n            if predicate(cur_item, next_item):\n                yield new(buf)\n                if max_split == 1:\n                    yield new((next_item, *data))\n                    return\n                buf = []\n                max_split -= 1\n\n            buf.append(next_item)\n            cur_item = next_item\n\n        yield new(buf)\n\n    return Iter(_split_when(self._inner, max_split))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.successors","level":2,"title":"<code>successors(first, succ)</code>  <code>staticmethod</code>","text":"<p>Create an iterator of successive values computed from the previous one.</p> <p>The iterator yields <code>first</code> (if it is <code>Some</code>), then repeatedly applies succ to the previous yielded value until it returns <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>first</code> <code>Option[U]</code> <p>Initial item.</p> required <code>succ</code> <code>Callable[[U], Option[U]]</code> <p>Successor function.</p> required <p>Returns:</p> Type Description <code>Iter[U]</code> <p>Iter[U]: Iterator yielding <code>first</code> and its successors.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def next_pow10(x: int) -&gt; pc.Option[int]:\n...     return pc.Some(x * 10) if x &lt; 10_000 else pc.NONE\n&gt;&gt;&gt; pc.Iter.successors(pc.Some(1), next_pow10).collect()\nSeq(1, 10, 100, 1000, 10000)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef successors[U](first: Option[U], succ: Callable[[U], Option[U]]) -&gt; Iter[U]:\n    \"\"\"Create an iterator of successive values computed from the previous one.\n\n    The iterator yields `first` (if it is `Some`), then repeatedly applies **succ** to the\n    previous yielded value until it returns `NONE`.\n\n    Args:\n        first (Option[U]): Initial item.\n        succ (Callable[[U], Option[U]]): Successor function.\n\n    Returns:\n        Iter[U]: Iterator yielding `first` and its successors.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def next_pow10(x: int) -&gt; pc.Option[int]:\n    ...     return pc.Some(x * 10) if x &lt; 10_000 else pc.NONE\n    &gt;&gt;&gt; pc.Iter.successors(pc.Some(1), next_pow10).collect()\n    Seq(1, 10, 100, 1000, 10000)\n\n    ```\n    \"\"\"\n\n    def _successors() -&gt; Iterator[U]:\n        current = first\n        while current.is_some():\n            value = current.unwrap()\n            yield value\n            current = succ(value)\n\n    return Iter(_successors())\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.tail","level":2,"title":"<code>tail(n)</code>","text":"<p>Return a <code>Seq</code> of the last n elements of the <code>Iterator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to return.</p> required <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A <code>Seq</code> containing the last n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).tail(2)\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def tail(self, n: int) -&gt; Seq[T]:\n    \"\"\"Return a `Seq` of the last **n** elements of the `Iterator`.\n\n    Args:\n        n (int): Number of elements to return.\n\n    Returns:\n        Seq[T]: A `Seq` containing the last **n** elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).tail(2)\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.tail(n, self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.top_n","level":2,"title":"<code>top_n(n, key=None)</code>","text":"<p>Return a tuple of the top-n items according to key.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of top elements to return.</p> required <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to extract a comparison key from each element.</p> <code>None</code> <p>Returns:</p> Type Description <code>Seq[T]</code> <p>Seq[T]: A new Seq containing the top-n elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 3, 2]).top_n(2)\nSeq(3, 2)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def top_n(self, n: int, key: Callable[[T], Any] | None = None) -&gt; Seq[T]:\n    \"\"\"Return a tuple of the top-n items according to key.\n\n    Args:\n        n (int): Number of top elements to return.\n        key (Callable[[T], Any] | None): Function to extract a comparison key from each element.\n\n    Returns:\n        Seq[T]: A new Seq containing the top-n elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 3, 2]).top_n(2)\n    Seq(3, 2)\n\n    ```\n    \"\"\"\n    return Seq(cz.itertoolz.topk(n, self._inner, key=key))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.try_collect","level":2,"title":"<code>try_collect()</code>","text":"<p>Fallibly transforms self into a <code>Vec</code>, short circuiting if a failure is encountered.</p> <p><code>try_collect()</code> is a variation of <code>collect()</code> that allows fallible conversions during collection.</p> <p>Its main use case is simplifying conversions from iterators yielding <code>Option[T]</code> or <code>Result[T, E]</code> into <code>Option[Vec[T]]</code>.</p> <p>Also, if a failure is encountered during <code>try_collect()</code>, the <code>Iter</code> is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure.</p> <p>See the last example below for an example of how this works.</p> Note <p>This method return <code>Vec[U]</code> instead of being customizable, because the underlying data structure must be mutable in order to build up the collection.</p> <p>Returns:</p> Type Description <code>Option[Vec[U]]</code> <p>Option[Vec[U]]: <code>Some[Vec[U]]</code> if all elements were successfully collected, or <code>NONE</code> if a failure was encountered.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Successfully collecting an iterator of Option[int] into Option[Vec[int]]:\n&gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.Some(3)]).try_collect()\nSome(Vec(1, 2, 3))\n&gt;&gt;&gt; # Failing to collect in the same way:\n&gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.NONE, pc.Some(3)]).try_collect()\nNONE\n&gt;&gt;&gt; # A similar example, but with Result:\n&gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Ok(2), pc.Ok(3)]).try_collect()\nSome(Vec(1, 2, 3))\n&gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Err(\"error\"), pc.Ok(3)]).try_collect()\nNONE\n&gt;&gt;&gt; def external_fn(x: int) -&gt; pc.Option[int]:\n...     if x % 2 == 0:\n...         return pc.Some(x)\n...     return pc.NONE\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map(external_fn).try_collect()\nNONE\n&gt;&gt;&gt; # Demonstrating that the iterator remains usable after a failure:\n&gt;&gt;&gt; it = pc.Iter([pc.Some(1), pc.NONE, pc.Some(3), pc.Some(4)])\n&gt;&gt;&gt; it.try_collect()\nNONE\n&gt;&gt;&gt; it.try_collect()\nSome(Vec(3, 4))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def try_collect[U](self: Iter[Option[U]] | Iter[Result[U, Any]]) -&gt; Option[Vec[U]]:\n    \"\"\"Fallibly transforms **self** into a `Vec`, short circuiting if a failure is encountered.\n\n    `try_collect()` is a variation of `collect()` that allows fallible conversions during collection.\n\n    Its main use case is simplifying conversions from iterators yielding `Option[T]` or `Result[T, E]` into `Option[Vec[T]]`.\n\n    Also, if a failure is encountered during `try_collect()`, the `Iter` is still valid and may continue to be used, in which case it will continue iterating starting after the element that triggered the failure.\n\n    See the last example below for an example of how this works.\n\n    Note:\n        This method return `Vec[U]` instead of being customizable, because the underlying data structure must be mutable in order to build up the collection.\n\n    Returns:\n        Option[Vec[U]]: `Some[Vec[U]]` if all elements were successfully collected, or `NONE` if a failure was encountered.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Successfully collecting an iterator of Option[int] into Option[Vec[int]]:\n    &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.Some(3)]).try_collect()\n    Some(Vec(1, 2, 3))\n    &gt;&gt;&gt; # Failing to collect in the same way:\n    &gt;&gt;&gt; pc.Iter([pc.Some(1), pc.Some(2), pc.NONE, pc.Some(3)]).try_collect()\n    NONE\n    &gt;&gt;&gt; # A similar example, but with Result:\n    &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Ok(2), pc.Ok(3)]).try_collect()\n    Some(Vec(1, 2, 3))\n    &gt;&gt;&gt; pc.Iter([pc.Ok(1), pc.Err(\"error\"), pc.Ok(3)]).try_collect()\n    NONE\n    &gt;&gt;&gt; def external_fn(x: int) -&gt; pc.Option[int]:\n    ...     if x % 2 == 0:\n    ...         return pc.Some(x)\n    ...     return pc.NONE\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4]).map(external_fn).try_collect()\n    NONE\n    &gt;&gt;&gt; # Demonstrating that the iterator remains usable after a failure:\n    &gt;&gt;&gt; it = pc.Iter([pc.Some(1), pc.NONE, pc.Some(3), pc.Some(4)])\n    &gt;&gt;&gt; it.try_collect()\n    NONE\n    &gt;&gt;&gt; it.try_collect()\n    Some(Vec(3, 4))\n\n    ```\n    \"\"\"\n    collected: list[U] = []\n    collected_add = collected.append\n    for item in self._inner:\n        match item:\n            case Ok(val) | Some(val):\n                collected_add(val)\n            case _:\n                return NONE\n    return Some(Vec.from_ref(collected))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.unique_to_each","level":2,"title":"<code>unique_to_each()</code>","text":"<p>Return the elements from each of the iterators that aren't in the other iterators.</p> <p>It is assumed that the elements of each iterable are hashable.</p> <p>Credits</p> <pre><code>more_itertools.unique_to_each\n</code></pre> <p>Returns:</p> Type Description <code>Iter[Iter[U]]</code> <p>Iter[Iter[U]]: An iterator of iterators, each containing the unique elements from the corresponding input iterable.</p> <p>For example, suppose you have a set of packages, each with a set of dependencies:</p> <p>{'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}</p> <p>If you remove one package, which dependencies can also be removed?</p> <p>If pkg_1 is removed, then A is no longer necessary - it is not associated with pkg_2 or pkg_3.</p> <p>Similarly, C is only needed for pkg_2, and D is only needed for pkg_3:</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = ({\"A\", \"B\"}, {\"B\", \"C\"}, {\"B\", \"D\"})\n&gt;&gt;&gt; pc.Iter(data).unique_to_each().map(lambda x: x.into(list)).collect()\nSeq(['A'], ['C'], ['D'])\n</code></pre> <p>If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output.</p> <p>Input order is preserved: <pre><code>&gt;&gt;&gt; data = (\"mississippi\", \"missouri\")\n&gt;&gt;&gt; pc.Seq(data).iter().unique_to_each().map(lambda x: x.into(list)).collect()\nSeq(['p', 'p'], ['o', 'u', 'r'])\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unique_to_each[U: Iterable[Any]](self: Iter[U]) -&gt; Iter[Iter[U]]:\n    \"\"\"Return the elements from each of the iterators that aren't in the other iterators.\n\n    It is assumed that the elements of each iterable are hashable.\n\n    **Credits**\n\n        more_itertools.unique_to_each\n\n    Returns:\n        Iter[Iter[U]]: An iterator of iterators, each containing the unique elements from the corresponding input iterable.\n\n    For example, suppose you have a set of packages, each with a set of dependencies:\n\n    **{'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}**\n\n    If you remove one package, which dependencies can also be removed?\n\n    If pkg_1 is removed, then A is no longer necessary - it is not associated with pkg_2 or pkg_3.\n\n    Similarly, C is only needed for pkg_2, and D is only needed for pkg_3:\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = ({\"A\", \"B\"}, {\"B\", \"C\"}, {\"B\", \"D\"})\n    &gt;&gt;&gt; pc.Iter(data).unique_to_each().map(lambda x: x.into(list)).collect()\n    Seq(['A'], ['C'], ['D'])\n\n    ```\n\n    If there are duplicates in one input iterable that aren't in the others they will be duplicated in the output.\n\n    Input order is preserved:\n    ```python\n    &gt;&gt;&gt; data = (\"mississippi\", \"missouri\")\n    &gt;&gt;&gt; pc.Seq(data).iter().unique_to_each().map(lambda x: x.into(list)).collect()\n    Seq(['p', 'p'], ['o', 'u', 'r'])\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    pool: tuple[Iterable[U], ...] = tuple(self._inner)\n    counts: Counter[U] = Counter(itertools.chain.from_iterable(map(set, pool)))\n    uniques: set[U] = {element for element in counts if counts[element] == 1}\n\n    return Iter((Iter(filter(uniques.__contains__, it))) for it in pool)\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.unzip","level":2,"title":"<code>unzip()</code>","text":"<p>Converts an iterator of pairs into a pair of iterators.</p> <p>Returns:</p> Type Description <code>Unzipped[U, V]</code> <p>Unzipped[U, V]: dataclass with first and second iterators.</p> <p>Returns an <code>Unzipped</code> dataclass, containing two iterators:</p> <ul> <li>one from the left elements of the pairs</li> <li>one from the right elements.</li> </ul> <p>This function is, in some sense, the opposite of <code>.zip()</code>.</p> Note <p>Both iterators share the same underlying source.</p> <p>Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.</p> <p>This is the unavoidable cost of having two independent iterators over the same source.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n&gt;&gt;&gt; unzipped = pc.Iter(data).unzip()\n&gt;&gt;&gt; unzipped.left.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; unzipped.right.collect()\nSeq('a', 'b', 'c')\n</code></pre> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def unzip[U, V](self: Iter[tuple[U, V]]) -&gt; Unzipped[U, V]:\n    \"\"\"Converts an iterator of pairs into a pair of iterators.\n\n    Returns:\n        Unzipped[U, V]: dataclass with first and second iterators.\n\n\n    Returns an `Unzipped` dataclass, containing two iterators:\n\n    - one from the left elements of the pairs\n    - one from the right elements.\n\n    This function is, in some sense, the opposite of `.zip()`.\n\n    Note:\n        Both iterators share the same underlying source.\n\n        Values consumed by one iterator remain in the shared buffer until the other iterator consumes them too.\n\n        This is the unavoidable cost of having two independent iterators over the same source.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [(1, \"a\"), (2, \"b\"), (3, \"c\")]\n    &gt;&gt;&gt; unzipped = pc.Iter(data).unzip()\n    &gt;&gt;&gt; unzipped.left.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; unzipped.right.collect()\n    Seq('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    left, right = itertools.tee(self._inner, 2)\n    return Unzipped(Iter(x[0] for x in left), Iter(x[1] for x in right))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.with_position","level":2,"title":"<code>with_position()</code>","text":"<p>Return an iterable over (<code>Position</code>, <code>T</code>) tuples.</p> <p>The <code>Position</code> indicates whether the item <code>T</code> is the first, middle, last, or only element in the iterable.</p> <p>Returns:</p> Type Description <code>Iter[tuple[Position, T]]</code> <p>Iter[tuple[Position, T]]: An iterable of (<code>Position</code>, item) tuples.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).with_position().collect()\nSeq(('first', 'a'), ('middle', 'b'), ('last', 'c'))\n&gt;&gt;&gt; pc.Iter([\"a\"]).with_position().collect()\nSeq(('only', 'a'),)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def with_position(self) -&gt; Iter[tuple[Position, T]]:\n    \"\"\"Return an iterable over (`Position`, `T`) tuples.\n\n    The `Position` indicates whether the item `T` is the first, middle, last, or only element in the iterable.\n\n    Returns:\n        Iter[tuple[Position, T]]: An iterable of (`Position`, item) tuples.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\", \"c\"]).with_position().collect()\n    Seq(('first', 'a'), ('middle', 'b'), ('last', 'c'))\n    &gt;&gt;&gt; pc.Iter([\"a\"]).with_position().collect()\n    Seq(('only', 'a'),)\n\n    ```\n    \"\"\"\n\n    def _gen(data: Iterator[T]) -&gt; Iterator[tuple[Position, T]]:\n        try:\n            first = next(data)\n        except StopIteration:\n            return\n\n        try:\n            second = next(data)\n        except StopIteration:\n            yield (\"only\", first)\n            return\n        yield (\"first\", first)\n\n        current: T = second\n        for nxt in self._inner:\n            yield (\"middle\", current)\n            current = nxt\n        yield (\"last\", current)\n\n    return Iter(_gen(self._inner))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.zip","level":2,"title":"<code>zip(*others, strict=False)</code>","text":"<pre><code>zip(\n    iter1: Iterable[T1], /, *, strict: bool = ...\n) -&gt; Iter[tuple[T, T1]]\n</code></pre><pre><code>zip(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    /,\n    *,\n    strict: bool = ...,\n) -&gt; Iter[tuple[T, T1, T2]]\n</code></pre><pre><code>zip(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    /,\n    *,\n    strict: bool = ...,\n) -&gt; Iter[tuple[T, T1, T2, T3]]\n</code></pre><pre><code>zip(\n    iter1: Iterable[T1],\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n    /,\n    *,\n    strict: bool = ...,\n) -&gt; Iter[tuple[T, T1, T2, T3, T4]]\n</code></pre> <p>Yields n-length tuples, where n is the number of iterables passed as positional arguments.</p> <p>The i-th element in every tuple comes from the i-th iterable argument to <code>.zip()</code>.</p> <p>This continues until the shortest argument is exhausted.</p> Note <p><code>Iter.map_star</code> can then be used for subsequent operations on the index and value, in a destructuring manner. This keep the code clean and readable, without index access like <code>[0]</code> and <code>[1]</code> for inline lambdas.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to zip with.</p> <code>()</code> <code>strict</code> <code>bool</code> <p>If <code>True</code> and one of the arguments is exhausted before the others, raise a ValueError.</p> <code>False</code> <p>Returns:</p> Type Description <code>Iter[tuple[Any, ...]]</code> <p>Iter[tuple[Any, ...]]: An <code>Iter</code> of tuples containing elements from the zipped Iter and other iterables.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).zip([10, 20]).collect()\nSeq((1, 10), (2, 20))\n&gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).zip([1, 2, 3]).collect()\nSeq(('a', 1), ('b', 2))\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def zip(\n    self,\n    *others: Iterable[Any],\n    strict: bool = False,\n) -&gt; Iter[tuple[Any, ...]]:\n    \"\"\"Yields n-length tuples, where n is the number of iterables passed as positional arguments.\n\n    The i-th element in every tuple comes from the i-th iterable argument to `.zip()`.\n\n    This continues until the shortest argument is exhausted.\n\n    Note:\n        `Iter.map_star` can then be used for subsequent operations on the index and value, in a destructuring manner.\n        This keep the code clean and readable, without index access like `[0]` and `[1]` for inline lambdas.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to zip with.\n        strict (bool): If `True` and one of the arguments is exhausted before the others, raise a ValueError.\n\n    Returns:\n        Iter[tuple[Any, ...]]: An `Iter` of tuples containing elements from the zipped Iter and other iterables.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).zip([10, 20]).collect()\n    Seq((1, 10), (2, 20))\n    &gt;&gt;&gt; pc.Iter([\"a\", \"b\"]).zip([1, 2, 3]).collect()\n    Seq(('a', 1), ('b', 2))\n\n    ```\n    \"\"\"\n    return Iter(zip(self._inner, *others, strict=strict))\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/iter/#pyochain._iter.Iter.zip_longest","level":2,"title":"<code>zip_longest(*others)</code>","text":"<pre><code>zip_longest(\n    iter2: Iterable[T2],\n) -&gt; Iter[tuple[Option[T], Option[T2]]]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T2], iter3: Iterable[T3]\n) -&gt; Iter[tuple[Option[T], Option[T2], Option[T3]]]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n) -&gt; Iter[\n    tuple[Option[T], Option[T2], Option[T3], Option[T4]]\n]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T2],\n    iter3: Iterable[T3],\n    iter4: Iterable[T4],\n    iter5: Iterable[T5],\n) -&gt; Iter[\n    tuple[\n        Option[T],\n        Option[T2],\n        Option[T3],\n        Option[T4],\n        Option[T5],\n    ]\n]\n</code></pre><pre><code>zip_longest(\n    iter2: Iterable[T],\n    iter3: Iterable[T],\n    iter4: Iterable[T],\n    iter5: Iterable[T],\n    iter6: Iterable[T],\n    /,\n    *iterables: Iterable[T],\n) -&gt; Iter[tuple[Option[T], ...]]\n</code></pre> <p>Return a zip Iterator who yield a tuple where the i-th element comes from the i-th iterable argument.</p> <p>Yield values until the longest iterable in the argument sequence is exhausted, and then it raises StopIteration.</p> <p>The longest iterable determines the length of the returned iterator, and will return <code>Some[T]</code> until exhaustion.</p> <p>When the shorter iterables are exhausted, they yield <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[Any]</code> <p>Other iterables to zip with.</p> <code>()</code> <p>Returns:</p> Type Description <code>Iter[tuple[Option[Any], ...]]</code> <p>Iter[tuple[Option[Any], ...]]: An iterable of tuples containing optional elements from the zipped iterables.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).collect()\nSeq((Some(1), Some(10)), (Some(2), NONE))\n&gt;&gt;&gt; # Can be combined with try collect to filter out the NONE:\n&gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).map(lambda x: pc.Iter(x).try_collect()).collect()\nSeq(Some(Vec(1, 10)), NONE)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def zip_longest(self, *others: Iterable[Any]) -&gt; Iter[tuple[Option[Any], ...]]:\n    \"\"\"Return a zip Iterator who yield a tuple where the i-th element comes from the i-th iterable argument.\n\n    Yield values until the longest iterable in the argument sequence is exhausted, and then it raises StopIteration.\n\n    The longest iterable determines the length of the returned iterator, and will return `Some[T]` until exhaustion.\n\n    When the shorter iterables are exhausted, they yield `NONE`.\n\n    Args:\n        *others (Iterable[Any]): Other iterables to zip with.\n\n    Returns:\n        Iter[tuple[Option[Any], ...]]: An iterable of tuples containing optional elements from the zipped iterables.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).collect()\n    Seq((Some(1), Some(10)), (Some(2), NONE))\n    &gt;&gt;&gt; # Can be combined with try collect to filter out the NONE:\n    &gt;&gt;&gt; pc.Iter([1, 2]).zip_longest([10]).map(lambda x: pc.Iter(x).try_collect()).collect()\n    Seq(Some(Vec(1, 10)), NONE)\n\n    ```\n    \"\"\"\n    return Iter(\n        tuple(Option(t) for t in tup)\n        for tup in itertools.zip_longest(self._inner, *others, fillvalue=None)\n    )\n</code></pre>","path":["API Reference","Iterators","Iter"],"tags":[]},{"location":"reference/noneoption/","level":1,"title":"NoneOption","text":"<p>               Bases: <code>Option[T]</code></p> <p>Option variant representing the absence of a value.</p> <p>This class is not supposed to be instanciated by the user. Instead, pyochain provide the <code>NONE</code> singleton (for performance reasons).</p> <p>For more documentation, see the <code>Option[T]</code> class.</p>","path":["API Reference","Optional Values","NoneOption"],"tags":[]},{"location":"reference/ok/","level":1,"title":"Ok","text":"<p>               Bases: <code>Result[T, E]</code></p> <p>Represents a successful value.</p> <p>For more documentation, see the <code>Result[T, E]</code> class.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>T</code> <p>The contained successful value.</p>","path":["API Reference","Error Handling","Ok"],"tags":[]},{"location":"reference/option/","level":1,"title":"Option","text":"<p>               Bases: <code>Pipeable</code></p> <p>Type <code>Option[T]</code> represents an optional value.</p> <p>Every Option is either:</p> <ul> <li><code>Some</code> and contains a value</li> <li><code>None</code>, and does not.</li> </ul> <p>This is a common type in Rust, and is used to represent values that may be absent.</p> <p>In python, this is best tought of a an union type <code>T | None</code>, but with additional methods to operate on the contained value in a functional style.</p> <p><code>Option[T]</code> and/or <code>T | None</code> types are very useful, as they have a number of uses:</p> <ul> <li>Initial values</li> <li>Union types</li> <li>Return value where None is returned on error</li> <li>Optional class fields</li> <li>Optional function arguments</li> </ul> <p>The fact that <code>T | None</code> is a very common pattern in python, but without a dedicated structure/handling, leads to:</p> <ul> <li>a lot of boilerplate code</li> <li>potential bugs (even with type checkers)</li> <li>less readable code (where does the None come from? is it expected?).</li> </ul> <p><code>Option[T]</code> instances are commonly paired with pattern matching. This allow to query the presence of a value and take action, always accounting for the None case.</p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.__bool__","level":2,"title":"<code>__bool__()</code>","text":"<p>Prevent implicit <code>Some|None</code> value checking in boolean contexts.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Always, to prevent implicit <code>Some|None</code> value checking.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x = pc.Some(42)\n&gt;&gt;&gt; bool(x)\nTraceback (most recent call last):\n...\nTypeError: Option instances cannot be used in boolean contexts for implicit `Some|None` value checking. Use is_some() or is_none() instead.\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.__eq__","level":2,"title":"<code>__eq__(other)</code>","text":"<p>Checks if this <code>Option</code> and other are equal.</p> <p>A plain Python <code>None</code> is considered equal to a <code>pyochain.NoneOption</code> instance.</p> <p>A plain value of type <code>T</code> is considered equal to a <code>pyochain.Some[T]</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>object</code> <p>The other object to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if both instances are equal, <code>False</code> otherwise.</p> See Also <ul> <li><code>Option.eq</code> for a type-safe, performant version that only accepts <code>Option[T]</code> instances.</li> </ul> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(42) == pc.Some(42)\nTrue\n&gt;&gt;&gt; pc.Some(42) == pc.Some(21)\nFalse\n&gt;&gt;&gt; pc.Some(42) == pc.NONE\nFalse\n&gt;&gt;&gt; pc.NONE == pc.NONE\nTrue\n&gt;&gt;&gt; pc.NONE == None\nTrue\n&gt;&gt;&gt; pc.Some(42) == 42\nTrue\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.__new__","level":2,"title":"<code>__new__(value)</code>","text":"<p>Creates an <code>Option[V]</code> from a value that may be <code>None</code>.</p> <p>When calling <code>Option(value)</code>, this method automatically redirects to: - <code>Some(value)</code> if the value is not <code>None</code> - <code>NONE</code> if the value is <code>None</code></p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V | None</code> <p>The value to convert into an <code>Option[V]</code>.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the value is not <code>None</code>, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option(42)\nSome(42)\n&gt;&gt;&gt; pc.Option(None)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.and_","level":2,"title":"<code>and_(optb)</code>","text":"<p>Returns <code>NONE</code> if the option is <code>NONE</code>, otherwise returns optb.</p> <p>This is similar to <code>and_then</code>, except that the value is passed directly instead of through a closure.</p> <p>Parameters:</p> Name Type Description Default <code>optb</code> <code>Option[U]</code> <p>The option to return if the original option is <code>NONE</code></p> required <p>Returns:     Option[U]: <code>NONE</code> if the original option is <code>NONE</code>, otherwise <code>optb</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).and_(pc.NONE)\nNONE\n&gt;&gt;&gt; pc.NONE.and_(pc.Some(\"foo\"))\nNONE\n&gt;&gt;&gt; pc.Some(2).and_(pc.Some(\"foo\"))\nSome('foo')\n&gt;&gt;&gt; pc.NONE.and_(pc.NONE)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.and_then","level":2,"title":"<code>and_then(f, *args, **kwargs)</code>","text":"<p>Calls a function if the option is <code>Some</code>, otherwise returns <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[Concatenate[T, P], Option[R]]</code> <p>The function to call with the <code>Some</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: The result of the function if <code>Some</code>, otherwise <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def sq(x: int) -&gt; Option[int]:\n...     return pc.Some(x * x)\n&gt;&gt;&gt; def nope(x: int) -&gt; Option[int]:\n...     return pc.NONE\n&gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(sq)\nSome(16)\n&gt;&gt;&gt; pc.Some(2).and_then(sq).and_then(nope)\nNONE\n&gt;&gt;&gt; pc.Some(2).and_then(nope).and_then(sq)\nNONE\n&gt;&gt;&gt; pc.NONE.and_then(sq).and_then(sq)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.and_then_star","level":2,"title":"<code>and_then_star(func)</code>","text":"<pre><code>and_then_star(\n    func: Callable[[Any], Option[R]],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2], Option[R]],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3], Option[R]],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3, T4], Option[R]],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3, T4, T5], Option[R]],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], Option[R]],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], Option[R]],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8], Option[R]\n    ],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9], Option[R]\n    ],\n) -&gt; Option[R]\n</code></pre><pre><code>and_then_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], Option[R]\n    ],\n) -&gt; Option[R]\n</code></pre> <p>Calls a function if the option is <code>Some</code>, unpacking the iterable into the function.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Option[R]]</code> <p>The function to call with the unpacked <code>Some</code> value.</p> required <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: The result of the function if <code>Some</code>, otherwise <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some((2, 3)).and_then_star(lambda x, y: pc.Some(x + y))\nSome(5)\n&gt;&gt;&gt; pc.NONE.and_then_star(lambda x, y: pc.Some(x + y))\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Checks if two <code>Option[T]</code> instances are equal.</p> Note <p>This method behave similarly to <code>__eq__</code>, but only accepts <code>Option[T]</code> instances as argument.</p> <p>This avoids runtime isinstance checks (we check for boolean <code>is_some()</code>, which is a simple function call), and is more type-safe.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[T]</code> <p>The other <code>Option[T]</code> instance to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if both instances are equal, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(42).eq(pc.Some(42))\nTrue\n&gt;&gt;&gt; pc.Some(42).eq(pc.Some(21))\nFalse\n&gt;&gt;&gt; pc.Some(42).eq(pc.NONE)\nFalse\n&gt;&gt;&gt; pc.NONE.eq(pc.NONE)\nTrue\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.expect","level":2,"title":"<code>expect(msg)</code>","text":"<p>Returns the contained <code>Some</code> value.</p> <p>Raises an exception with a provided message if the value is <code>None</code>.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to include in the exception if the result is <code>None</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value.</p> <p>Raises:</p> Type Description <code>OptionUnwrapError</code> <p>If the result is <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"value\").expect(\"fruits are healthy\")\n'value'\n&gt;&gt;&gt; pc.NONE.expect(\"fruits are healthy\")\nTraceback (most recent call last):\n...\nOptionUnwrapError: fruits are healthy (called `expect` on a `None`)\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.filter","level":2,"title":"<code>filter(predicate, *args, **kwargs)</code>","text":"<p>Returns None if the option is None, otherwise calls predicate with the wrapped value.</p> <p>This function works similar to <code>Iter.filter</code> in the sense that we only keep the value if it matches a predicate.</p> <p>You can imagine the <code>Option[T]</code> being an iterator over one or zero elements.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[Concatenate[T, P], R]</code> <p>The predicate to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to predicate.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to predicate.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: <code>Some[T]</code> if predicate returns true (where T is the wrapped value), <code>NONE</code> if predicate returns false.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; def is_even(n: int) -&gt; bool:\n...     return n % 2 == 0\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.NONE.filter(is_even)\nNONE\n&gt;&gt;&gt; pc.Some(3).filter(is_even)\nNONE\n&gt;&gt;&gt; pc.Some(4).filter(is_even)\nSome(4)\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Option</code>.</p> <p>Converts an <code>Option[Option[U]]</code> into an <code>Option[U]</code> by removing one level of nesting.</p> <p>Equivalent to <code>Option.and_then(lambda x: x)</code>.</p> <p>Returns:</p> Type Description <code>Option[U]</code> <p>Option[U]: The flattened option.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(pc.Some(42)).flatten()\nSome(42)\n&gt;&gt;&gt; pc.Some(pc.NONE).flatten()\nNONE\n&gt;&gt;&gt; pc.NONE.flatten()\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.if_some","level":2,"title":"<code>if_some(value)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on the truthiness of a value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the value is truthy, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_some(42)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_some(0)\nNONE\n&gt;&gt;&gt; pc.Option.if_some(\"hello\")\nSome('hello')\n&gt;&gt;&gt; pc.Option.if_some(\"\")\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.if_true","level":2,"title":"<code>if_true(value, *, predicate)</code>  <code>staticmethod</code>","text":"<p>Creates an <code>Option[V]</code> based on a predicate condition on the provided value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>V</code> <p>The value to wrap in <code>Some</code> if the condition is <code>True</code>.</p> required <code>predicate</code> <code>Callable[[V], bool]</code> <p>The condition to evaluate.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> if the condition is <code>True</code>, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Option.if_true(42, predicate=lambda x: x == 42)\nSome(42)\n&gt;&gt;&gt; pc.Option.if_true(21, predicate=lambda x: x == 42)\nNONE\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; pc.Option.if_true(Path(\"README.md\"), predicate=Path.exists).map(str)\nSome('README.md')\n&gt;&gt;&gt; pc.Option.if_true(Path(\"README.md\"), predicate=lambda p: p.exists()).map(str) # Same as above\nSome('README.md')\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.inspect","level":2,"title":"<code>inspect(f, *args, **kwargs)</code>","text":"<p>Applies a function to the contained <code>Some</code> value, returning the original <code>Option</code>.</p> <p>This allows side effects (logging, debugging, metrics, etc.) on the wrapped value without changing it.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[Concatenate[T, P], object]</code> <p>Function to apply to the <code>Some</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The original option, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; seen: list[int] = []\n&gt;&gt;&gt; pc.Some(2).inspect(lambda x: seen.append(x))\nSome(2)\n&gt;&gt;&gt; seen\n[2]\n&gt;&gt;&gt; pc.NONE.inspect(lambda x: seen.append(x))\nNONE\n&gt;&gt;&gt; seen\n[2]\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.is_none","level":2,"title":"<code>is_none()</code>","text":"<p>Returns <code>True</code> if the option is a <code>None</code> value.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is a <code>_None</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: Option[int] = pc.Some(2)\n&gt;&gt;&gt; x.is_none()\nFalse\n&gt;&gt;&gt; y: Option[int] = pc.NONE\n&gt;&gt;&gt; y.is_none()\nTrue\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.is_none_or","level":2,"title":"<code>is_none_or(func, *args, **kwargs)</code>","text":"<p>Returns true if the option is a None or the value inside of it matches a predicate.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[T, P], bool]</code> <p>The predicate to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is <code>None</code> or the predicate returns <code>True</code> for the contained value, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).is_none_or(lambda x: x &gt; 1)\nTrue\n&gt;&gt;&gt; pc.Some(0).is_none_or(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; pc.NONE.is_none_or(lambda x: x &gt; 1)\nTrue\n&gt;&gt;&gt; pc.Some(\"hello\").is_none_or(lambda x: len(x) &gt; 1)\nTrue\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.is_some","level":2,"title":"<code>is_some()</code>","text":"<p>Returns <code>True</code> if the option is a <code>Some</code> value.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is a <code>Some</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: Option[int] = pc.Some(2)\n&gt;&gt;&gt; x.is_some()\nTrue\n&gt;&gt;&gt; y: Option[int] = pc.NONE\n&gt;&gt;&gt; y.is_some()\nFalse\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.is_some_and","level":2,"title":"<code>is_some_and(predicate, *args, **kwargs)</code>","text":"<p>Returns true if the option is a Some and the value inside of it matches a predicate.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[Concatenate[T, P], bool]</code> <p>The predicate to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to predicate.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to predicate.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the option is <code>Some</code> and the predicate returns <code>True</code> for the contained value, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x = pc.Some(2)\n&gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\nTrue\n\n&gt;&gt;&gt; x = pc.Some(0)\n&gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; x = pc.NONE\n&gt;&gt;&gt; x.is_some_and(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; x = pc.Some(\"hello\")\n&gt;&gt;&gt; x.is_some_and(lambda x: len(x) &gt; 1)\nTrue\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.iter","level":2,"title":"<code>iter()</code>","text":"<p>Creates an <code>Iter</code> over the optional value.</p> <ul> <li>If the option is <code>Some(value)</code>, the iterator yields <code>value</code>.</li> <li>If the option is <code>NONE</code>, the iterator yields nothing.</li> </ul> <p>Equivalent to <code>Iter((self,))</code>.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterator over the optional value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(42).iter().next()\nSome(42)\n&gt;&gt;&gt; pc.NONE.iter().next()\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.map","level":2,"title":"<code>map(f, *args, **kwargs)</code>","text":"<p>Maps an <code>Option[T]</code> to <code>Option[U]</code>.</p> <p>Done by applying a function to a contained <code>Some</code> value, leaving a <code>None</code> value untouched.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[Concatenate[T, P], R]</code> <p>The function to apply to the <code>Some</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: A new <code>Option</code> with the mapped value if <code>Some</code>, otherwise <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"Hello, World!\").map(len)\nSome(13)\n&gt;&gt;&gt; pc.NONE.map(len)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.map_or","level":2,"title":"<code>map_or(default, f, *args, **kwargs)</code>","text":"<p>Returns the result of applying a function to the contained value if Some, otherwise returns the default value.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>R</code> <p>The default value to return if NONE.</p> required <code>f</code> <code>Callable[Concatenate[T, P], R]</code> <p>The function to apply to the contained value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The result of f(self.unwrap()) if Some, otherwise default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).map_or(0, lambda x: x * 10)\n20\n&gt;&gt;&gt; pc.NONE.map_or(0, lambda x: x * 10)\n0\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.map_or_else","level":2,"title":"<code>map_or_else(default, f)</code>","text":"<p>Returns the result of applying a function to the contained value if Some, otherwise computes a default value.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>Callable[[], R]</code> <p>A function returning the default value if NONE.</p> required <code>f</code> <code>Callable[[T], R]</code> <p>The function to apply to the contained value.</p> required <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The result of f(self.unwrap()) if Some, otherwise default().</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).map_or_else(lambda: 0, lambda x: x * 10)\n20\n&gt;&gt;&gt; pc.NONE.map_or_else(lambda: 0, lambda x: x * 10)\n0\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.map_star","level":2,"title":"<code>map_star(func)</code>","text":"<pre><code>map_star(func: Callable[[Any], R]) -&gt; Option[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2], R]) -&gt; Option[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2, T3], R]) -&gt; Option[R]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2, T3, T4], R]) -&gt; Option[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5], R],\n) -&gt; Option[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], R],\n) -&gt; Option[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n) -&gt; Option[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n) -&gt; Option[R]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n) -&gt; Option[R]\n</code></pre><pre><code>map_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R\n    ],\n) -&gt; Option[R]\n</code></pre> <p>Maps an <code>Option[Iterable]</code> to <code>Option[U]</code> by unpacking the iterable into the function.</p> <p>Done by applying a function to a contained <code>Some</code> value, leaving a <code>None</code> value untouched.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>The function to apply to the unpacked <code>Some</code> value.</p> required <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: A new <code>Option</code> with the mapped value if <code>Some</code>, otherwise <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some((2, 3)).map_star(lambda x, y: x + y)\nSome(5)\n&gt;&gt;&gt; pc.NONE.map_star(lambda x, y: x + y)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.ne","level":2,"title":"<code>ne(other)</code>","text":"<p>Checks if two <code>Option[T]</code> instances are not equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[T]</code> <p>The other <code>Option[T]</code> instance to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if both instances are not equal, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(42).ne(pc.Some(21))\nTrue\n&gt;&gt;&gt; pc.Some(42).ne(pc.Some(42))\nFalse\n&gt;&gt;&gt; pc.Some(42).ne(pc.NONE)\nTrue\n&gt;&gt;&gt; pc.NONE.ne(pc.NONE)\nFalse\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.ok_or","level":2,"title":"<code>ok_or(err)</code>","text":"<p>Converts the option to a <code>Result</code>.</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>E</code> <p>The error value to use if the option is <code>NONE</code>.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: <code>Ok(v)</code> if <code>Some(v)</code>, otherwise <code>Err(err)</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(1).ok_or('fail')\nOk(1)\n&gt;&gt;&gt; pc.NONE.ok_or('fail')\nErr('fail')\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.ok_or_else","level":2,"title":"<code>ok_or_else(err)</code>","text":"<p>Converts the option to a Result.</p> <p>Parameters:</p> Name Type Description Default <code>err</code> <code>Callable[[], E]</code> <p>A function returning the error value if the option is NONE.</p> required <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: Ok(v) if Some(v), otherwise Err(err()).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(1).ok_or_else(lambda: 'fail')\nOk(1)\n&gt;&gt;&gt; pc.NONE.ok_or_else(lambda: 'fail')\nErr('fail')\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.or_","level":2,"title":"<code>or_(optb)</code>","text":"<p>Returns the option if it contains a value, otherwise returns optb.</p> <p>Parameters:</p> Name Type Description Default <code>optb</code> <code>Option[T]</code> <p>The option to return if the original option is <code>NONE</code>.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The original option if it is <code>Some</code>, otherwise <code>optb</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).or_(pc.NONE)\nSome(2)\n&gt;&gt;&gt; pc.NONE.or_(pc.Some(100))\nSome(100)\n&gt;&gt;&gt; pc.Some(2).or_(pc.Some(100))\nSome(2)\n&gt;&gt;&gt; pc.NONE.or_(pc.NONE)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.or_else","level":2,"title":"<code>or_else(f)</code>","text":"<p>Returns the <code>Option[T]</code> if it contains a value, otherwise calls a function and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], Option[T]]</code> <p>The function to call if the option is <code>None</code>.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The original <code>Option</code> if it is <code>Some</code>, otherwise the result of the function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def nobody() -&gt; Option[str]:\n...     return pc.NONE\n&gt;&gt;&gt; def vikings() -&gt; Option[str]:\n...     return pc.Some(\"vikings\")\n&gt;&gt;&gt; pc.Some(\"barbarians\").or_else(vikings)\nSome('barbarians')\n&gt;&gt;&gt; pc.NONE.or_else(vikings)\nSome('vikings')\n&gt;&gt;&gt; pc.NONE.or_else(nobody)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.reduce","level":2,"title":"<code>reduce(other, func)</code>","text":"<p>Reduces two options into one, using the provided function if both are Some.</p> <p>If self is <code>Some(s)</code> and other is <code>Some(o)</code>, this method returns <code>Some(func(s, o))</code>.</p> <p>Otherwise, if only one of self and other is <code>Some</code>, that value is returned.</p> <p>If both self and other are <code>NONE</code>, <code>NONE</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[T]</code> <p>The second option.</p> required <code>func</code> <code>Callable[[T, T], T]</code> <p>The function to apply to the unwrapped values.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The resulting option after reduction.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; s12 = pc.Some(12)\n&gt;&gt;&gt; s17 = pc.Some(17)\n&gt;&gt;&gt;\n&gt;&gt;&gt; def add(a: int, b: int) -&gt; int:\n...     return a + b\n&gt;&gt;&gt;\n&gt;&gt;&gt; s12.reduce(s17, add)\nSome(29)\n&gt;&gt;&gt; s12.reduce(pc.NONE, add)\nSome(12)\n&gt;&gt;&gt; pc.NONE.reduce(s17, add)\nSome(17)\n&gt;&gt;&gt; pc.NONE.reduce(pc.NONE, add)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.transpose","level":2,"title":"<code>transpose()</code>","text":"<p>Transposes an <code>Option</code> of a <code>Result</code> into a <code>Result</code> of an <code>Option</code>.</p> <p><code>Some(Ok[T])</code> is mapped to <code>Ok(Some[T])</code>, <code>Some(Err[E])</code> is mapped to <code>Err[E]</code>, and <code>NONE</code> will be mapped to <code>Ok(NONE)</code>.</p> <p>Returns:</p> Type Description <code>Result[Option[T], E]</code> <p>Result[Option[T], E]: The transposed result.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(pc.Ok(5)).transpose()\nOk(Some(5))\n&gt;&gt;&gt; pc.NONE.transpose()\nOk(NONE)\n&gt;&gt;&gt; pc.Some(pc.Err(\"error\")).transpose()\nErr('error')\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.unwrap","level":2,"title":"<code>unwrap()</code>","text":"<p>Returns the contained <code>Some</code> value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value.</p> <p>Raises:</p> Type Description <code>OptionUnwrapError</code> <p>If the option is <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"car\").unwrap()\n'car'\n</code></pre> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.NONE.unwrap()\nTraceback (most recent call last):\n...\nOptionUnwrapError: called `unwrap` on a `None`\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.unwrap_or","level":2,"title":"<code>unwrap_or(default)</code>","text":"<p>Returns the contained <code>Some</code> value or a provided default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The value to return if the result is <code>None</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value or the provided default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(\"car\").unwrap_or(\"bike\")\n'car'\n&gt;&gt;&gt; pc.NONE.unwrap_or(\"bike\")\n'bike'\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.unwrap_or_else","level":2,"title":"<code>unwrap_or_else(f)</code>","text":"<p>Returns the contained <code>Some</code> value or computes it from a function.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[], T]</code> <p>A function that returns a default value if the result is <code>None</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Some</code> value or the result of the function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; k = 10\n&gt;&gt;&gt; pc.Some(4).unwrap_or_else(lambda: 2 * k)\n4\n&gt;&gt;&gt; pc.NONE.unwrap_or_else(lambda: 2 * k)\n20\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.unzip","level":2,"title":"<code>unzip()</code>","text":"<p>Unzips an <code>Option</code> of a tuple into a tuple of <code>Option</code>s.</p> <p>If the option is <code>Some((a, b))</code>, this method returns <code>(Some(a), Some(b))</code>. If the option is <code>NONE</code>, it returns <code>(NONE, NONE)</code>.</p> <p>Returns:</p> Type Description <code>tuple[Option[T], Option[U]]</code> <p>tuple[Option[T], Option[U]]: A tuple containing two options.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some((1, 'a')).unzip()\n(Some(1), Some('a'))\n&gt;&gt;&gt; pc.NONE.unzip()\n(NONE, NONE)\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.xor","level":2,"title":"<code>xor(optb)</code>","text":"<p>Returns <code>Some</code> if exactly one of self, optb is <code>Some</code>, otherwise returns <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>optb</code> <code>Option[T]</code> <p>The other option to compare with.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: <code>Some</code> value if exactly one option is <code>Some</code>, otherwise <code>NONE</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(2).xor(pc.NONE)\nSome(2)\n&gt;&gt;&gt; pc.NONE.xor(pc.Some(2))\nSome(2)\n&gt;&gt;&gt; pc.Some(2).xor(pc.Some(2))\nNONE\n&gt;&gt;&gt; pc.NONE.xor(pc.NONE)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.zip","level":2,"title":"<code>zip(other)</code>","text":"<p>Returns an <code>Option[tuple[T, U]]</code> containing a tuple of the values if both options are <code>Some</code>, otherwise returns <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[U]</code> <p>The other option to zip with.</p> required <p>Returns:</p> Type Description <code>Option[tuple[T, U]]</code> <p>Option[tuple[T, U]]: Some((self, other)) if both are Some, otherwise NONE.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(1).zip(pc.Some('a'))\nSome((1, 'a'))\n&gt;&gt;&gt; pc.Some(1).zip(pc.NONE)\nNONE\n&gt;&gt;&gt; pc.NONE.zip(pc.Some('a'))\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/option/#pyochain.rs.Option.zip_with","level":2,"title":"<code>zip_with(other, f)</code>","text":"<p>Zips <code>self</code> and another <code>Option</code> with function <code>f</code>.</p> <p>If <code>self</code> is <code>Some(s)</code> and other is <code>Some(o)</code>, this method returns <code>Some(f(s, o))</code>.</p> <p>Otherwise, <code>NONE</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Option[U]</code> <p>The second option.</p> required <code>f</code> <code>Callable[[T, U], R]</code> <p>The function to apply to the unwrapped values.</p> required <p>Returns:</p> Type Description <code>Option[R]</code> <p>Option[R]: The resulting option after applying the function.</p> <p>Example: <pre><code>&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt;\n&gt;&gt;&gt; @dataclass\n... class Point:\n...     x: float\n...     y: float\n&gt;&gt;&gt;\n&gt;&gt;&gt; x = pc.Some(17.5)\n&gt;&gt;&gt; y = pc.Some(42.7)\n&gt;&gt;&gt; x.zip_with(y, Point)\nSome(Point(x=17.5, y=42.7))\n&gt;&gt;&gt; x.zip_with(pc.NONE, Point)\nNONE\n&gt;&gt;&gt; pc.NONE.zip_with(y, Point)\nNONE\n</code></pre></p>","path":["API Reference","Optional Values","Option"],"tags":[]},{"location":"reference/optionunwraperror/","level":1,"title":"OptionUnwrapError","text":"<p>               Bases: <code>RuntimeError</code></p>","path":["API Reference","Optional Values","OptionUnwrapError"],"tags":[]},{"location":"reference/peekable/","level":1,"title":"Peekable","text":"<p>               Bases: <code>Pipeable</code>, <code>Checkable</code></p> <p>Represents the result of peeking into an <code>Iter</code>.</p> <p>Inerhit from <code>Checkable</code> to provide truthiness based on whether any elements were peeked.</p> <p>Attributes:</p> Name Type Description <code>peek</code> <code>Seq[T]</code> <p>A <code>Seq</code> of the peeked elements.</p> <code>values</code> <code>Iter[T]</code> <p>An <code>Iter</code> of values, still including the peeked elements.</p> See Also <p><code>Iter.peekable()</code> <code>Iter.cloned()</code></p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; it = pc.Iter([1, 2, 3, 4, 5])\n&gt;&gt;&gt; peekable = it.peekable(3)\n&gt;&gt;&gt; peekable.peek\nSeq(1, 2, 3)\n&gt;&gt;&gt; peekable.values.collect()\nSeq(1, 2, 3, 4, 5)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@dataclass(slots=True)\nclass Peekable[T](Pipeable, Checkable):\n    \"\"\"Represents the result of peeking into an `Iter`.\n\n    Inerhit from `Checkable` to provide truthiness based on whether any elements were peeked.\n\n    Attributes:\n        peek (Seq[T]): A `Seq` of the peeked elements.\n        values (Iter[T]): An `Iter` of values, still including the peeked elements.\n\n    See Also:\n        `Iter.peekable()`\n        `Iter.cloned()`\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; it = pc.Iter([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; peekable = it.peekable(3)\n    &gt;&gt;&gt; peekable.peek\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; peekable.values.collect()\n    Seq(1, 2, 3, 4, 5)\n\n    ```\n    \"\"\"\n\n    peek: Seq[T]\n    \"\"\"A `Seq` of the peeked elements.\"\"\"\n    values: Iter[T]\n    \"\"\"An `Iter` of values, still including the peeked elements.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return bool(self.peek)\n</code></pre>","path":["API Reference","Iterators","Peekable"],"tags":[]},{"location":"reference/peekable/#pyochain._iter.Peekable.peek","level":2,"title":"<code>peek</code>  <code>instance-attribute</code>","text":"<p>A <code>Seq</code> of the peeked elements.</p>","path":["API Reference","Iterators","Peekable"],"tags":[]},{"location":"reference/peekable/#pyochain._iter.Peekable.values","level":2,"title":"<code>values</code>  <code>instance-attribute</code>","text":"<p>An <code>Iter</code> of values, still including the peeked elements.</p>","path":["API Reference","Iterators","Peekable"],"tags":[]},{"location":"reference/pipeable/","level":1,"title":"Pipeable","text":"<p>               Bases: <code>Protocol</code></p> <p>Mixin class providing pipeable methods for fluent chaining.</p>","path":["API Reference","Traits & Mixins","Pipeable"],"tags":[]},{"location":"reference/pipeable/#pyochain.rs.Pipeable.inspect","level":2,"title":"<code>inspect(func, *args, **kwargs)</code>","text":"<p>Pass <code>Self</code> to func to perform side effects without altering the data.</p> <p>This method is very useful for debugging or passing the instance to other functions for side effects, without breaking the fluent method chaining.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], object]</code> <p>Function to apply to the instance for side effects.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The instance itself, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3, 4]).inspect(print).last()\nSeq(1, 2, 3, 4)\n4\n</code></pre></p>","path":["API Reference","Traits & Mixins","Pipeable"],"tags":[]},{"location":"reference/pipeable/#pyochain.rs.Pipeable.into","level":2,"title":"<code>into(func, *args, **kwargs)</code>","text":"<p>Convert <code>Self</code> to <code>R</code>.</p> <p>This method allows to pipe the instance into an object or function that can convert <code>Self</code> into another type.</p> <p>Conceptually, this allow to do <code>x.into(f)</code> instead of <code>f(x)</code>, hence keeping a fluent chaining style.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[Self, P], R]</code> <p>Function for conversion.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments to pass to func.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments to pass to func.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>The converted value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from collections.abc import Sequence\n&gt;&gt;&gt; import hashlib\n&gt;&gt;&gt; def sha256_hex(data: Sequence[int]) -&gt; str:\n...     return hashlib.sha256(bytes(data)).hexdigest()\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).into(sha256_hex)\n'039058c6f2c0cb492c533b0a4d14ef77cc0f78abccced5287d84a1a2011cfb81'\n</code></pre></p>","path":["API Reference","Traits & Mixins","Pipeable"],"tags":[]},{"location":"reference/pyocollection/","level":1,"title":"PyoCollection","text":"<p>               Bases: <code>PyoIterable[T]</code>, <code>Collection[T]</code></p> <p>Base trait for eager pyochain collections.</p> <p><code>PyoCollection[T]</code> is the shared trait for concrete, eager collections: <code>Seq</code>, <code>Vec</code>, <code>Set</code>, <code>SetMut</code>, <code>Dict</code>.</p> <p>It extends <code>PyoIterable[T]</code> and <code>collections.abc.Collection[T]</code> and provides a few convenience methods like <code>contains()</code> and <code>repeat()</code>.</p> <p>This is equivalent to subclassing <code>collections.abc.Collection[T]</code> (this trait already does), meaning any concrete subclass must implement the required <code>Collection</code> dunder methods:</p> <ul> <li><code>__iter__</code></li> <li><code>__len__</code></li> <li><code>__contains__</code></li> </ul> <p>On top of the standard <code>Collection</code> protocol, it provides the additional pyochain API (from <code>PyoIterable</code>, <code>Pipeable</code>, <code>Checkable</code>, plus the helpers defined here).</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoCollection[T](PyoIterable[T], Collection[T]):\n    \"\"\"Base trait for eager pyochain collections.\n\n    `PyoCollection[T]` is the shared trait for concrete, eager collections:\n    `Seq`, `Vec`, `Set`, `SetMut`, `Dict`.\n\n    It extends `PyoIterable[T]` and `collections.abc.Collection[T]` and provides\n    a few convenience methods like `contains()` and `repeat()`.\n\n    This is equivalent to subclassing `collections.abc.Collection[T]` (this\n    trait already does), meaning any concrete subclass must implement the\n    required `Collection` dunder methods:\n\n    - `__iter__`\n    - `__len__`\n    - `__contains__`\n\n    On top of the standard `Collection` protocol, it provides the additional\n    pyochain API (from `PyoIterable`, `Pipeable`, `Checkable`, plus the helpers\n    defined here).\n\n    \"\"\"\n\n    __slots__ = ()\n\n    @override\n    def length(self) -&gt; int:\n        return len(self)\n\n    def contains(self, value: T) -&gt; bool:\n        \"\"\"Check if the `Collection` contains the specified **value**.\n\n        This is equivalent to using the `in` keyword directly on the `Collection`.\n\n        Args:\n            value (T): The value to check for existence.\n\n        Returns:\n            bool: True if the value exists in the Collection, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.contains(1)\n        True\n        &gt;&gt;&gt; data.contains(3)\n        False\n\n        ```\n        \"\"\"\n        return value in self\n\n    def repeat(self, n: int | None = None) -&gt; Iter[Self]:\n        \"\"\"Repeat the entire `Collection` **n** times (as elements) in an `Iter`.\n\n        If **n** is `None`, repeat indefinitely.\n\n        Warning:\n            If **n** is `None`, this will create an infinite `Iterator`.\n\n            Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n        See Also:\n            `Iter.cycle()` to repeat the *elements* of the `Iter` indefinitely.\n\n        Args:\n            n (int | None): Optional number of repetitions.\n\n        Returns:\n            Iter[Self]: An `Iter` of repeated `Iter`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2]).repeat(3).collect()\n        Seq(Seq(1, 2), Seq(1, 2), Seq(1, 2))\n        &gt;&gt;&gt; pc.Seq((\"a\", \"b\")).repeat(2).collect()\n        Seq(Seq('a', 'b'), Seq('a', 'b'))\n        &gt;&gt;&gt; pc.Seq([0]).repeat().flatten().take(5).collect()\n        Seq(0, 0, 0, 0, 0)\n\n        ```\n        \"\"\"\n        from .._iter import Iter\n\n        if n is None:\n            return Iter(itertools.repeat(self))\n        return Iter(itertools.repeat(self, n))\n\n    def is_empty(self) -&gt; bool:\n        \"\"\"Returns `True` if the `Collection` contains no elements.\n\n        Returns:\n            bool: `True` if the `Collection` is empty, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; d = pc.Dict.new()\n        &gt;&gt;&gt; d.is_empty()\n        True\n        &gt;&gt;&gt; d.insert(1, \"a\")\n        NONE\n        &gt;&gt;&gt; d.is_empty()\n        False\n\n        ```\n        \"\"\"\n        return len(self) == 0\n</code></pre>","path":["API Reference","Traits & Mixins","PyoCollection"],"tags":[]},{"location":"reference/pyocollection/#pyochain.traits._iterable.PyoCollection.contains","level":2,"title":"<code>contains(value)</code>","text":"<p>Check if the <code>Collection</code> contains the specified value.</p> <p>This is equivalent to using the <code>in</code> keyword directly on the <code>Collection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to check for existence.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the value exists in the Collection, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.contains(1)\nTrue\n&gt;&gt;&gt; data.contains(3)\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def contains(self, value: T) -&gt; bool:\n    \"\"\"Check if the `Collection` contains the specified **value**.\n\n    This is equivalent to using the `in` keyword directly on the `Collection`.\n\n    Args:\n        value (T): The value to check for existence.\n\n    Returns:\n        bool: True if the value exists in the Collection, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.contains(1)\n    True\n    &gt;&gt;&gt; data.contains(3)\n    False\n\n    ```\n    \"\"\"\n    return value in self\n</code></pre>","path":["API Reference","Traits & Mixins","PyoCollection"],"tags":[]},{"location":"reference/pyocollection/#pyochain.traits._iterable.PyoCollection.is_empty","level":2,"title":"<code>is_empty()</code>","text":"<p>Returns <code>True</code> if the <code>Collection</code> contains no elements.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the <code>Collection</code> is empty, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; d = pc.Dict.new()\n&gt;&gt;&gt; d.is_empty()\nTrue\n&gt;&gt;&gt; d.insert(1, \"a\")\nNONE\n&gt;&gt;&gt; d.is_empty()\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_empty(self) -&gt; bool:\n    \"\"\"Returns `True` if the `Collection` contains no elements.\n\n    Returns:\n        bool: `True` if the `Collection` is empty, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; d = pc.Dict.new()\n    &gt;&gt;&gt; d.is_empty()\n    True\n    &gt;&gt;&gt; d.insert(1, \"a\")\n    NONE\n    &gt;&gt;&gt; d.is_empty()\n    False\n\n    ```\n    \"\"\"\n    return len(self) == 0\n</code></pre>","path":["API Reference","Traits & Mixins","PyoCollection"],"tags":[]},{"location":"reference/pyocollection/#pyochain.traits._iterable.PyoCollection.repeat","level":2,"title":"<code>repeat(n=None)</code>","text":"<p>Repeat the entire <code>Collection</code> n times (as elements) in an <code>Iter</code>.</p> <p>If n is <code>None</code>, repeat indefinitely.</p> Warning <p>If n is <code>None</code>, this will create an infinite <code>Iterator</code>.</p> <p>Be sure to use <code>Iter.take()</code> or <code>Iter.slice()</code> to limit the number of items taken.</p> See Also <p><code>Iter.cycle()</code> to repeat the elements of the <code>Iter</code> indefinitely.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Optional number of repetitions.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[Self]</code> <p>Iter[Self]: An <code>Iter</code> of repeated <code>Iter</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).repeat(3).collect()\nSeq(Seq(1, 2), Seq(1, 2), Seq(1, 2))\n&gt;&gt;&gt; pc.Seq((\"a\", \"b\")).repeat(2).collect()\nSeq(Seq('a', 'b'), Seq('a', 'b'))\n&gt;&gt;&gt; pc.Seq([0]).repeat().flatten().take(5).collect()\nSeq(0, 0, 0, 0, 0)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def repeat(self, n: int | None = None) -&gt; Iter[Self]:\n    \"\"\"Repeat the entire `Collection` **n** times (as elements) in an `Iter`.\n\n    If **n** is `None`, repeat indefinitely.\n\n    Warning:\n        If **n** is `None`, this will create an infinite `Iterator`.\n\n        Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n    See Also:\n        `Iter.cycle()` to repeat the *elements* of the `Iter` indefinitely.\n\n    Args:\n        n (int | None): Optional number of repetitions.\n\n    Returns:\n        Iter[Self]: An `Iter` of repeated `Iter`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).repeat(3).collect()\n    Seq(Seq(1, 2), Seq(1, 2), Seq(1, 2))\n    &gt;&gt;&gt; pc.Seq((\"a\", \"b\")).repeat(2).collect()\n    Seq(Seq('a', 'b'), Seq('a', 'b'))\n    &gt;&gt;&gt; pc.Seq([0]).repeat().flatten().take(5).collect()\n    Seq(0, 0, 0, 0, 0)\n\n    ```\n    \"\"\"\n    from .._iter import Iter\n\n    if n is None:\n        return Iter(itertools.repeat(self))\n    return Iter(itertools.repeat(self, n))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoCollection"],"tags":[]},{"location":"reference/pyoitemsview/","level":1,"title":"PyoItemsView","text":"<p>               Bases: <code>ItemsView[K, V]</code>, <code>PyoMappingView[tuple[K, V]]</code>, <code>PyoSet[tuple[K, V]]</code></p> <p>A view of the items (key-value pairs) in a pyochain mapping.</p> <p>This class provides a view over the items contained in a pyochain mapping, with additional methods from the <code>PyoMappingView</code>, <code>PyoSet</code>, and <code>PyoCollection</code> traits.</p> <p>Items are represented as tuples of <code>(key, value)</code> pairs, and the view supports set-like operations.</p> See Also <p><code>PyoMapping.items()</code>: Method that returns this view.</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoItemsView[K, V](\n    ItemsView[K, V], PyoMappingView[tuple[K, V]], PyoSet[tuple[K, V]]\n):\n    \"\"\"A view of the items (key-value pairs) in a pyochain mapping.\n\n    This class provides a view over the items contained in a pyochain mapping, with\n    additional methods from the `PyoMappingView`, `PyoSet`, and `PyoCollection` traits.\n\n    Items are represented as tuples of `(key, value)` pairs, and the view supports set-like operations.\n\n    See Also:\n        `PyoMapping.items()`: Method that returns this view.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>","path":["API Reference","Traits & Mixins","PyoItemsView"],"tags":[]},{"location":"reference/pyoiterable/","level":1,"title":"PyoIterable","text":"<p>               Bases: <code>Pipeable</code>, <code>Checkable</code>, <code>Iterable[T]</code></p> <p>Base trait for all pyochain <code>Iterables</code>.</p> <p><code>PyoIterable[T]</code> is the common API surface shared by:</p> <ul> <li>eager <code>Collections</code>: <code>Seq</code>, <code>Vec</code>, <code>Set</code>, <code>SetMut</code>, <code>Dict</code></li> <li>lazy <code>Iterator</code>: <code>Iter</code></li> </ul> <p>You typically don't instantiate this trait directly; it exists to provide a consistent, fluent interface across all pyochain <code>Iterables</code>.</p> <p>This is equivalent to inheriting from <code>collections.abc.Iterable[T]</code> (this trait already does), meaning any concrete subclass is an <code>Iterable[T]</code> as soon as it implements the required dunder <code>__iter__()</code>.</p> <p>On top of the standard <code>Iterable</code> protocol, it provides additional pyochain methods for fluent chaining and convenience (<code>Pipeable</code>, <code>Checkable</code>, <code>length()</code>, comparison helpers, aggregations, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The data to initialize the concrete iterable with.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Always raised when instantiating <code>PyoIterable</code> directly.</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoIterable[T](Pipeable, Checkable, Iterable[T]):\n    \"\"\"Base trait for all pyochain `Iterables`.\n\n    `PyoIterable[T]` is the common API surface shared by:\n\n    - eager `Collections`: `Seq`, `Vec`, `Set`, `SetMut`, `Dict`\n    - lazy `Iterator`: `Iter`\n\n    You typically don't instantiate this trait directly; it exists to provide a\n    consistent, fluent interface across all pyochain `Iterables`.\n\n    This is equivalent to inheriting from `collections.abc.Iterable[T]` (this\n    trait already does), meaning any concrete subclass is an `Iterable[T]` as\n    soon as it implements the required dunder `__iter__()`.\n\n    On top of the standard `Iterable` protocol, it provides additional pyochain\n    methods for fluent chaining and convenience (`Pipeable`, `Checkable`,\n    `length()`, comparison helpers, aggregations, etc.).\n\n\n    Args:\n        data (Iterable[T]): The data to initialize the concrete iterable with.\n\n    Raises:\n        TypeError: Always raised when instantiating `PyoIterable` directly.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __init__(self, data: Iterable[T]) -&gt; None:  # noqa: ARG002\n        msg = f\"Cannot instantiate {self.__class__.__name__} directly. \"\n        raise TypeError(msg)\n\n    @classmethod\n    def new(cls) -&gt; Self:\n        \"\"\"Create an empty `Iterable`.\n\n        Make sure to specify the type when calling this method, e.g., `Vec[int].new()`.\n\n        Otherwise, `T` will be inferred as `Any`.\n\n        This can be very useful for mutable collections like `Vec` and `Dict`.\n\n        However, this can be handy for immutable collections too, for example for representing failure steps in a pipeline.\n\n        Returns:\n            Self: A new empty `Iterable` instance.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Vec[int].new()\n        &gt;&gt;&gt; data\n        Vec()\n        &gt;&gt;&gt; # Equivalent to\n        &gt;&gt;&gt; data: list[str] = []\n        &gt;&gt;&gt; data\n        []\n        &gt;&gt;&gt; my_dict = pc.Dict[str, int].new()\n        &gt;&gt;&gt; my_dict.insert(\"a\", 1)\n        NONE\n        &gt;&gt;&gt; my_dict\n        Dict('a': 1)\n\n        ```\n        \"\"\"\n        return cls(())\n\n    def iter(self) -&gt; Iter[T]:\n        \"\"\"Get an `Iter` over the `Iterable`.\n\n        Call this to switch to lazy evaluation.\n\n        Note:\n            Calling this method on a class who is itself an `Iterator` has no effect.\n\n        Returns:\n            Iter[T]: An `Iterator` over the `Iterable`. The element type is inferred from the actual subclass.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; seq = pc.Seq([1, 2, 3])\n        &gt;&gt;&gt; iterator = seq.iter()\n        &gt;&gt;&gt; iterator.collect()\n        Seq(1, 2, 3)\n        &gt;&gt;&gt; # iterator is now empty\n        &gt;&gt;&gt; iterator.collect()\n        Seq()\n\n        ```\n        \"\"\"\n        from .._iter import Iter\n\n        return Iter(self)\n\n    def length(self) -&gt; int:\n        \"\"\"Return the length of the `Iterable`.\n\n        Returns:\n            int: The count of elements.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2]).length()\n        2\n        &gt;&gt;&gt; pc.Iter(range(5)).length()\n        5\n\n        ```\n        \"\"\"\n        return cz.itertoolz.count(self.__iter__())\n\n    def join(self: PyoIterable[str], sep: str) -&gt; str:\n        \"\"\"Join all elements of the `Iterable` into a single `str`, with a specified separator.\n\n        Args:\n            sep (str): Separator to use between elements.\n\n        Returns:\n            str: The joined string.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n        'a-b-c'\n\n        ```\n        \"\"\"\n        return sep.join(self.__iter__())\n\n    def first(self) -&gt; T:\n        \"\"\"Return the first element of the `Iterable`.\n\n        This is similar to `__getitem__` but works on lazy `Iterators`.\n\n        Returns:\n            T: The first element of the `Iterable`.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([9]).first()\n        9\n\n        ```\n        \"\"\"\n        return cz.itertoolz.first(self.__iter__())\n\n    def second(self) -&gt; T:\n        \"\"\"Return the second element of the `Iterable`.\n\n        This is similar to `__getitem__` but works on lazy `Iterators`.\n\n        Returns:\n            T: The second element of the `Iterable`.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([9, 8]).second()\n        8\n\n        ```\n        \"\"\"\n        return cz.itertoolz.second(self.__iter__())\n\n    def last(self) -&gt; T:\n        \"\"\"Return the last element of the `Iterable`.\n\n        This is similar to `__getitem__` but works on lazy `Iterators`.\n\n        Returns:\n            T: The last element of the `Iterable`.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n        9\n\n        ```\n        \"\"\"\n        return cz.itertoolz.last(self.__iter__())\n\n    def sum[U: int | bool](self: PyoIterable[U]) -&gt; int:\n        \"\"\"Return the sum of the `Iterable`.\n\n        If the `Iterable` is empty, return 0.\n\n        Returns:\n            int: The sum of all elements.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n        6\n\n        ```\n        \"\"\"\n        return sum(self.__iter__())\n\n    def min[U: SupportsRichComparison[Any]](self: PyoIterable[U]) -&gt; U:\n        \"\"\"Return the minimum of the `Iterable`.\n\n        The elements of the `Iterable` must support comparison operations.\n\n        For comparing elements using a custom **key** function, use `min_by()` instead.\n\n        If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n        Returns:\n            U: The minimum value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n        1\n\n        ```\n        \"\"\"\n        return min(self.__iter__())\n\n    def min_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n        \"\"\"Return the minimum element of the `Iterable` using a custom **key** function.\n\n        If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n        Args:\n            key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n        Returns:\n            T: The element with the minimum key value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; @dataclass\n        ... class Foo:\n        ...     x: int\n        ...     y: str\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\n        Foo(x=1, y='b')\n        &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\n        Foo(x=1, y='b')\n\n        ```\n        \"\"\"\n        return min(self.__iter__(), key=key)\n\n    def max[U: SupportsRichComparison[Any]](self: PyoIterable[U]) -&gt; U:\n        \"\"\"Return the maximum element of the `Iterable`.\n\n        The elements of the `Iterable` must support comparison operations.\n\n        For comparing elements using a custom **key** function, use `max_by()` instead.\n\n        If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n        Returns:\n            U: The maximum value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n        3\n\n        ```\n        \"\"\"\n        return max(self.__iter__())\n\n    def max_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n        \"\"\"Return the maximum element of the `Iterable` using a custom **key** function.\n\n        If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n        Args:\n            key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n        Returns:\n            T: The element with the maximum key value.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; from dataclasses import dataclass\n        &gt;&gt;&gt; @dataclass\n        ... class Foo:\n        ...     x: int\n        ...     y: str\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\n        Foo(x=4, y='c')\n        &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\n        Foo(x=3, y='b')\n\n        ```\n        \"\"\"\n        return max(self.__iter__(), key=key)\n\n    def all(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n        \"\"\"Tests if every element of the `Iterable` is truthy.\n\n        `Iter.all()` can optionally take a closure that returns true or false.\n\n        It applies this closure to each element of the `Iterable`, and if they all return true, then so does `Iter.all()`.\n\n        If any of them return false, it returns false.\n\n        An empty `Iterable` returns true.\n\n        Args:\n            predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n        Returns:\n            bool: True if all elements match the predicate, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, True]).all()\n        True\n        &gt;&gt;&gt; pc.Seq([]).all()\n        True\n        &gt;&gt;&gt; pc.Seq([1, 0]).all()\n        False\n        &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n        ...     return x % 2 == 0\n        &gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\n        True\n\n        ```\n        \"\"\"\n        if predicate is None:\n            return all(self.__iter__())\n        return all(predicate(x) for x in self.__iter__())\n\n    def any(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n        \"\"\"Tests if any element of the `Iterable` is truthy.\n\n        `Iter.any()` can optionally take a closure that returns true or false.\n\n        It applies this closure to each element of the `Iterable`, and if any of them return true, then so does `Iter.any()`.\n        If they all return false, it returns false.\n\n        An empty iterator returns false.\n\n        Args:\n            predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n        Returns:\n            bool: True if any element matches the predicate, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([0, 1]).any()\n        True\n        &gt;&gt;&gt; pc.Seq(range(0)).any()\n        False\n        &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n        ...     return x % 2 == 0\n        &gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\n        True\n\n        ```\n        \"\"\"\n        if predicate is None:\n            return any(self.__iter__())\n        return any(predicate(x) for x in self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.all","level":2,"title":"<code>all(predicate=None)</code>","text":"<p>Tests if every element of the <code>Iterable</code> is truthy.</p> <p><code>Iter.all()</code> can optionally take a closure that returns true or false.</p> <p>It applies this closure to each element of the <code>Iterable</code>, and if they all return true, then so does <code>Iter.all()</code>.</p> <p>If any of them return false, it returns false.</p> <p>An empty <code>Iterable</code> returns true.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all elements match the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, True]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([]).all()\nTrue\n&gt;&gt;&gt; pc.Seq([1, 0]).all()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def all(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if every element of the `Iterable` is truthy.\n\n    `Iter.all()` can optionally take a closure that returns true or false.\n\n    It applies this closure to each element of the `Iterable`, and if they all return true, then so does `Iter.all()`.\n\n    If any of them return false, it returns false.\n\n    An empty `Iterable` returns true.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if all elements match the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, True]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([]).all()\n    True\n    &gt;&gt;&gt; pc.Seq([1, 0]).all()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([2, 4, 6]).all(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return all(self.__iter__())\n    return all(predicate(x) for x in self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.any","level":2,"title":"<code>any(predicate=None)</code>","text":"<p>Tests if any element of the <code>Iterable</code> is truthy.</p> <p><code>Iter.any()</code> can optionally take a closure that returns true or false.</p> <p>It applies this closure to each element of the <code>Iterable</code>, and if any of them return true, then so does <code>Iter.any()</code>. If they all return false, it returns false.</p> <p>An empty iterator returns false.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool] | None</code> <p>Optional function to evaluate each item.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if any element matches the predicate, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([0, 1]).any()\nTrue\n&gt;&gt;&gt; pc.Seq(range(0)).any()\nFalse\n&gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n...     return x % 2 == 0\n&gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def any(self, predicate: Callable[[T], bool] | None = None) -&gt; bool:\n    \"\"\"Tests if any element of the `Iterable` is truthy.\n\n    `Iter.any()` can optionally take a closure that returns true or false.\n\n    It applies this closure to each element of the `Iterable`, and if any of them return true, then so does `Iter.any()`.\n    If they all return false, it returns false.\n\n    An empty iterator returns false.\n\n    Args:\n        predicate (Callable[[T], bool] | None): Optional function to evaluate each item.\n\n    Returns:\n        bool: True if any element matches the predicate, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([0, 1]).any()\n    True\n    &gt;&gt;&gt; pc.Seq(range(0)).any()\n    False\n    &gt;&gt;&gt; def is_even(x: int) -&gt; bool:\n    ...     return x % 2 == 0\n    &gt;&gt;&gt; pc.Seq([1, 3, 4]).any(is_even)\n    True\n\n    ```\n    \"\"\"\n    if predicate is None:\n        return any(self.__iter__())\n    return any(predicate(x) for x in self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.first","level":2,"title":"<code>first()</code>","text":"<p>Return the first element of the <code>Iterable</code>.</p> <p>This is similar to <code>__getitem__</code> but works on lazy <code>Iterators</code>.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The first element of the <code>Iterable</code>.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9]).first()\n9\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def first(self) -&gt; T:\n    \"\"\"Return the first element of the `Iterable`.\n\n    This is similar to `__getitem__` but works on lazy `Iterators`.\n\n    Returns:\n        T: The first element of the `Iterable`.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9]).first()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.first(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.iter","level":2,"title":"<code>iter()</code>","text":"<p>Get an <code>Iter</code> over the <code>Iterable</code>.</p> <p>Call this to switch to lazy evaluation.</p> Note <p>Calling this method on a class who is itself an <code>Iterator</code> has no effect.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> over the <code>Iterable</code>. The element type is inferred from the actual subclass.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; seq = pc.Seq([1, 2, 3])\n&gt;&gt;&gt; iterator = seq.iter()\n&gt;&gt;&gt; iterator.collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; # iterator is now empty\n&gt;&gt;&gt; iterator.collect()\nSeq()\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def iter(self) -&gt; Iter[T]:\n    \"\"\"Get an `Iter` over the `Iterable`.\n\n    Call this to switch to lazy evaluation.\n\n    Note:\n        Calling this method on a class who is itself an `Iterator` has no effect.\n\n    Returns:\n        Iter[T]: An `Iterator` over the `Iterable`. The element type is inferred from the actual subclass.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; seq = pc.Seq([1, 2, 3])\n    &gt;&gt;&gt; iterator = seq.iter()\n    &gt;&gt;&gt; iterator.collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; # iterator is now empty\n    &gt;&gt;&gt; iterator.collect()\n    Seq()\n\n    ```\n    \"\"\"\n    from .._iter import Iter\n\n    return Iter(self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.join","level":2,"title":"<code>join(sep)</code>","text":"<p>Join all elements of the <code>Iterable</code> into a single <code>str</code>, with a specified separator.</p> <p>Parameters:</p> Name Type Description Default <code>sep</code> <code>str</code> <p>Separator to use between elements.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The joined string.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n'a-b-c'\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def join(self: PyoIterable[str], sep: str) -&gt; str:\n    \"\"\"Join all elements of the `Iterable` into a single `str`, with a specified separator.\n\n    Args:\n        sep (str): Separator to use between elements.\n\n    Returns:\n        str: The joined string.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([\"a\", \"b\", \"c\"]).join(\"-\")\n    'a-b-c'\n\n    ```\n    \"\"\"\n    return sep.join(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.last","level":2,"title":"<code>last()</code>","text":"<p>Return the last element of the <code>Iterable</code>.</p> <p>This is similar to <code>__getitem__</code> but works on lazy <code>Iterators</code>.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The last element of the <code>Iterable</code>.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n9\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def last(self) -&gt; T:\n    \"\"\"Return the last element of the `Iterable`.\n\n    This is similar to `__getitem__` but works on lazy `Iterators`.\n\n    Returns:\n        T: The last element of the `Iterable`.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([7, 8, 9]).last()\n    9\n\n    ```\n    \"\"\"\n    return cz.itertoolz.last(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.length","level":2,"title":"<code>length()</code>","text":"<p>Return the length of the <code>Iterable</code>.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The count of elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).length()\n2\n&gt;&gt;&gt; pc.Iter(range(5)).length()\n5\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def length(self) -&gt; int:\n    \"\"\"Return the length of the `Iterable`.\n\n    Returns:\n        int: The count of elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).length()\n    2\n    &gt;&gt;&gt; pc.Iter(range(5)).length()\n    5\n\n    ```\n    \"\"\"\n    return cz.itertoolz.count(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.max","level":2,"title":"<code>max()</code>","text":"<p>Return the maximum element of the <code>Iterable</code>.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>max_by()</code> instead.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The maximum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n3\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def max[U: SupportsRichComparison[Any]](self: PyoIterable[U]) -&gt; U:\n    \"\"\"Return the maximum element of the `Iterable`.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `max_by()` instead.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Returns:\n        U: The maximum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).max()\n    3\n\n    ```\n    \"\"\"\n    return max(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.max_by","level":2,"title":"<code>max_by(*, key)</code>","text":"<p>Return the maximum element of the <code>Iterable</code> using a custom key function.</p> <p>If multiple elements are tied for the maximum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the maximum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=4, y='c')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\nFoo(x=3, y='b')\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def max_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the maximum element of the `Iterable` using a custom **key** function.\n\n    If multiple elements are tied for the maximum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the maximum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(4, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=4, y='c')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(3, \"b\"), Foo(3, \"c\")]).max_by(key=lambda f: f.x)\n    Foo(x=3, y='b')\n\n    ```\n    \"\"\"\n    return max(self.__iter__(), key=key)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.min","level":2,"title":"<code>min()</code>","text":"<p>Return the minimum of the <code>Iterable</code>.</p> <p>The elements of the <code>Iterable</code> must support comparison operations.</p> <p>For comparing elements using a custom key function, use <code>min_by()</code> instead.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The minimum value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n1\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def min[U: SupportsRichComparison[Any]](self: PyoIterable[U]) -&gt; U:\n    \"\"\"Return the minimum of the `Iterable`.\n\n    The elements of the `Iterable` must support comparison operations.\n\n    For comparing elements using a custom **key** function, use `min_by()` instead.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Returns:\n        U: The minimum value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([3, 1, 2]).min()\n    1\n\n    ```\n    \"\"\"\n    return min(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.min_by","level":2,"title":"<code>min_by(*, key)</code>","text":"<p>Return the minimum element of the <code>Iterable</code> using a custom key function.</p> <p>If multiple elements are tied for the minimum value, the first one encountered is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U]</code> <p>Function to extract a comparison key from each element.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The element with the minimum key value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; from dataclasses import dataclass\n&gt;&gt;&gt; @dataclass\n... class Foo:\n...     x: int\n...     y: str\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n&gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\nFoo(x=1, y='b')\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def min_by[U: SupportsRichComparison[Any]](self, *, key: Callable[[T], U]) -&gt; T:\n    \"\"\"Return the minimum element of the `Iterable` using a custom **key** function.\n\n    If multiple elements are tied for the minimum value, the first one encountered is returned.\n\n    Args:\n        key (Callable[[T], U]): Function to extract a comparison key from each element.\n\n    Returns:\n        T: The element with the minimum key value.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; from dataclasses import dataclass\n    &gt;&gt;&gt; @dataclass\n    ... class Foo:\n    ...     x: int\n    ...     y: str\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(4, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n    &gt;&gt;&gt; pc.Seq([Foo(2, \"a\"), Foo(1, \"b\"), Foo(1, \"c\")]).min_by(key=lambda f: f.x)\n    Foo(x=1, y='b')\n\n    ```\n    \"\"\"\n    return min(self.__iter__(), key=key)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.new","level":2,"title":"<code>new()</code>  <code>classmethod</code>","text":"<p>Create an empty <code>Iterable</code>.</p> <p>Make sure to specify the type when calling this method, e.g., <code>Vec[int].new()</code>.</p> <p>Otherwise, <code>T</code> will be inferred as <code>Any</code>.</p> <p>This can be very useful for mutable collections like <code>Vec</code> and <code>Dict</code>.</p> <p>However, this can be handy for immutable collections too, for example for representing failure steps in a pipeline.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new empty <code>Iterable</code> instance.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Vec[int].new()\n&gt;&gt;&gt; data\nVec()\n&gt;&gt;&gt; # Equivalent to\n&gt;&gt;&gt; data: list[str] = []\n&gt;&gt;&gt; data\n[]\n&gt;&gt;&gt; my_dict = pc.Dict[str, int].new()\n&gt;&gt;&gt; my_dict.insert(\"a\", 1)\nNONE\n&gt;&gt;&gt; my_dict\nDict('a': 1)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>@classmethod\ndef new(cls) -&gt; Self:\n    \"\"\"Create an empty `Iterable`.\n\n    Make sure to specify the type when calling this method, e.g., `Vec[int].new()`.\n\n    Otherwise, `T` will be inferred as `Any`.\n\n    This can be very useful for mutable collections like `Vec` and `Dict`.\n\n    However, this can be handy for immutable collections too, for example for representing failure steps in a pipeline.\n\n    Returns:\n        Self: A new empty `Iterable` instance.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Vec[int].new()\n    &gt;&gt;&gt; data\n    Vec()\n    &gt;&gt;&gt; # Equivalent to\n    &gt;&gt;&gt; data: list[str] = []\n    &gt;&gt;&gt; data\n    []\n    &gt;&gt;&gt; my_dict = pc.Dict[str, int].new()\n    &gt;&gt;&gt; my_dict.insert(\"a\", 1)\n    NONE\n    &gt;&gt;&gt; my_dict\n    Dict('a': 1)\n\n    ```\n    \"\"\"\n    return cls(())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.second","level":2,"title":"<code>second()</code>","text":"<p>Return the second element of the <code>Iterable</code>.</p> <p>This is similar to <code>__getitem__</code> but works on lazy <code>Iterators</code>.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The second element of the <code>Iterable</code>.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([9, 8]).second()\n8\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def second(self) -&gt; T:\n    \"\"\"Return the second element of the `Iterable`.\n\n    This is similar to `__getitem__` but works on lazy `Iterators`.\n\n    Returns:\n        T: The second element of the `Iterable`.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([9, 8]).second()\n    8\n\n    ```\n    \"\"\"\n    return cz.itertoolz.second(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterable/#pyochain.traits._iterable.PyoIterable.sum","level":2,"title":"<code>sum()</code>","text":"<p>Return the sum of the <code>Iterable</code>.</p> <p>If the <code>Iterable</code> is empty, return 0.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The sum of all elements.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n6\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def sum[U: int | bool](self: PyoIterable[U]) -&gt; int:\n    \"\"\"Return the sum of the `Iterable`.\n\n    If the `Iterable` is empty, return 0.\n\n    Returns:\n        int: The sum of all elements.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).sum()\n    6\n\n    ```\n    \"\"\"\n    return sum(self.__iter__())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterable"],"tags":[]},{"location":"reference/pyoiterator/","level":1,"title":"PyoIterator","text":"<p>               Bases: <code>PyoIterable[T]</code>, <code>Iterator[T]</code></p> <p>Base trait for lazy <code>Iterator</code> classes.</p> <p>Pyochain's <code>Iter[T]</code> implements this trait. This trait extends <code>PyoIterable[T]</code> and <code>collections.abc.Iterator[T]</code>, providing additional methods for working with lazy sequences.</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoIterator[T](PyoIterable[T], Iterator[T]):\n    \"\"\"Base trait for lazy `Iterator` classes.\n\n    Pyochain's `Iter[T]` implements this trait.\n    This trait extends `PyoIterable[T]` and `collections.abc.Iterator[T]`, providing\n    additional methods for working with lazy sequences.\n    \"\"\"\n\n    __slots__ = ()\n\n    def nth(self, n: int) -&gt; Option[T]:\n        \"\"\"Return the nth item of the `Iterable` at the specified *n*.\n\n        This is similar to `__getitem__` but for lazy `Iterators`.\n\n        If *n* is out of bounds, returns `NONE`.\n\n        Args:\n            n (int): The index of the item to retrieve.\n\n        Returns:\n            Option[T]: `Some(item)` at the specified *n*.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([10, 20]).nth(1)\n        Some(20)\n        &gt;&gt;&gt; pc.Iter([10, 20]).nth(3)\n        NONE\n\n        ```\n        \"\"\"\n        try:\n            return Some(next(itertools.islice(self.__iter__(), n, n + 1)))\n        except StopIteration:\n            return NONE\n\n    def eq(self, other: Iterable[T]) -&gt; bool:\n        \"\"\"Check if two `Iterable`s are equal based on their data.\n\n        Note:\n            This will consume any `Iterator` instances involved in the comparison (**self** and/or **other**).\n\n        Args:\n            other (Iterable[T]): Another instance of `Iterable[T]` to compare against.\n\n        Returns:\n            bool: `True` if the underlying data are equal, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\n        True\n        &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\n        False\n        &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\n        False\n        &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Vec([1,2,3]))\n        True\n\n        ```\n        \"\"\"\n        return tls.eq(self.__iter__(), other)\n\n    def ne(self, other: Iterable[T]) -&gt; bool:\n        \"\"\"Check if this `Iterator` and *other* are not equal based on their data.\n\n        Args:\n            other (Iterable[T]): Another instance of `Iterable[T]` to compare against.\n\n        Returns:\n            bool: `True` if the underlying data are not equal, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\n        False\n        &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Seq([1,2]))\n        True\n        &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\n        True\n        &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Vec([1,2,3]))\n        False\n\n        ```\n        \"\"\"\n        return tls.ne(self.__iter__(), other)\n\n    def le(self, other: Iterable[T]) -&gt; bool:\n        \"\"\"Check if this `Iterator` is less than or equal to *other* based on their data.\n\n        Args:\n            other (Iterable[T]): Another instance of `Iterable[T]` to compare against.\n\n        Returns:\n            bool: `True` if the underlying data of self is less than or equal to that of other, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1,2)).le(pc.Seq((1,2,3)))\n        True\n        &gt;&gt;&gt; pc.Iter((1,2,3)).le(pc.Seq((1,2)))\n        False\n\n        ```\n        \"\"\"\n        return tls.le(self.__iter__(), other)\n\n    def lt(self, other: Iterable[T]) -&gt; bool:\n        \"\"\"Check if this `Iterator` is less than *other* based on their data.\n\n        Args:\n            other (Iterable[T]): Another `Iterable[T]` to compare against.\n\n        Returns:\n            bool: `True` if the underlying data of self is less than that of other, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1,2)).lt(pc.Seq((1,2,3)))\n        True\n        &gt;&gt;&gt; pc.Iter((1,2,3)).lt(pc.Seq((1,2)))\n        False\n\n        ```\n        \"\"\"\n        return tls.lt(self.__iter__(), other)\n\n    def gt(self, other: Iterable[T]) -&gt; bool:\n        \"\"\"Check if this `Iterator` is greater than *other* based on their data.\n\n        Args:\n            other (Iterable[T]): Another `Iterable[T]` to compare against.\n\n        Returns:\n            bool: `True` if the underlying data of **self** is greater than that of **other**, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1,2,3)).gt((1,2))\n        True\n        &gt;&gt;&gt; pc.Iter((1,2)).gt((1,2,3))\n        False\n\n        ```\n        \"\"\"\n        return tls.gt(self.__iter__(), other)\n\n    def ge(self, other: Iterable[T]) -&gt; bool:\n        \"\"\"Check if this `Iterator` is greater than or equal to *other* based on their data.\n\n        Args:\n            other (Iterable[T]): Another `Iterable[T]` to compare against.\n\n        Returns:\n            bool: `True` if the underlying data of **self** is greater than or equal to that of **other**, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1,2,3)).ge((1,2))\n        True\n        &gt;&gt;&gt; pc.Iter((1,2)).ge((1,2,3))\n        False\n\n        ```\n        \"\"\"\n        return tls.ge(self.__iter__(), other)\n\n    def next(self) -&gt; Option[T]:\n        \"\"\"Return the next element in the `Iterator`.\n\n        Note:\n            The actual `.__next__()` method must be conform to the Python `Iterator` Protocol, and is what will be actually called if you iterate over the `PyoIterator` instance.\n\n            `PyoIterator.next()` is a convenience method that wraps the result in an `Option` to handle exhaustion gracefully, for custom use cases.\n\n        Returns:\n            Option[T]: The next element in the iterator. `Some[T]`, or `NONE` if the iterator is exhausted.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; it = pc.Seq([1, 2, 3]).iter()\n        &gt;&gt;&gt; it.next().unwrap()\n        1\n        &gt;&gt;&gt; it.next().unwrap()\n        2\n\n        ```\n        \"\"\"\n        return Option(next(self, None))\n\n    def reduce(self, func: Callable[[T, T], T]) -&gt; T:\n        \"\"\"Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n        Args:\n            func (Callable[[T, T], T]): Function to apply cumulatively to the items of the iterable.\n\n        Returns:\n            T: Single value resulting from cumulative reduction.\n\n        This effectively reduces the `Iterator` to a single value.\n\n        If initial is present, it is placed before the items of the `Iterator` in the calculation.\n\n        It then serves as a default when the `Iterator` is empty.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).reduce(lambda a, b: a + b)\n        6\n\n        ```\n        \"\"\"\n        return functools.reduce(func, self)\n\n    def fold[B](self, init: B, func: Callable[[B, T], B]) -&gt; B:\n        \"\"\"Fold every element of the `Iterator` into an accumulator by applying an operation, returning the final result.\n\n        Args:\n            init (B): Initial value for the accumulator.\n            func (Callable[[B, T], B]): Function that takes the accumulator and current element,\n                returning the new accumulator value.\n\n        Returns:\n            B: The final accumulated value.\n\n        Note:\n            This is similar to `reduce()` but with an initial value, making it equivalent to\n            Python `functools.reduce()` with an initializer.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n        6\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n        16\n        &gt;&gt;&gt; pc.Iter(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n        'abc'\n\n        ```\n        \"\"\"\n        return functools.reduce(func, self, init)\n\n    def find(self, predicate: Callable[[T], bool]) -&gt; Option[T]:\n        \"\"\"Searches for an element of an iterator that satisfies a `predicate`.\n\n        Takes a closure that returns true or false as `predicate`, and applies it to each element of the iterator.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to evaluate each item.\n\n        Returns:\n            Option[T]: The first element satisfying the predicate. `Some(value)` if found, `NONE` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n        ...     return x &gt; 5\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n        ...     return x &gt; 9\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(range(10)).find(predicate=gt_five)\n        Some(6)\n        &gt;&gt;&gt; pc.Iter(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n        'missing'\n\n        ```\n        \"\"\"\n        return Option(next(filter(predicate, self), None))\n\n    def try_find[E](\n        self, predicate: Callable[[T], Result[bool, E]]\n    ) -&gt; Result[Option[T], E]:\n        \"\"\"Applies a function returning `Result[bool, E]` to find first matching element.\n\n        Short-circuits: stops at the first successful `True` or on the first error.\n\n        Args:\n            predicate (Callable[[T], Result[bool, E]]): Function returning a `Result[bool, E]`.\n\n        Returns:\n            Result[Option[T], E]: The first matching element, or the first error.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def is_even(x: int) -&gt; pc.Result[bool, str]:\n        ...     return pc.Ok(x % 2 == 0) if x &gt;= 0 else pc.Err(\"negative number\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter(range(1, 6)).try_find(is_even)\n        Ok(Some(2))\n\n        ```\n        \"\"\"\n        return tls.try_find(self.__iter__(), predicate)\n\n    def try_fold[B, E](\n        self, init: B, func: Callable[[B, T], Result[B, E]]\n    ) -&gt; Result[B, E]:\n        \"\"\"Folds every element into an accumulator, short-circuiting on error.\n\n        Applies **func** cumulatively to items and the accumulator.\n\n        If **func** returns an error, stops and returns that error.\n\n        Args:\n            init (B): Initial accumulator value.\n            func (Callable[[B, T], Result[B, E]]): Function that takes the accumulator and element, returns a `Result[B, E]`.\n\n        Returns:\n            Result[B, E]: Final accumulator or the first error.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def checked_add(acc: int, x: int) -&gt; pc.Result[int, str]:\n        ...     new_val = acc + x\n        ...     if new_val &gt; 100:\n        ...         return pc.Err(\"overflow\")\n        ...     return pc.Ok(new_val)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).try_fold(0, checked_add)\n        Ok(6)\n        &gt;&gt;&gt; pc.Iter([50, 40, 20]).try_fold(0, checked_add)\n        Err('overflow')\n        &gt;&gt;&gt; pc.Iter([]).try_fold(0, checked_add)\n        Ok(0)\n\n        ```\n        \"\"\"\n        return tls.try_fold(self.__iter__(), init, func)\n\n    def try_reduce[E](\n        self, func: Callable[[T, T], Result[T, E]]\n    ) -&gt; Result[Option[T], E]:\n        \"\"\"Reduces elements to a single one, short-circuiting on error.\n\n        Uses the first element as the initial accumulator. If **func** returns an error, stops immediately.\n\n        Args:\n            func (Callable[[T, T], Result[T, E]]): Function that reduces two items, returns a `Result[T, E]`.\n\n        Returns:\n            Result[Option[T], E]: Final accumulated value or the first error. Returns `Ok(NONE)` for empty iterable.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def checked_add(x: int, y: int) -&gt; pc.Result[int, str]:\n        ...     if x + y &gt; 100:\n        ...         return pc.Err(\"overflow\")\n        ...     return pc.Ok(x + y)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).try_reduce(checked_add)\n        Ok(Some(6))\n        &gt;&gt;&gt; pc.Iter([50, 60]).try_reduce(checked_add)\n        Err('overflow')\n        &gt;&gt;&gt; pc.Iter([]).try_reduce(checked_add)\n        Ok(NONE)\n\n        ```\n        \"\"\"\n        return tls.try_reduce(self.__iter__(), func)\n\n    def is_sorted[U: SupportsComparison[Any]](\n        self: PyoIterator[U], *, reverse: bool = False, strict: bool = False\n    ) -&gt; bool:\n        \"\"\"Returns `True` if the items of the `Iterator` are in sorted order.\n\n        The elements of the `Iterator` must support comparison operations.\n\n        The function returns `False` after encountering the first out-of-order item.\n\n        If there are no out-of-order items, the `Iterator` is exhausted.\n\n        Credits to **more-itertools** for the implementation.\n\n        See Also:\n            - `is_sorted_by()`: If your elements do not support comparison operations directly, or you want to sort based on a specific attribute or transformation.\n\n        Args:\n            reverse (bool): Whether to check for descending order.\n            strict (bool): Whether to enforce strict sorting (no equal elements).\n\n        Returns:\n            bool: `True` if items are sorted according to the criteria, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).is_sorted()\n        True\n\n        ```\n        If strict, tests for strict sorting, that is, returns False if equal elements are found:\n        ```python\n        &gt;&gt;&gt; pc.Iter([1, 2, 2]).is_sorted()\n        True\n        &gt;&gt;&gt; pc.Iter([1, 2, 2]).is_sorted(strict=True)\n        False\n\n        ```\n\n        \"\"\"\n        return tls.is_sorted(self.__iter__(), reverse=reverse, strict=strict)\n\n    def is_sorted_by(\n        self,\n        key: Callable[[T], SupportsComparison[Any]],\n        *,\n        reverse: bool = False,\n        strict: bool = False,\n    ) -&gt; bool:\n        \"\"\"Returns `True` if the items of the `Iterator` are in sorted order according to the key function.\n\n        The function returns `False` after encountering the first out-of-order item.\n\n        If there are no out-of-order items, the `Iterator` is exhausted.\n\n        Credits to **more-itertools** for the implementation.\n\n        Args:\n            key (Callable[[T], SupportsComparison[Any]]): Function to extract a comparison key from each element.\n            reverse (bool): Whether to check for descending order.\n            strict (bool): Whether to enforce strict sorting (no equal elements).\n\n        Returns:\n            bool: `True` if items are sorted according to the criteria, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted_by(int)\n        True\n        &gt;&gt;&gt; pc.Iter([\"5\", \"4\", \"3\", \"1\", \"2\"]).is_sorted_by(int, reverse=True)\n        False\n\n        ```\n        If strict, tests for strict sorting, that is, returns False if equal elements are found:\n        ```python\n        &gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"2\"]).is_sorted_by(int)\n        True\n        &gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"2\"]).is_sorted_by(key=int, strict=True)\n        False\n\n        ```\n        \"\"\"\n        return tls.is_sorted_by(self.__iter__(), key, reverse=reverse, strict=strict)\n\n    def all_equal[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n        \"\"\"Return `True` if all items of the `Iterator` are equal.\n\n        A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n        Credits to **more-itertools** for the implementation.\n\n        Args:\n            key (Callable[[T], U] | None): Function to transform items before comparison.\n\n        Returns:\n            bool: `True` if all items are equal, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"AaaA\").all_equal(key=str.casefold)\n        True\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\n        True\n\n        ```\n        \"\"\"\n        iterator = itertools.groupby(self.__iter__(), key)\n        for _first in iterator:\n            for _second in iterator:\n                return False\n            return True\n        return True\n\n    def all_unique[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n        \"\"\"Returns True if all the elements of iterable are unique.\n\n        The function returns as soon as the first non-unique element is encountered.\n\n        `Iters` with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items.\n\n        A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n        Credits to **more-itertools** for the implementation.\n\n        Args:\n            key (Callable[[T], U] | None): Function to transform items before comparison.\n\n        Returns:\n            bool: `True` if all elements are unique, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"ABCB\").all_unique()\n        False\n        &gt;&gt;&gt; pc.Iter(\"ABCb\").all_unique()\n        True\n        &gt;&gt;&gt; pc.Iter(\"ABCb\").all_unique(str.lower)\n        False\n\n        ```\n        \"\"\"\n        seenset: set[T | U] = set()\n        seenset_add = seenset.add\n        seenlist: list[T | U] = []\n        seenlist_add = seenlist.append\n        for element in map(key, self.__iter__()) if key else self.__iter__():\n            try:\n                if element in seenset:\n                    return False\n                seenset_add(element)\n            except TypeError:\n                if element in seenlist:\n                    return False\n                seenlist_add(element)\n        return True\n\n    def argmax[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n        \"\"\"Index of the first occurrence of a maximum value in the `Iterator`.\n\n        A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n        Credits to more-itertools for the implementation.\n\n        Args:\n            key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n        Returns:\n            int: The index of the maximum value.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"abcdefghabcd\").argmax()\n        7\n        &gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n        3\n\n        ```\n        For example, identify the best machine learning model:\n        ```python\n        &gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n        &gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n        &gt;&gt;&gt; # Most accurate model\n        &gt;&gt;&gt; models.get(accuracy.iter().argmax()).unwrap()\n        'knn'\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Best accuracy\n        &gt;&gt;&gt; accuracy.max()\n        84\n\n        ```\n        \"\"\"\n        it = self.__iter__()\n        if key is not None:\n            it = map(key, it)\n        return max(enumerate(it), key=itemgetter(1))[0]\n\n    def argmin[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n        \"\"\"Index of the first occurrence of a minimum value in the `Iterator`.\n\n        A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n        Credits to more-itertools for the implementation.\n\n        Args:\n            key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n        Returns:\n            int: The index of the minimum value.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Example 1: Basic usage\n        &gt;&gt;&gt; pc.Iter(\"efghabcdijkl\").argmin()\n        4\n        &gt;&gt;&gt; pc.Iter([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n        3\n        &gt;&gt;&gt; # Example 2: look up a label corresponding to the position of a value that minimizes a cost function\n        &gt;&gt;&gt; def cost(x: int) -&gt; float:\n        ...     \"Days for a wound to heal given a subject's age.\"\n        ...     return x**2 - 20 * x + 150\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n        &gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n        &gt;&gt;&gt; # Fastest healing family member\n        &gt;&gt;&gt; labels.get(ages.iter().argmin(key=cost)).unwrap()\n        'bart'\n        &gt;&gt;&gt; # Age with fastest healing\n        &gt;&gt;&gt; ages.min_by(key=cost)\n        10\n\n        ```\n        \"\"\"\n        it = self.__iter__()\n        if key is not None:\n            it = map(key, it)\n        return min(enumerate(it), key=itemgetter(1))[0]\n\n    def take_while(self, predicate: Callable[[T], bool]) -&gt; Self:\n        \"\"\"Take items while predicate holds.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to evaluate each item.\n\n        Returns:\n            Self: An `Iterator` of the items taken while the predicate is true.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 0)).take_while(lambda x: x &gt; 0).collect()\n        Seq(1, 2)\n\n        ```\n        \"\"\"\n        return self.__class__(itertools.takewhile(predicate, self.__iter__()))\n\n    def skip_while(self, predicate: Callable[[T], bool]) -&gt; Self:\n        \"\"\"Drop items while predicate holds.\n\n        Args:\n            predicate (Callable[[T], bool]): Function to evaluate each item.\n\n        Returns:\n            Self: An `Iterator` of the items after skipping those for which the predicate is true.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 0)).skip_while(lambda x: x &gt; 0).collect()\n        Seq(0,)\n\n        ```\n        \"\"\"\n        return self.__class__(itertools.dropwhile(predicate, self.__iter__()))\n\n    def compress(self, *selectors: bool) -&gt; Self:\n        \"\"\"Filter elements using a boolean selector iterable.\n\n        Args:\n            *selectors (bool): Boolean values indicating which elements to keep.\n\n        Returns:\n            Self: An `Iterator` of the items selected by the boolean selectors.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"ABCDEF\").compress(1, 0, 1, 0, 1, 1).collect()\n        Seq('A', 'C', 'E', 'F')\n\n        ```\n        \"\"\"\n        return self.__class__(itertools.compress(self.__iter__(), selectors))\n\n    def unique(self, key: Callable[[T], Any] | None = None) -&gt; Self:\n        \"\"\"Return only unique elements of the iterable.\n\n        Args:\n            key (Callable[[T], Any] | None): Function to transform items before comparison.\n\n        Returns:\n            Self: An `Iterator` of the unique items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).unique().collect()\n        Seq(1, 2, 3)\n        &gt;&gt;&gt; pc.Iter([1, 2, 1, 3]).unique().collect()\n        Seq(1, 2, 3)\n\n        ```\n        Uniqueness can be defined by key keyword\n        ```python\n        &gt;&gt;&gt; pc.Iter([\"cat\", \"mouse\", \"dog\", \"hen\"]).unique(key=len).collect()\n        Seq('cat', 'mouse')\n\n        ```\n        \"\"\"\n        return self.__class__(cz.itertoolz.unique(self.__iter__(), key=key))\n\n    def take(self, n: int) -&gt; Self:\n        \"\"\"Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner.\n\n        `Iter.take(n)` yields elements until n elements are yielded or the end of the iterator is reached (whichever happens first).\n\n        The returned iterator is either:\n\n        - A prefix of length n if the original iterator contains at least n elements\n        - All of the (fewer than n) elements of the original iterator if it contains fewer than n elements.\n\n        Args:\n            n (int): Number of elements to take.\n\n        Returns:\n            Self: An `Iterator` of the first n items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = [1, 2, 3]\n        &gt;&gt;&gt; pc.Iter(data).take(2).collect()\n        Seq(1, 2)\n        &gt;&gt;&gt; pc.Iter(data).take(5).collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        return self.__class__(itertools.islice(self.__iter__(), n))\n\n    def skip(self, n: int) -&gt; Self:\n        \"\"\"Drop first n elements.\n\n        Args:\n            n (int): Number of elements to skip.\n\n        Returns:\n            Self: An `Iterator` of the items after skipping the first n items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 3)).skip(1).collect()\n        Seq(2, 3)\n\n        ```\n        \"\"\"\n        return self.__class__(cz.itertoolz.drop(n, self.__iter__()))\n\n    def step_by(self, step: int) -&gt; Self:\n        \"\"\"Creates an `Iterator` starting at the same point, but stepping by the given **step** at each iteration.\n\n        Note:\n            The first element of the iterator will always be returned, regardless of the **step** given.\n\n        Args:\n            step (int): Step size for selecting items.\n\n        Returns:\n            Self: An `Iterator` of every nth item.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 4, 5]).step_by(2).collect()\n        Seq(0, 2, 4)\n\n        ```\n        \"\"\"\n        return self.__class__(cz.itertoolz.take_nth(step, self.__iter__()))\n\n    def slice(\n        self,\n        start: int | None = None,\n        stop: int | None = None,\n        step: int | None = None,\n    ) -&gt; Self:\n        \"\"\"Return a slice of the `Iterator`.\n\n        Args:\n            start (int | None): Starting index of the slice.\n            stop (int | None): Ending index of the slice.\n            step (int | None): Step size for the slice.\n\n        Returns:\n            Self: An `Iterator` of the sliced items.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = (1, 2, 3, 4, 5)\n        &gt;&gt;&gt; pc.Iter(data).slice(1, 4).collect()\n        Seq(2, 3, 4)\n        &gt;&gt;&gt; pc.Iter(data).slice(step=2).collect()\n        Seq(1, 3, 5)\n\n        ```\n        \"\"\"\n        return self.__class__(itertools.islice(self.__iter__(), start, stop, step))\n\n    def cycle(self) -&gt; Self:\n        \"\"\"Repeat the `Iterator` indefinitely.\n\n        Warning:\n            This creates an infinite `Iterator`.\n\n            Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n        See Also:\n            `Iter.repeat()` to repeat *self* as elements (`Iter[Self]`).\n\n        Returns:\n            Self: A new `Iterator` that cycles through the elements indefinitely.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2)).cycle().take(5).collect()\n        Seq(1, 2, 1, 2, 1)\n\n        ```\n        \"\"\"\n        return self.__class__(itertools.cycle(self.__iter__()))\n\n    def intersperse(self, element: T) -&gt; Self:\n        \"\"\"Creates a new `Iterator` which places a copy of separator between adjacent items of the original iterator.\n\n        Args:\n            element (T): The element to interpose between items.\n\n        Returns:\n            Self: A new `Iterator` with the element interposed.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Simple example with numbers\n        &gt;&gt;&gt; pc.Iter([1, 2, 3]).intersperse(0).collect()\n        Seq(1, 0, 2, 0, 3)\n        &gt;&gt;&gt; # Useful when chaining with other operations\n        &gt;&gt;&gt; pc.Iter([10, 20, 30]).intersperse(5).sum()\n        70\n        &gt;&gt;&gt; # Inserting separators between groups, then flattening\n        &gt;&gt;&gt; pc.Iter([[1, 2], [3, 4], [5, 6]]).intersperse([-1]).flatten().collect()\n        Seq(1, 2, -1, 3, 4, -1, 5, 6)\n\n        ```\n        \"\"\"\n        return self.__class__(cz.itertoolz.interpose(element, self.__iter__()))\n\n    def random_sample(\n        self, probability: float, state: Random | int | None = None\n    ) -&gt; Self:\n        \"\"\"Return elements from the `Iterator` with a given *probability*.\n\n        `.random_sample()` considers each item independently and without replacement.\n\n        See below how the first time it returned 13 items and the next time it returned 6 items.\n\n        Args:\n            probability (float): The probability of including each element.\n            state (Random | int | None): Random state or seed for deterministic sampling.\n\n        Returns:\n            Self: A new `Iterator` with randomly sampled elements.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Iter(range(100)).collect()\n        &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n        Seq(6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95)\n        &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n        Seq(6, 44, 54, 61, 69, 94)\n        ```\n        Providing an integer seed for random_state will result in deterministic sampling.\n\n        Given the same seed it will return the same sample every time.\n        ```python\n        &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n        Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n        &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n        Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n        ```\n        random_state can also be any object with a method random that returns floats between 0.0 and 1.0 (exclusive).\n        ```python\n        &gt;&gt;&gt; from random import Random\n        &gt;&gt;&gt; randobj = Random(2016)\n        &gt;&gt;&gt; data.iter().random_sample(0.1, state=randobj).collect()\n        Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n        ```\n        \"\"\"\n        return self.__class__(\n            cz.itertoolz.random_sample(probability, self.__iter__(), random_state=state)\n        )\n\n    def insert(self, value: T) -&gt; Self:\n        \"\"\"Prepend the *value* to the `Iterator`.\n\n        Note:\n            This can be considered the equivalent as `list.append()`, but for a lazy `Iterator`.\n            However, append add the value at the **end**, while insert add it at the **beginning**.\n\n        See Also:\n            `Iter.chain()` to add multiple elements at the end of the `Iterator`.\n\n        Args:\n            value (T): The value to prepend.\n\n        Returns:\n            Self: A new Iterable wrapper with the value prepended.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((2, 3)).insert(1).collect()\n        Seq(1, 2, 3)\n\n        ```\n        \"\"\"\n        return self.__class__(cz.itertoolz.cons(value, self.__iter__()))\n\n    def interleave(self, *others: Iterable[T]) -&gt; Self:\n        \"\"\"Interleave multiple sequences element-wise.\n\n        Args:\n            *others (Iterable[T]): Other iterables to interleave.\n\n        Returns:\n            Self: A new Iterable wrapper with interleaved elements.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2)).interleave((3, 4)).collect()\n        Seq(1, 3, 2, 4)\n\n        ```\n        \"\"\"\n        return self.__class__(cz.itertoolz.interleave((self.__iter__(), *others)))\n\n    def chain(self, *others: Iterable[T]) -&gt; Self:\n        \"\"\"Concatenate **self** with one or more `Iterables`, any of which may be infinite.\n\n        In other words, it links **self** and **others** together, in a chain. üîó\n\n        An infinite `Iterable` will prevent the rest of the arguments from being included.\n\n        This is equivalent to `list.extend()`, except it is fully lazy and works with any `Iterable`.\n\n        See Also:\n            `Iter.insert()` to add a single element at the beginning of the `Iterator`.\n\n        Args:\n            *others (Iterable[T]): Other iterables to concatenate.\n\n        Returns:\n            Self: A new `Iterator` which will first iterate over values from the original `Iterator` and then over values from the **others** `Iterable`s.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2)).chain((3, 4), [5]).collect()\n        Seq(1, 2, 3, 4, 5)\n        &gt;&gt;&gt; pc.Iter((1, 2)).chain(pc.Iter.from_count(3)).take(5).collect()\n        Seq(1, 2, 3, 4, 5)\n\n        ```\n        \"\"\"\n        return self.__class__(cz.itertoolz.concat((self.__iter__(), *others)))\n\n    def elements(self) -&gt; Self:\n        \"\"\"Iterator over elements repeating each as many times as its count.\n\n        Note:\n            if an element's count has been set to zero or is a negative\n            number, elements() will ignore it.\n\n        Returns:\n            Self: A new `Iterator` with elements repeated according to their counts.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter(\"ABCABC\").elements().sort()\n        Vec('A', 'A', 'B', 'B', 'C', 'C')\n\n        ```\n        Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1\n        ```python\n        &gt;&gt;&gt; import math\n        &gt;&gt;&gt; data = [2, 2, 3, 3, 3, 17]\n        &gt;&gt;&gt; pc.Iter(data).elements().into(math.prod)\n        1836\n\n        ```\n        \"\"\"\n        from collections import Counter\n\n        return self.__class__(Counter(self.__iter__()).elements())\n\n    def accumulate(self, func: Callable[[T, T], T], initial: T | None = None) -&gt; Self:\n        \"\"\"Return an `Iterator` of accumulated binary function results.\n\n        In principle, `.accumulate()` is similar to `.fold()` if you provide it with the same binary function.\n\n        However, instead of returning the final accumulated result, it returns an `Iterator` that yields the current value `T` of the accumulator for each iteration.\n\n        In other words, the last element yielded by `.accumulate()` is what would have been returned by `.fold()` if it had been used instead.\n\n        Args:\n            func (Callable[[T, T], T]): A binary function to apply cumulatively.\n            initial (T | None): Optional initial value to start the accumulation.\n\n        Returns:\n            Self: A new `Iterator` with accumulated results.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a + b, 0).collect()\n        Seq(0, 1, 3, 6)\n        &gt;&gt;&gt; # The final accumulated result is the same as fold:\n        &gt;&gt;&gt; pc.Iter((1,2,3)).fold(0, lambda a, b: a + b)\n        6\n        &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a * b).collect()\n        Seq(1, 2, 6)\n\n        ```\n        \"\"\"\n        return self.__class__(\n            itertools.accumulate(self.__iter__(), func, initial=initial)\n        )\n\n    def for_each[**P](\n        self,\n        func: Callable[Concatenate[T, P], Any],\n        *args: P.args,\n        **kwargs: P.kwargs,\n    ) -&gt; None:\n        \"\"\"Consume the `Iterator` by applying a function to each element in the `Iterable`.\n\n        Is a terminal operation, and is useful for functions that have side effects,\n        or when you want to force evaluation of a lazy iterable.\n\n        Args:\n            func (Callable[Concatenate[T, P], Any]): Function to apply to each element.\n            *args (P.args): Positional arguments for the function.\n            **kwargs (P.kwargs): Keyword arguments for the function.\n\n        Returns:\n            None: This is a terminal operation with no return value.\n\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).iter().for_each(lambda x: print(x + 1))\n        2\n        3\n        4\n\n        ```\n        \"\"\"\n        for v in self.__iter__():\n            func(v, *args, **kwargs)\n\n    @overload\n    def for_each_star[R](\n        self: PyoIterator[tuple[Any]],\n        func: Callable[[Any], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, R](\n        self: PyoIterator[tuple[T1, T2]],\n        func: Callable[[T1, T2], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, R](\n        self: PyoIterator[tuple[T1, T2, T3]],\n        func: Callable[[T1, T2, T3], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, R](\n        self: PyoIterator[tuple[T1, T2, T3, T4]],\n        func: Callable[[T1, T2, T3, T4], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, R](\n        self: PyoIterator[tuple[T1, T2, T3, T4, T5]],\n        func: Callable[[T1, T2, T3, T4, T5], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, R](\n        self: PyoIterator[tuple[T1, T2, T3, T4, T5, T6]],\n        func: Callable[[T1, T2, T3, T4, T5, T6], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, R](\n        self: PyoIterator[tuple[T1, T2, T3, T4, T5, T6, T7]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, T8, R](\n        self: PyoIterator[tuple[T1, T2, T3, T4, T5, T6, T7, T8]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, R](\n        self: PyoIterator[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n    ) -&gt; None: ...\n    @overload\n    def for_each_star[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R](\n        self: PyoIterator[tuple[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]],\n        func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R],\n    ) -&gt; None: ...\n    def for_each_star[U: Iterable[Any], R](\n        self: PyoIterator[U],\n        func: Callable[..., R],\n    ) -&gt; None:\n        \"\"\"Consume the `Iterator` by applying a function to each unpacked item in the `Iterable` element.\n\n        Is a terminal operation, and is useful for functions that have side effects,\n        or when you want to force evaluation of a lazy iterable.\n\n        Each item yielded by the `Iterator` is expected to be an `Iterable` itself (e.g., a tuple or list),\n        and its elements are unpacked as arguments to the provided function.\n\n        This is often used after methods like `zip()` or `enumerate()` that yield tuples.\n\n        Args:\n            func (Callable[..., R]): Function to apply to each unpacked element.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Iter([(1, 2), (3, 4)]).for_each_star(lambda x, y: print(x + y))\n        3\n        7\n\n        ```\n        \"\"\"\n        for item in self.__iter__():\n            func(*item)\n\n    def try_for_each[E](self, f: Callable[[T], Result[Any, E]]) -&gt; Result[None, E]:\n        \"\"\"Applies a fallible function to each item in the `Iterator`, stopping at the first error and returning that error.\n\n        This can also be thought of as the fallible form of `.for_each()`.\n\n        Args:\n            f (Callable[[T], Result[Any, E]]): A function that takes an item of type `T` and returns a `Result`.\n\n        Returns:\n            Result[None, E]: Returns `Ok(None)` if all applications of **f** were successful (i.e., returned `Ok`), or the first error `E` encountered.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; def validate_positive(n: int) -&gt; pc.Result[None, str]:\n        ...     if n &gt; 0:\n        ...         return pc.Ok(None)\n        ...     return pc.Err(f\"Value {n} is not positive\")\n        &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).try_for_each(validate_positive)\n        Ok(None)\n        &gt;&gt;&gt; # Short-circuit on first error:\n        &gt;&gt;&gt; pc.Iter([1, 2, -1, 4]).try_for_each(validate_positive)\n        Err('Value -1 is not positive')\n\n        ```\n        \"\"\"\n        for item in self.__iter__():\n            res = f(item)\n            if res.is_err():\n                return res\n        return Ok(None)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.accumulate","level":2,"title":"<code>accumulate(func, initial=None)</code>","text":"<p>Return an <code>Iterator</code> of accumulated binary function results.</p> <p>In principle, <code>.accumulate()</code> is similar to <code>.fold()</code> if you provide it with the same binary function.</p> <p>However, instead of returning the final accumulated result, it returns an <code>Iterator</code> that yields the current value <code>T</code> of the accumulator for each iteration.</p> <p>In other words, the last element yielded by <code>.accumulate()</code> is what would have been returned by <code>.fold()</code> if it had been used instead.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>A binary function to apply cumulatively.</p> required <code>initial</code> <code>T | None</code> <p>Optional initial value to start the accumulation.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Iterator</code> with accumulated results.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a + b, 0).collect()\nSeq(0, 1, 3, 6)\n&gt;&gt;&gt; # The final accumulated result is the same as fold:\n&gt;&gt;&gt; pc.Iter((1,2,3)).fold(0, lambda a, b: a + b)\n6\n&gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a * b).collect()\nSeq(1, 2, 6)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def accumulate(self, func: Callable[[T, T], T], initial: T | None = None) -&gt; Self:\n    \"\"\"Return an `Iterator` of accumulated binary function results.\n\n    In principle, `.accumulate()` is similar to `.fold()` if you provide it with the same binary function.\n\n    However, instead of returning the final accumulated result, it returns an `Iterator` that yields the current value `T` of the accumulator for each iteration.\n\n    In other words, the last element yielded by `.accumulate()` is what would have been returned by `.fold()` if it had been used instead.\n\n    Args:\n        func (Callable[[T, T], T]): A binary function to apply cumulatively.\n        initial (T | None): Optional initial value to start the accumulation.\n\n    Returns:\n        Self: A new `Iterator` with accumulated results.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a + b, 0).collect()\n    Seq(0, 1, 3, 6)\n    &gt;&gt;&gt; # The final accumulated result is the same as fold:\n    &gt;&gt;&gt; pc.Iter((1,2,3)).fold(0, lambda a, b: a + b)\n    6\n    &gt;&gt;&gt; pc.Iter((1, 2, 3)).accumulate(lambda a, b: a * b).collect()\n    Seq(1, 2, 6)\n\n    ```\n    \"\"\"\n    return self.__class__(\n        itertools.accumulate(self.__iter__(), func, initial=initial)\n    )\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.all_equal","level":2,"title":"<code>all_equal(key=None)</code>","text":"<p>Return <code>True</code> if all items of the <code>Iterator</code> are equal.</p> <p>A function that accepts a single argument and returns a transformed version of each input item can be specified with key.</p> <p>Credits to more-itertools for the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if all items are equal, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"AaaA\").all_equal(key=str.casefold)\nTrue\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\nTrue\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def all_equal[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Return `True` if all items of the `Iterator` are equal.\n\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n    Credits to **more-itertools** for the implementation.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison.\n\n    Returns:\n        bool: `True` if all items are equal, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"AaaA\").all_equal(key=str.casefold)\n    True\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).all_equal(key=lambda x: x &lt; 10)\n    True\n\n    ```\n    \"\"\"\n    iterator = itertools.groupby(self.__iter__(), key)\n    for _first in iterator:\n        for _second in iterator:\n            return False\n        return True\n    return True\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.all_unique","level":2,"title":"<code>all_unique(key=None)</code>","text":"<p>Returns True if all the elements of iterable are unique.</p> <p>The function returns as soon as the first non-unique element is encountered.</p> <p><code>Iters</code> with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items.</p> <p>A function that accepts a single argument and returns a transformed version of each input item can be specified with key.</p> <p>Credits to more-itertools for the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Function to transform items before comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if all elements are unique, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"ABCB\").all_unique()\nFalse\n&gt;&gt;&gt; pc.Iter(\"ABCb\").all_unique()\nTrue\n&gt;&gt;&gt; pc.Iter(\"ABCb\").all_unique(str.lower)\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def all_unique[U](self, key: Callable[[T], U] | None = None) -&gt; bool:\n    \"\"\"Returns True if all the elements of iterable are unique.\n\n    The function returns as soon as the first non-unique element is encountered.\n\n    `Iters` with a mix of hashable and unhashable items can be used, but the function will be slower for unhashable items.\n\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n    Credits to **more-itertools** for the implementation.\n\n    Args:\n        key (Callable[[T], U] | None): Function to transform items before comparison.\n\n    Returns:\n        bool: `True` if all elements are unique, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"ABCB\").all_unique()\n    False\n    &gt;&gt;&gt; pc.Iter(\"ABCb\").all_unique()\n    True\n    &gt;&gt;&gt; pc.Iter(\"ABCb\").all_unique(str.lower)\n    False\n\n    ```\n    \"\"\"\n    seenset: set[T | U] = set()\n    seenset_add = seenset.add\n    seenlist: list[T | U] = []\n    seenlist_add = seenlist.append\n    for element in map(key, self.__iter__()) if key else self.__iter__():\n        try:\n            if element in seenset:\n                return False\n            seenset_add(element)\n        except TypeError:\n            if element in seenlist:\n                return False\n            seenlist_add(element)\n    return True\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.argmax","level":2,"title":"<code>argmax(key=None)</code>","text":"<p>Index of the first occurrence of a maximum value in the <code>Iterator</code>.</p> <p>A function that accepts a single argument and returns a transformed version of each input item can be specified with key.</p> <p>Credits to more-itertools for the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the maximum value.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"abcdefghabcd\").argmax()\n7\n&gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n3\n</code></pre> For example, identify the best machine learning model: <pre><code>&gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n&gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n&gt;&gt;&gt; # Most accurate model\n&gt;&gt;&gt; models.get(accuracy.iter().argmax()).unwrap()\n'knn'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Best accuracy\n&gt;&gt;&gt; accuracy.max()\n84\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def argmax[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a maximum value in the `Iterator`.\n\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n    Credits to more-itertools for the implementation.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the maximum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"abcdefghabcd\").argmax()\n    7\n    &gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 3, 2, 1, 0]).argmax()\n    3\n\n    ```\n    For example, identify the best machine learning model:\n    ```python\n    &gt;&gt;&gt; models = pc.Seq([\"svm\", \"random forest\", \"knn\", \"na√Øve bayes\"])\n    &gt;&gt;&gt; accuracy = pc.Seq([68, 61, 84, 72])\n    &gt;&gt;&gt; # Most accurate model\n    &gt;&gt;&gt; models.get(accuracy.iter().argmax()).unwrap()\n    'knn'\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Best accuracy\n    &gt;&gt;&gt; accuracy.max()\n    84\n\n    ```\n    \"\"\"\n    it = self.__iter__()\n    if key is not None:\n        it = map(key, it)\n    return max(enumerate(it), key=itemgetter(1))[0]\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.argmin","level":2,"title":"<code>argmin(key=None)</code>","text":"<p>Index of the first occurrence of a minimum value in the <code>Iterator</code>.</p> <p>A function that accepts a single argument and returns a transformed version of each input item can be specified with key.</p> <p>Credits to more-itertools for the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], U] | None</code> <p>Optional function to determine the value for comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the minimum value.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Example 1: Basic usage\n&gt;&gt;&gt; pc.Iter(\"efghabcdijkl\").argmin()\n4\n&gt;&gt;&gt; pc.Iter([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n3\n&gt;&gt;&gt; # Example 2: look up a label corresponding to the position of a value that minimizes a cost function\n&gt;&gt;&gt; def cost(x: int) -&gt; float:\n...     \"Days for a wound to heal given a subject's age.\"\n...     return x**2 - 20 * x + 150\n&gt;&gt;&gt;\n&gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n&gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n&gt;&gt;&gt; # Fastest healing family member\n&gt;&gt;&gt; labels.get(ages.iter().argmin(key=cost)).unwrap()\n'bart'\n&gt;&gt;&gt; # Age with fastest healing\n&gt;&gt;&gt; ages.min_by(key=cost)\n10\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def argmin[U](self, key: Callable[[T], U] | None = None) -&gt; int:\n    \"\"\"Index of the first occurrence of a minimum value in the `Iterator`.\n\n    A function that accepts a single argument and returns a transformed version of each input item can be specified with **key**.\n\n    Credits to more-itertools for the implementation.\n\n    Args:\n        key (Callable[[T], U] | None): Optional function to determine the value for comparison.\n\n    Returns:\n        int: The index of the minimum value.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Example 1: Basic usage\n    &gt;&gt;&gt; pc.Iter(\"efghabcdijkl\").argmin()\n    4\n    &gt;&gt;&gt; pc.Iter([3, 2, 1, 0, 4, 2, 1, 0]).argmin()\n    3\n    &gt;&gt;&gt; # Example 2: look up a label corresponding to the position of a value that minimizes a cost function\n    &gt;&gt;&gt; def cost(x: int) -&gt; float:\n    ...     \"Days for a wound to heal given a subject's age.\"\n    ...     return x**2 - 20 * x + 150\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; labels = pc.Seq([\"homer\", \"marge\", \"bart\", \"lisa\", \"maggie\"])\n    &gt;&gt;&gt; ages = pc.Seq([35, 30, 10, 9, 1])\n    &gt;&gt;&gt; # Fastest healing family member\n    &gt;&gt;&gt; labels.get(ages.iter().argmin(key=cost)).unwrap()\n    'bart'\n    &gt;&gt;&gt; # Age with fastest healing\n    &gt;&gt;&gt; ages.min_by(key=cost)\n    10\n\n    ```\n    \"\"\"\n    it = self.__iter__()\n    if key is not None:\n        it = map(key, it)\n    return min(enumerate(it), key=itemgetter(1))[0]\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.chain","level":2,"title":"<code>chain(*others)</code>","text":"<p>Concatenate self with one or more <code>Iterables</code>, any of which may be infinite.</p> <p>In other words, it links self and others together, in a chain. üîó</p> <p>An infinite <code>Iterable</code> will prevent the rest of the arguments from being included.</p> <p>This is equivalent to <code>list.extend()</code>, except it is fully lazy and works with any <code>Iterable</code>.</p> See Also <p><code>Iter.insert()</code> to add a single element at the beginning of the <code>Iterator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to concatenate.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Iterator</code> which will first iterate over values from the original <code>Iterator</code> and then over values from the others <code>Iterable</code>s.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2)).chain((3, 4), [5]).collect()\nSeq(1, 2, 3, 4, 5)\n&gt;&gt;&gt; pc.Iter((1, 2)).chain(pc.Iter.from_count(3)).take(5).collect()\nSeq(1, 2, 3, 4, 5)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def chain(self, *others: Iterable[T]) -&gt; Self:\n    \"\"\"Concatenate **self** with one or more `Iterables`, any of which may be infinite.\n\n    In other words, it links **self** and **others** together, in a chain. üîó\n\n    An infinite `Iterable` will prevent the rest of the arguments from being included.\n\n    This is equivalent to `list.extend()`, except it is fully lazy and works with any `Iterable`.\n\n    See Also:\n        `Iter.insert()` to add a single element at the beginning of the `Iterator`.\n\n    Args:\n        *others (Iterable[T]): Other iterables to concatenate.\n\n    Returns:\n        Self: A new `Iterator` which will first iterate over values from the original `Iterator` and then over values from the **others** `Iterable`s.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2)).chain((3, 4), [5]).collect()\n    Seq(1, 2, 3, 4, 5)\n    &gt;&gt;&gt; pc.Iter((1, 2)).chain(pc.Iter.from_count(3)).take(5).collect()\n    Seq(1, 2, 3, 4, 5)\n\n    ```\n    \"\"\"\n    return self.__class__(cz.itertoolz.concat((self.__iter__(), *others)))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.compress","level":2,"title":"<code>compress(*selectors)</code>","text":"<p>Filter elements using a boolean selector iterable.</p> <p>Parameters:</p> Name Type Description Default <code>*selectors</code> <code>bool</code> <p>Boolean values indicating which elements to keep.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of the items selected by the boolean selectors.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"ABCDEF\").compress(1, 0, 1, 0, 1, 1).collect()\nSeq('A', 'C', 'E', 'F')\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def compress(self, *selectors: bool) -&gt; Self:\n    \"\"\"Filter elements using a boolean selector iterable.\n\n    Args:\n        *selectors (bool): Boolean values indicating which elements to keep.\n\n    Returns:\n        Self: An `Iterator` of the items selected by the boolean selectors.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"ABCDEF\").compress(1, 0, 1, 0, 1, 1).collect()\n    Seq('A', 'C', 'E', 'F')\n\n    ```\n    \"\"\"\n    return self.__class__(itertools.compress(self.__iter__(), selectors))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.cycle","level":2,"title":"<code>cycle()</code>","text":"<p>Repeat the <code>Iterator</code> indefinitely.</p> Warning <p>This creates an infinite <code>Iterator</code>.</p> <p>Be sure to use <code>Iter.take()</code> or <code>Iter.slice()</code> to limit the number of items taken.</p> See Also <p><code>Iter.repeat()</code> to repeat self as elements (<code>Iter[Self]</code>).</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Iterator</code> that cycles through the elements indefinitely.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2)).cycle().take(5).collect()\nSeq(1, 2, 1, 2, 1)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def cycle(self) -&gt; Self:\n    \"\"\"Repeat the `Iterator` indefinitely.\n\n    Warning:\n        This creates an infinite `Iterator`.\n\n        Be sure to use `Iter.take()` or `Iter.slice()` to limit the number of items taken.\n\n    See Also:\n        `Iter.repeat()` to repeat *self* as elements (`Iter[Self]`).\n\n    Returns:\n        Self: A new `Iterator` that cycles through the elements indefinitely.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2)).cycle().take(5).collect()\n    Seq(1, 2, 1, 2, 1)\n\n    ```\n    \"\"\"\n    return self.__class__(itertools.cycle(self.__iter__()))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.elements","level":2,"title":"<code>elements()</code>","text":"<p>Iterator over elements repeating each as many times as its count.</p> Note <p>if an element's count has been set to zero or is a negative number, elements() will ignore it.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Iterator</code> with elements repeated according to their counts.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter(\"ABCABC\").elements().sort()\nVec('A', 'A', 'B', 'B', 'C', 'C')\n</code></pre> Knuth's example for prime factors of 1836:  22 * 33 * 17**1 <pre><code>&gt;&gt;&gt; import math\n&gt;&gt;&gt; data = [2, 2, 3, 3, 3, 17]\n&gt;&gt;&gt; pc.Iter(data).elements().into(math.prod)\n1836\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def elements(self) -&gt; Self:\n    \"\"\"Iterator over elements repeating each as many times as its count.\n\n    Note:\n        if an element's count has been set to zero or is a negative\n        number, elements() will ignore it.\n\n    Returns:\n        Self: A new `Iterator` with elements repeated according to their counts.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter(\"ABCABC\").elements().sort()\n    Vec('A', 'A', 'B', 'B', 'C', 'C')\n\n    ```\n    Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1\n    ```python\n    &gt;&gt;&gt; import math\n    &gt;&gt;&gt; data = [2, 2, 3, 3, 3, 17]\n    &gt;&gt;&gt; pc.Iter(data).elements().into(math.prod)\n    1836\n\n    ```\n    \"\"\"\n    from collections import Counter\n\n    return self.__class__(Counter(self.__iter__()).elements())\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Check if two <code>Iterable</code>s are equal based on their data.</p> Note <p>This will consume any <code>Iterator</code> instances involved in the comparison (self and/or other).</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>Another instance of <code>Iterable[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the underlying data are equal, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Vec([1,2,3]))\nTrue\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def eq(self, other: Iterable[T]) -&gt; bool:\n    \"\"\"Check if two `Iterable`s are equal based on their data.\n\n    Note:\n        This will consume any `Iterator` instances involved in the comparison (**self** and/or **other**).\n\n    Args:\n        other (Iterable[T]): Another instance of `Iterable[T]` to compare against.\n\n    Returns:\n        bool: `True` if the underlying data are equal, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Seq([1,2]))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Iter((1,2)))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).eq(pc.Vec([1,2,3]))\n    True\n\n    ```\n    \"\"\"\n    return tls.eq(self.__iter__(), other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.find","level":2,"title":"<code>find(predicate)</code>","text":"<p>Searches for an element of an iterator that satisfies a <code>predicate</code>.</p> <p>Takes a closure that returns true or false as <code>predicate</code>, and applies it to each element of the iterator.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The first element satisfying the predicate. <code>Some(value)</code> if found, <code>NONE</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n...     return x &gt; 5\n&gt;&gt;&gt;\n&gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n...     return x &gt; 9\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(range(10)).find(predicate=gt_five)\nSome(6)\n&gt;&gt;&gt; pc.Iter(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n'missing'\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def find(self, predicate: Callable[[T], bool]) -&gt; Option[T]:\n    \"\"\"Searches for an element of an iterator that satisfies a `predicate`.\n\n    Takes a closure that returns true or false as `predicate`, and applies it to each element of the iterator.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Option[T]: The first element satisfying the predicate. `Some(value)` if found, `NONE` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def gt_five(x: int) -&gt; bool:\n    ...     return x &gt; 5\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; def gt_nine(x: int) -&gt; bool:\n    ...     return x &gt; 9\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(range(10)).find(predicate=gt_five)\n    Some(6)\n    &gt;&gt;&gt; pc.Iter(range(10)).find(predicate=gt_nine).unwrap_or(\"missing\")\n    'missing'\n\n    ```\n    \"\"\"\n    return Option(next(filter(predicate, self), None))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.fold","level":2,"title":"<code>fold(init, func)</code>","text":"<p>Fold every element of the <code>Iterator</code> into an accumulator by applying an operation, returning the final result.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>B</code> <p>Initial value for the accumulator.</p> required <code>func</code> <code>Callable[[B, T], B]</code> <p>Function that takes the accumulator and current element, returning the new accumulator value.</p> required <p>Returns:</p> Name Type Description <code>B</code> <code>B</code> <p>The final accumulated value.</p> Note <p>This is similar to <code>reduce()</code> but with an initial value, making it equivalent to Python <code>functools.reduce()</code> with an initializer.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n6\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n16\n&gt;&gt;&gt; pc.Iter(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n'abc'\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def fold[B](self, init: B, func: Callable[[B, T], B]) -&gt; B:\n    \"\"\"Fold every element of the `Iterator` into an accumulator by applying an operation, returning the final result.\n\n    Args:\n        init (B): Initial value for the accumulator.\n        func (Callable[[B, T], B]): Function that takes the accumulator and current element,\n            returning the new accumulator value.\n\n    Returns:\n        B: The final accumulated value.\n\n    Note:\n        This is similar to `reduce()` but with an initial value, making it equivalent to\n        Python `functools.reduce()` with an initializer.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).fold(0, lambda acc, x: acc + x)\n    6\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).fold(10, lambda acc, x: acc + x)\n    16\n    &gt;&gt;&gt; pc.Iter(['a', 'b', 'c']).fold('', lambda acc, x: acc + x)\n    'abc'\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self, init)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.for_each","level":2,"title":"<code>for_each(func, *args, **kwargs)</code>","text":"<p>Consume the <code>Iterator</code> by applying a function to each element in the <code>Iterable</code>.</p> <p>Is a terminal operation, and is useful for functions that have side effects, or when you want to force evaluation of a lazy iterable.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[Concatenate[T, P], Any]</code> <p>Function to apply to each element.</p> required <code>*args</code> <code>P.args</code> <p>Positional arguments for the function.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Keyword arguments for the function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>This is a terminal operation with no return value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).iter().for_each(lambda x: print(x + 1))\n2\n3\n4\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def for_each[**P](\n    self,\n    func: Callable[Concatenate[T, P], Any],\n    *args: P.args,\n    **kwargs: P.kwargs,\n) -&gt; None:\n    \"\"\"Consume the `Iterator` by applying a function to each element in the `Iterable`.\n\n    Is a terminal operation, and is useful for functions that have side effects,\n    or when you want to force evaluation of a lazy iterable.\n\n    Args:\n        func (Callable[Concatenate[T, P], Any]): Function to apply to each element.\n        *args (P.args): Positional arguments for the function.\n        **kwargs (P.kwargs): Keyword arguments for the function.\n\n    Returns:\n        None: This is a terminal operation with no return value.\n\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).iter().for_each(lambda x: print(x + 1))\n    2\n    3\n    4\n\n    ```\n    \"\"\"\n    for v in self.__iter__():\n        func(v, *args, **kwargs)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.for_each_star","level":2,"title":"<code>for_each_star(func)</code>","text":"<pre><code>for_each_star(func: Callable[[Any], R]) -&gt; None\n</code></pre><pre><code>for_each_star(func: Callable[[T1, T2], R]) -&gt; None\n</code></pre><pre><code>for_each_star(func: Callable[[T1, T2, T3], R]) -&gt; None\n</code></pre><pre><code>for_each_star(func: Callable[[T1, T2, T3, T4], R]) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n) -&gt; None\n</code></pre><pre><code>for_each_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R\n    ],\n) -&gt; None\n</code></pre> <p>Consume the <code>Iterator</code> by applying a function to each unpacked item in the <code>Iterable</code> element.</p> <p>Is a terminal operation, and is useful for functions that have side effects, or when you want to force evaluation of a lazy iterable.</p> <p>Each item yielded by the <code>Iterator</code> is expected to be an <code>Iterable</code> itself (e.g., a tuple or list), and its elements are unpacked as arguments to the provided function.</p> <p>This is often used after methods like <code>zip()</code> or <code>enumerate()</code> that yield tuples.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>Function to apply to each unpacked element.</p> required <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([(1, 2), (3, 4)]).for_each_star(lambda x, y: print(x + y))\n3\n7\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def for_each_star[U: Iterable[Any], R](\n    self: PyoIterator[U],\n    func: Callable[..., R],\n) -&gt; None:\n    \"\"\"Consume the `Iterator` by applying a function to each unpacked item in the `Iterable` element.\n\n    Is a terminal operation, and is useful for functions that have side effects,\n    or when you want to force evaluation of a lazy iterable.\n\n    Each item yielded by the `Iterator` is expected to be an `Iterable` itself (e.g., a tuple or list),\n    and its elements are unpacked as arguments to the provided function.\n\n    This is often used after methods like `zip()` or `enumerate()` that yield tuples.\n\n    Args:\n        func (Callable[..., R]): Function to apply to each unpacked element.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([(1, 2), (3, 4)]).for_each_star(lambda x, y: print(x + y))\n    3\n    7\n\n    ```\n    \"\"\"\n    for item in self.__iter__():\n        func(*item)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.ge","level":2,"title":"<code>ge(other)</code>","text":"<p>Check if this <code>Iterator</code> is greater than or equal to other based on their data.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>Another <code>Iterable[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the underlying data of self is greater than or equal to that of other, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).ge((1,2))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2)).ge((1,2,3))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def ge(self, other: Iterable[T]) -&gt; bool:\n    \"\"\"Check if this `Iterator` is greater than or equal to *other* based on their data.\n\n    Args:\n        other (Iterable[T]): Another `Iterable[T]` to compare against.\n\n    Returns:\n        bool: `True` if the underlying data of **self** is greater than or equal to that of **other**, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ge((1,2))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2)).ge((1,2,3))\n    False\n\n    ```\n    \"\"\"\n    return tls.ge(self.__iter__(), other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.gt","level":2,"title":"<code>gt(other)</code>","text":"<p>Check if this <code>Iterator</code> is greater than other based on their data.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>Another <code>Iterable[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the underlying data of self is greater than that of other, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).gt((1,2))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2)).gt((1,2,3))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def gt(self, other: Iterable[T]) -&gt; bool:\n    \"\"\"Check if this `Iterator` is greater than *other* based on their data.\n\n    Args:\n        other (Iterable[T]): Another `Iterable[T]` to compare against.\n\n    Returns:\n        bool: `True` if the underlying data of **self** is greater than that of **other**, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).gt((1,2))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2)).gt((1,2,3))\n    False\n\n    ```\n    \"\"\"\n    return tls.gt(self.__iter__(), other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.insert","level":2,"title":"<code>insert(value)</code>","text":"<p>Prepend the value to the <code>Iterator</code>.</p> Note <p>This can be considered the equivalent as <code>list.append()</code>, but for a lazy <code>Iterator</code>. However, append add the value at the end, while insert add it at the beginning.</p> See Also <p><code>Iter.chain()</code> to add multiple elements at the end of the <code>Iterator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The value to prepend.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new Iterable wrapper with the value prepended.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((2, 3)).insert(1).collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def insert(self, value: T) -&gt; Self:\n    \"\"\"Prepend the *value* to the `Iterator`.\n\n    Note:\n        This can be considered the equivalent as `list.append()`, but for a lazy `Iterator`.\n        However, append add the value at the **end**, while insert add it at the **beginning**.\n\n    See Also:\n        `Iter.chain()` to add multiple elements at the end of the `Iterator`.\n\n    Args:\n        value (T): The value to prepend.\n\n    Returns:\n        Self: A new Iterable wrapper with the value prepended.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((2, 3)).insert(1).collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    return self.__class__(cz.itertoolz.cons(value, self.__iter__()))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.interleave","level":2,"title":"<code>interleave(*others)</code>","text":"<p>Interleave multiple sequences element-wise.</p> <p>Parameters:</p> Name Type Description Default <code>*others</code> <code>Iterable[T]</code> <p>Other iterables to interleave.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new Iterable wrapper with interleaved elements.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2)).interleave((3, 4)).collect()\nSeq(1, 3, 2, 4)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def interleave(self, *others: Iterable[T]) -&gt; Self:\n    \"\"\"Interleave multiple sequences element-wise.\n\n    Args:\n        *others (Iterable[T]): Other iterables to interleave.\n\n    Returns:\n        Self: A new Iterable wrapper with interleaved elements.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2)).interleave((3, 4)).collect()\n    Seq(1, 3, 2, 4)\n\n    ```\n    \"\"\"\n    return self.__class__(cz.itertoolz.interleave((self.__iter__(), *others)))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.intersperse","level":2,"title":"<code>intersperse(element)</code>","text":"<p>Creates a new <code>Iterator</code> which places a copy of separator between adjacent items of the original iterator.</p> <p>Parameters:</p> Name Type Description Default <code>element</code> <code>T</code> <p>The element to interpose between items.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Iterator</code> with the element interposed.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Simple example with numbers\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).intersperse(0).collect()\nSeq(1, 0, 2, 0, 3)\n&gt;&gt;&gt; # Useful when chaining with other operations\n&gt;&gt;&gt; pc.Iter([10, 20, 30]).intersperse(5).sum()\n70\n&gt;&gt;&gt; # Inserting separators between groups, then flattening\n&gt;&gt;&gt; pc.Iter([[1, 2], [3, 4], [5, 6]]).intersperse([-1]).flatten().collect()\nSeq(1, 2, -1, 3, 4, -1, 5, 6)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def intersperse(self, element: T) -&gt; Self:\n    \"\"\"Creates a new `Iterator` which places a copy of separator between adjacent items of the original iterator.\n\n    Args:\n        element (T): The element to interpose between items.\n\n    Returns:\n        Self: A new `Iterator` with the element interposed.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Simple example with numbers\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).intersperse(0).collect()\n    Seq(1, 0, 2, 0, 3)\n    &gt;&gt;&gt; # Useful when chaining with other operations\n    &gt;&gt;&gt; pc.Iter([10, 20, 30]).intersperse(5).sum()\n    70\n    &gt;&gt;&gt; # Inserting separators between groups, then flattening\n    &gt;&gt;&gt; pc.Iter([[1, 2], [3, 4], [5, 6]]).intersperse([-1]).flatten().collect()\n    Seq(1, 2, -1, 3, 4, -1, 5, 6)\n\n    ```\n    \"\"\"\n    return self.__class__(cz.itertoolz.interpose(element, self.__iter__()))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.is_sorted","level":2,"title":"<code>is_sorted(*, reverse=False, strict=False)</code>","text":"<p>Returns <code>True</code> if the items of the <code>Iterator</code> are in sorted order.</p> <p>The elements of the <code>Iterator</code> must support comparison operations.</p> <p>The function returns <code>False</code> after encountering the first out-of-order item.</p> <p>If there are no out-of-order items, the <code>Iterator</code> is exhausted.</p> <p>Credits to more-itertools for the implementation.</p> See Also <ul> <li><code>is_sorted_by()</code>: If your elements do not support comparison operations directly, or you want to sort based on a specific attribute or transformation.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>Whether to check for descending order.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Whether to enforce strict sorting (no equal elements).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if items are sorted according to the criteria, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).is_sorted()\nTrue\n</code></pre> If strict, tests for strict sorting, that is, returns False if equal elements are found: <pre><code>&gt;&gt;&gt; pc.Iter([1, 2, 2]).is_sorted()\nTrue\n&gt;&gt;&gt; pc.Iter([1, 2, 2]).is_sorted(strict=True)\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_sorted[U: SupportsComparison[Any]](\n    self: PyoIterator[U], *, reverse: bool = False, strict: bool = False\n) -&gt; bool:\n    \"\"\"Returns `True` if the items of the `Iterator` are in sorted order.\n\n    The elements of the `Iterator` must support comparison operations.\n\n    The function returns `False` after encountering the first out-of-order item.\n\n    If there are no out-of-order items, the `Iterator` is exhausted.\n\n    Credits to **more-itertools** for the implementation.\n\n    See Also:\n        - `is_sorted_by()`: If your elements do not support comparison operations directly, or you want to sort based on a specific attribute or transformation.\n\n    Args:\n        reverse (bool): Whether to check for descending order.\n        strict (bool): Whether to enforce strict sorting (no equal elements).\n\n    Returns:\n        bool: `True` if items are sorted according to the criteria, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).is_sorted()\n    True\n\n    ```\n    If strict, tests for strict sorting, that is, returns False if equal elements are found:\n    ```python\n    &gt;&gt;&gt; pc.Iter([1, 2, 2]).is_sorted()\n    True\n    &gt;&gt;&gt; pc.Iter([1, 2, 2]).is_sorted(strict=True)\n    False\n\n    ```\n\n    \"\"\"\n    return tls.is_sorted(self.__iter__(), reverse=reverse, strict=strict)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.is_sorted_by","level":2,"title":"<code>is_sorted_by(key, *, reverse=False, strict=False)</code>","text":"<p>Returns <code>True</code> if the items of the <code>Iterator</code> are in sorted order according to the key function.</p> <p>The function returns <code>False</code> after encountering the first out-of-order item.</p> <p>If there are no out-of-order items, the <code>Iterator</code> is exhausted.</p> <p>Credits to more-itertools for the implementation.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsComparison[Any]]</code> <p>Function to extract a comparison key from each element.</p> required <code>reverse</code> <code>bool</code> <p>Whether to check for descending order.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>Whether to enforce strict sorting (no equal elements).</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if items are sorted according to the criteria, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted_by(int)\nTrue\n&gt;&gt;&gt; pc.Iter([\"5\", \"4\", \"3\", \"1\", \"2\"]).is_sorted_by(int, reverse=True)\nFalse\n</code></pre> If strict, tests for strict sorting, that is, returns False if equal elements are found: <pre><code>&gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"2\"]).is_sorted_by(int)\nTrue\n&gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"2\"]).is_sorted_by(key=int, strict=True)\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_sorted_by(\n    self,\n    key: Callable[[T], SupportsComparison[Any]],\n    *,\n    reverse: bool = False,\n    strict: bool = False,\n) -&gt; bool:\n    \"\"\"Returns `True` if the items of the `Iterator` are in sorted order according to the key function.\n\n    The function returns `False` after encountering the first out-of-order item.\n\n    If there are no out-of-order items, the `Iterator` is exhausted.\n\n    Credits to **more-itertools** for the implementation.\n\n    Args:\n        key (Callable[[T], SupportsComparison[Any]]): Function to extract a comparison key from each element.\n        reverse (bool): Whether to check for descending order.\n        strict (bool): Whether to enforce strict sorting (no equal elements).\n\n    Returns:\n        bool: `True` if items are sorted according to the criteria, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"3\", \"4\", \"5\"]).is_sorted_by(int)\n    True\n    &gt;&gt;&gt; pc.Iter([\"5\", \"4\", \"3\", \"1\", \"2\"]).is_sorted_by(int, reverse=True)\n    False\n\n    ```\n    If strict, tests for strict sorting, that is, returns False if equal elements are found:\n    ```python\n    &gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"2\"]).is_sorted_by(int)\n    True\n    &gt;&gt;&gt; pc.Iter([\"1\", \"2\", \"2\"]).is_sorted_by(key=int, strict=True)\n    False\n\n    ```\n    \"\"\"\n    return tls.is_sorted_by(self.__iter__(), key, reverse=reverse, strict=strict)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.le","level":2,"title":"<code>le(other)</code>","text":"<p>Check if this <code>Iterator</code> is less than or equal to other based on their data.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>Another instance of <code>Iterable[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the underlying data of self is less than or equal to that of other, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2)).le(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).le(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def le(self, other: Iterable[T]) -&gt; bool:\n    \"\"\"Check if this `Iterator` is less than or equal to *other* based on their data.\n\n    Args:\n        other (Iterable[T]): Another instance of `Iterable[T]` to compare against.\n\n    Returns:\n        bool: `True` if the underlying data of self is less than or equal to that of other, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2)).le(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).le(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tls.le(self.__iter__(), other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.lt","level":2,"title":"<code>lt(other)</code>","text":"<p>Check if this <code>Iterator</code> is less than other based on their data.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>Another <code>Iterable[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the underlying data of self is less than that of other, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2)).lt(pc.Seq((1,2,3)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).lt(pc.Seq((1,2)))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def lt(self, other: Iterable[T]) -&gt; bool:\n    \"\"\"Check if this `Iterator` is less than *other* based on their data.\n\n    Args:\n        other (Iterable[T]): Another `Iterable[T]` to compare against.\n\n    Returns:\n        bool: `True` if the underlying data of self is less than that of other, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2)).lt(pc.Seq((1,2,3)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).lt(pc.Seq((1,2)))\n    False\n\n    ```\n    \"\"\"\n    return tls.lt(self.__iter__(), other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.ne","level":2,"title":"<code>ne(other)</code>","text":"<p>Check if this <code>Iterator</code> and other are not equal based on their data.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Iterable[T]</code> <p>Another instance of <code>Iterable[T]</code> to compare against.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the underlying data are not equal, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\nFalse\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Seq([1,2]))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\nTrue\n&gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Vec([1,2,3]))\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def ne(self, other: Iterable[T]) -&gt; bool:\n    \"\"\"Check if this `Iterator` and *other* are not equal based on their data.\n\n    Args:\n        other (Iterable[T]): Another instance of `Iterable[T]` to compare against.\n\n    Returns:\n        bool: `True` if the underlying data are not equal, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2,3)))\n    False\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Seq([1,2]))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Iter((1,2)))\n    True\n    &gt;&gt;&gt; pc.Iter((1,2,3)).ne(pc.Vec([1,2,3]))\n    False\n\n    ```\n    \"\"\"\n    return tls.ne(self.__iter__(), other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.next","level":2,"title":"<code>next()</code>","text":"<p>Return the next element in the <code>Iterator</code>.</p> Note <p>The actual <code>.__next__()</code> method must be conform to the Python <code>Iterator</code> Protocol, and is what will be actually called if you iterate over the <code>PyoIterator</code> instance.</p> <p><code>PyoIterator.next()</code> is a convenience method that wraps the result in an <code>Option</code> to handle exhaustion gracefully, for custom use cases.</p> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: The next element in the iterator. <code>Some[T]</code>, or <code>NONE</code> if the iterator is exhausted.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; it = pc.Seq([1, 2, 3]).iter()\n&gt;&gt;&gt; it.next().unwrap()\n1\n&gt;&gt;&gt; it.next().unwrap()\n2\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def next(self) -&gt; Option[T]:\n    \"\"\"Return the next element in the `Iterator`.\n\n    Note:\n        The actual `.__next__()` method must be conform to the Python `Iterator` Protocol, and is what will be actually called if you iterate over the `PyoIterator` instance.\n\n        `PyoIterator.next()` is a convenience method that wraps the result in an `Option` to handle exhaustion gracefully, for custom use cases.\n\n    Returns:\n        Option[T]: The next element in the iterator. `Some[T]`, or `NONE` if the iterator is exhausted.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; it = pc.Seq([1, 2, 3]).iter()\n    &gt;&gt;&gt; it.next().unwrap()\n    1\n    &gt;&gt;&gt; it.next().unwrap()\n    2\n\n    ```\n    \"\"\"\n    return Option(next(self, None))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.nth","level":2,"title":"<code>nth(n)</code>","text":"<p>Return the nth item of the <code>Iterable</code> at the specified n.</p> <p>This is similar to <code>__getitem__</code> but for lazy <code>Iterators</code>.</p> <p>If n is out of bounds, returns <code>NONE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The index of the item to retrieve.</p> required <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: <code>Some(item)</code> at the specified n.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([10, 20]).nth(1)\nSome(20)\n&gt;&gt;&gt; pc.Iter([10, 20]).nth(3)\nNONE\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def nth(self, n: int) -&gt; Option[T]:\n    \"\"\"Return the nth item of the `Iterable` at the specified *n*.\n\n    This is similar to `__getitem__` but for lazy `Iterators`.\n\n    If *n* is out of bounds, returns `NONE`.\n\n    Args:\n        n (int): The index of the item to retrieve.\n\n    Returns:\n        Option[T]: `Some(item)` at the specified *n*.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([10, 20]).nth(1)\n    Some(20)\n    &gt;&gt;&gt; pc.Iter([10, 20]).nth(3)\n    NONE\n\n    ```\n    \"\"\"\n    try:\n        return Some(next(itertools.islice(self.__iter__(), n, n + 1)))\n    except StopIteration:\n        return NONE\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.random_sample","level":2,"title":"<code>random_sample(probability, state=None)</code>","text":"<p>Return elements from the <code>Iterator</code> with a given probability.</p> <p><code>.random_sample()</code> considers each item independently and without replacement.</p> <p>See below how the first time it returned 13 items and the next time it returned 6 items.</p> <p>Parameters:</p> Name Type Description Default <code>probability</code> <code>float</code> <p>The probability of including each element.</p> required <code>state</code> <code>Random | int | None</code> <p>Random state or seed for deterministic sampling.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Iterator</code> with randomly sampled elements.</p> <p><pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Iter(range(100)).collect()\n&gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\nSeq(6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95)\n&gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\nSeq(6, 44, 54, 61, 69, 94)\n</code></pre> Providing an integer seed for random_state will result in deterministic sampling.</p> <p>Given the same seed it will return the same sample every time. <pre><code>&gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\nSeq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n&gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\nSeq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n</code></pre> random_state can also be any object with a method random that returns floats between 0.0 and 1.0 (exclusive). <pre><code>&gt;&gt;&gt; from random import Random\n&gt;&gt;&gt; randobj = Random(2016)\n&gt;&gt;&gt; data.iter().random_sample(0.1, state=randobj).collect()\nSeq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def random_sample(\n    self, probability: float, state: Random | int | None = None\n) -&gt; Self:\n    \"\"\"Return elements from the `Iterator` with a given *probability*.\n\n    `.random_sample()` considers each item independently and without replacement.\n\n    See below how the first time it returned 13 items and the next time it returned 6 items.\n\n    Args:\n        probability (float): The probability of including each element.\n        state (Random | int | None): Random state or seed for deterministic sampling.\n\n    Returns:\n        Self: A new `Iterator` with randomly sampled elements.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Iter(range(100)).collect()\n    &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n    Seq(6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95)\n    &gt;&gt;&gt; data.iter().random_sample(0.1).collect()  # doctest: +SKIP\n    Seq(6, 44, 54, 61, 69, 94)\n    ```\n    Providing an integer seed for random_state will result in deterministic sampling.\n\n    Given the same seed it will return the same sample every time.\n    ```python\n    &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n    Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n    &gt;&gt;&gt; data.iter().random_sample(0.1, state=2016).collect()\n    Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n    ```\n    random_state can also be any object with a method random that returns floats between 0.0 and 1.0 (exclusive).\n    ```python\n    &gt;&gt;&gt; from random import Random\n    &gt;&gt;&gt; randobj = Random(2016)\n    &gt;&gt;&gt; data.iter().random_sample(0.1, state=randobj).collect()\n    Seq(7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98)\n\n    ```\n    \"\"\"\n    return self.__class__(\n        cz.itertoolz.random_sample(probability, self.__iter__(), random_state=state)\n    )\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.reduce","level":2,"title":"<code>reduce(func)</code>","text":"<p>Apply a function of two arguments cumulatively to the items of an iterable, from left to right.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], T]</code> <p>Function to apply cumulatively to the items of the iterable.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>Single value resulting from cumulative reduction.</p> <p>This effectively reduces the <code>Iterator</code> to a single value.</p> <p>If initial is present, it is placed before the items of the <code>Iterator</code> in the calculation.</p> <p>It then serves as a default when the <code>Iterator</code> is empty. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).reduce(lambda a, b: a + b)\n6\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def reduce(self, func: Callable[[T, T], T]) -&gt; T:\n    \"\"\"Apply a function of two arguments cumulatively to the items of an iterable, from left to right.\n\n    Args:\n        func (Callable[[T, T], T]): Function to apply cumulatively to the items of the iterable.\n\n    Returns:\n        T: Single value resulting from cumulative reduction.\n\n    This effectively reduces the `Iterator` to a single value.\n\n    If initial is present, it is placed before the items of the `Iterator` in the calculation.\n\n    It then serves as a default when the `Iterator` is empty.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).reduce(lambda a, b: a + b)\n    6\n\n    ```\n    \"\"\"\n    return functools.reduce(func, self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.skip","level":2,"title":"<code>skip(n)</code>","text":"<p>Drop first n elements.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to skip.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of the items after skipping the first n items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 3)).skip(1).collect()\nSeq(2, 3)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def skip(self, n: int) -&gt; Self:\n    \"\"\"Drop first n elements.\n\n    Args:\n        n (int): Number of elements to skip.\n\n    Returns:\n        Self: An `Iterator` of the items after skipping the first n items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 3)).skip(1).collect()\n    Seq(2, 3)\n\n    ```\n    \"\"\"\n    return self.__class__(cz.itertoolz.drop(n, self.__iter__()))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.skip_while","level":2,"title":"<code>skip_while(predicate)</code>","text":"<p>Drop items while predicate holds.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of the items after skipping those for which the predicate is true.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 0)).skip_while(lambda x: x &gt; 0).collect()\nSeq(0,)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def skip_while(self, predicate: Callable[[T], bool]) -&gt; Self:\n    \"\"\"Drop items while predicate holds.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Self: An `Iterator` of the items after skipping those for which the predicate is true.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 0)).skip_while(lambda x: x &gt; 0).collect()\n    Seq(0,)\n\n    ```\n    \"\"\"\n    return self.__class__(itertools.dropwhile(predicate, self.__iter__()))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.slice","level":2,"title":"<code>slice(start=None, stop=None, step=None)</code>","text":"<p>Return a slice of the <code>Iterator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int | None</code> <p>Starting index of the slice.</p> <code>None</code> <code>stop</code> <code>int | None</code> <p>Ending index of the slice.</p> <code>None</code> <code>step</code> <code>int | None</code> <p>Step size for the slice.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of the sliced items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = (1, 2, 3, 4, 5)\n&gt;&gt;&gt; pc.Iter(data).slice(1, 4).collect()\nSeq(2, 3, 4)\n&gt;&gt;&gt; pc.Iter(data).slice(step=2).collect()\nSeq(1, 3, 5)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def slice(\n    self,\n    start: int | None = None,\n    stop: int | None = None,\n    step: int | None = None,\n) -&gt; Self:\n    \"\"\"Return a slice of the `Iterator`.\n\n    Args:\n        start (int | None): Starting index of the slice.\n        stop (int | None): Ending index of the slice.\n        step (int | None): Step size for the slice.\n\n    Returns:\n        Self: An `Iterator` of the sliced items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = (1, 2, 3, 4, 5)\n    &gt;&gt;&gt; pc.Iter(data).slice(1, 4).collect()\n    Seq(2, 3, 4)\n    &gt;&gt;&gt; pc.Iter(data).slice(step=2).collect()\n    Seq(1, 3, 5)\n\n    ```\n    \"\"\"\n    return self.__class__(itertools.islice(self.__iter__(), start, stop, step))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.step_by","level":2,"title":"<code>step_by(step)</code>","text":"<p>Creates an <code>Iterator</code> starting at the same point, but stepping by the given step at each iteration.</p> Note <p>The first element of the iterator will always be returned, regardless of the step given.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>Step size for selecting items.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of every nth item.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 4, 5]).step_by(2).collect()\nSeq(0, 2, 4)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def step_by(self, step: int) -&gt; Self:\n    \"\"\"Creates an `Iterator` starting at the same point, but stepping by the given **step** at each iteration.\n\n    Note:\n        The first element of the iterator will always be returned, regardless of the **step** given.\n\n    Args:\n        step (int): Step size for selecting items.\n\n    Returns:\n        Self: An `Iterator` of every nth item.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([0, 1, 2, 3, 4, 5]).step_by(2).collect()\n    Seq(0, 2, 4)\n\n    ```\n    \"\"\"\n    return self.__class__(cz.itertoolz.take_nth(step, self.__iter__()))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.take","level":2,"title":"<code>take(n)</code>","text":"<p>Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner.</p> <p><code>Iter.take(n)</code> yields elements until n elements are yielded or the end of the iterator is reached (whichever happens first).</p> <p>The returned iterator is either:</p> <ul> <li>A prefix of length n if the original iterator contains at least n elements</li> <li>All of the (fewer than n) elements of the original iterator if it contains fewer than n elements.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of the first n items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = [1, 2, 3]\n&gt;&gt;&gt; pc.Iter(data).take(2).collect()\nSeq(1, 2)\n&gt;&gt;&gt; pc.Iter(data).take(5).collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def take(self, n: int) -&gt; Self:\n    \"\"\"Creates an iterator that yields the first n elements, or fewer if the underlying iterator ends sooner.\n\n    `Iter.take(n)` yields elements until n elements are yielded or the end of the iterator is reached (whichever happens first).\n\n    The returned iterator is either:\n\n    - A prefix of length n if the original iterator contains at least n elements\n    - All of the (fewer than n) elements of the original iterator if it contains fewer than n elements.\n\n    Args:\n        n (int): Number of elements to take.\n\n    Returns:\n        Self: An `Iterator` of the first n items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = [1, 2, 3]\n    &gt;&gt;&gt; pc.Iter(data).take(2).collect()\n    Seq(1, 2)\n    &gt;&gt;&gt; pc.Iter(data).take(5).collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"\n    return self.__class__(itertools.islice(self.__iter__(), n))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.take_while","level":2,"title":"<code>take_while(predicate)</code>","text":"<p>Take items while predicate holds.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>Function to evaluate each item.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of the items taken while the predicate is true.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter((1, 2, 0)).take_while(lambda x: x &gt; 0).collect()\nSeq(1, 2)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def take_while(self, predicate: Callable[[T], bool]) -&gt; Self:\n    \"\"\"Take items while predicate holds.\n\n    Args:\n        predicate (Callable[[T], bool]): Function to evaluate each item.\n\n    Returns:\n        Self: An `Iterator` of the items taken while the predicate is true.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter((1, 2, 0)).take_while(lambda x: x &gt; 0).collect()\n    Seq(1, 2)\n\n    ```\n    \"\"\"\n    return self.__class__(itertools.takewhile(predicate, self.__iter__()))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.try_find","level":2,"title":"<code>try_find(predicate)</code>","text":"<p>Applies a function returning <code>Result[bool, E]</code> to find first matching element.</p> <p>Short-circuits: stops at the first successful <code>True</code> or on the first error.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], Result[bool, E]]</code> <p>Function returning a <code>Result[bool, E]</code>.</p> required <p>Returns:</p> Type Description <code>Result[Option[T], E]</code> <p>Result[Option[T], E]: The first matching element, or the first error.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def is_even(x: int) -&gt; pc.Result[bool, str]:\n...     return pc.Ok(x % 2 == 0) if x &gt;= 0 else pc.Err(\"negative number\")\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter(range(1, 6)).try_find(is_even)\nOk(Some(2))\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def try_find[E](\n    self, predicate: Callable[[T], Result[bool, E]]\n) -&gt; Result[Option[T], E]:\n    \"\"\"Applies a function returning `Result[bool, E]` to find first matching element.\n\n    Short-circuits: stops at the first successful `True` or on the first error.\n\n    Args:\n        predicate (Callable[[T], Result[bool, E]]): Function returning a `Result[bool, E]`.\n\n    Returns:\n        Result[Option[T], E]: The first matching element, or the first error.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def is_even(x: int) -&gt; pc.Result[bool, str]:\n    ...     return pc.Ok(x % 2 == 0) if x &gt;= 0 else pc.Err(\"negative number\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter(range(1, 6)).try_find(is_even)\n    Ok(Some(2))\n\n    ```\n    \"\"\"\n    return tls.try_find(self.__iter__(), predicate)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.try_fold","level":2,"title":"<code>try_fold(init, func)</code>","text":"<p>Folds every element into an accumulator, short-circuiting on error.</p> <p>Applies func cumulatively to items and the accumulator.</p> <p>If func returns an error, stops and returns that error.</p> <p>Parameters:</p> Name Type Description Default <code>init</code> <code>B</code> <p>Initial accumulator value.</p> required <code>func</code> <code>Callable[[B, T], Result[B, E]]</code> <p>Function that takes the accumulator and element, returns a <code>Result[B, E]</code>.</p> required <p>Returns:</p> Type Description <code>Result[B, E]</code> <p>Result[B, E]: Final accumulator or the first error.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def checked_add(acc: int, x: int) -&gt; pc.Result[int, str]:\n...     new_val = acc + x\n...     if new_val &gt; 100:\n...         return pc.Err(\"overflow\")\n...     return pc.Ok(new_val)\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).try_fold(0, checked_add)\nOk(6)\n&gt;&gt;&gt; pc.Iter([50, 40, 20]).try_fold(0, checked_add)\nErr('overflow')\n&gt;&gt;&gt; pc.Iter([]).try_fold(0, checked_add)\nOk(0)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def try_fold[B, E](\n    self, init: B, func: Callable[[B, T], Result[B, E]]\n) -&gt; Result[B, E]:\n    \"\"\"Folds every element into an accumulator, short-circuiting on error.\n\n    Applies **func** cumulatively to items and the accumulator.\n\n    If **func** returns an error, stops and returns that error.\n\n    Args:\n        init (B): Initial accumulator value.\n        func (Callable[[B, T], Result[B, E]]): Function that takes the accumulator and element, returns a `Result[B, E]`.\n\n    Returns:\n        Result[B, E]: Final accumulator or the first error.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def checked_add(acc: int, x: int) -&gt; pc.Result[int, str]:\n    ...     new_val = acc + x\n    ...     if new_val &gt; 100:\n    ...         return pc.Err(\"overflow\")\n    ...     return pc.Ok(new_val)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).try_fold(0, checked_add)\n    Ok(6)\n    &gt;&gt;&gt; pc.Iter([50, 40, 20]).try_fold(0, checked_add)\n    Err('overflow')\n    &gt;&gt;&gt; pc.Iter([]).try_fold(0, checked_add)\n    Ok(0)\n\n    ```\n    \"\"\"\n    return tls.try_fold(self.__iter__(), init, func)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.try_for_each","level":2,"title":"<code>try_for_each(f)</code>","text":"<p>Applies a fallible function to each item in the <code>Iterator</code>, stopping at the first error and returning that error.</p> <p>This can also be thought of as the fallible form of <code>.for_each()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>Callable[[T], Result[Any, E]]</code> <p>A function that takes an item of type <code>T</code> and returns a <code>Result</code>.</p> required <p>Returns:</p> Type Description <code>Result[None, E]</code> <p>Result[None, E]: Returns <code>Ok(None)</code> if all applications of f were successful (i.e., returned <code>Ok</code>), or the first error <code>E</code> encountered.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def validate_positive(n: int) -&gt; pc.Result[None, str]:\n...     if n &gt; 0:\n...         return pc.Ok(None)\n...     return pc.Err(f\"Value {n} is not positive\")\n&gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).try_for_each(validate_positive)\nOk(None)\n&gt;&gt;&gt; # Short-circuit on first error:\n&gt;&gt;&gt; pc.Iter([1, 2, -1, 4]).try_for_each(validate_positive)\nErr('Value -1 is not positive')\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def try_for_each[E](self, f: Callable[[T], Result[Any, E]]) -&gt; Result[None, E]:\n    \"\"\"Applies a fallible function to each item in the `Iterator`, stopping at the first error and returning that error.\n\n    This can also be thought of as the fallible form of `.for_each()`.\n\n    Args:\n        f (Callable[[T], Result[Any, E]]): A function that takes an item of type `T` and returns a `Result`.\n\n    Returns:\n        Result[None, E]: Returns `Ok(None)` if all applications of **f** were successful (i.e., returned `Ok`), or the first error `E` encountered.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def validate_positive(n: int) -&gt; pc.Result[None, str]:\n    ...     if n &gt; 0:\n    ...         return pc.Ok(None)\n    ...     return pc.Err(f\"Value {n} is not positive\")\n    &gt;&gt;&gt; pc.Iter([1, 2, 3, 4, 5]).try_for_each(validate_positive)\n    Ok(None)\n    &gt;&gt;&gt; # Short-circuit on first error:\n    &gt;&gt;&gt; pc.Iter([1, 2, -1, 4]).try_for_each(validate_positive)\n    Err('Value -1 is not positive')\n\n    ```\n    \"\"\"\n    for item in self.__iter__():\n        res = f(item)\n        if res.is_err():\n            return res\n    return Ok(None)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.try_reduce","level":2,"title":"<code>try_reduce(func)</code>","text":"<p>Reduces elements to a single one, short-circuiting on error.</p> <p>Uses the first element as the initial accumulator. If func returns an error, stops immediately.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[T, T], Result[T, E]]</code> <p>Function that reduces two items, returns a <code>Result[T, E]</code>.</p> required <p>Returns:</p> Type Description <code>Result[Option[T], E]</code> <p>Result[Option[T], E]: Final accumulated value or the first error. Returns <code>Ok(NONE)</code> for empty iterable.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def checked_add(x: int, y: int) -&gt; pc.Result[int, str]:\n...     if x + y &gt; 100:\n...         return pc.Err(\"overflow\")\n...     return pc.Ok(x + y)\n&gt;&gt;&gt;\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).try_reduce(checked_add)\nOk(Some(6))\n&gt;&gt;&gt; pc.Iter([50, 60]).try_reduce(checked_add)\nErr('overflow')\n&gt;&gt;&gt; pc.Iter([]).try_reduce(checked_add)\nOk(NONE)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def try_reduce[E](\n    self, func: Callable[[T, T], Result[T, E]]\n) -&gt; Result[Option[T], E]:\n    \"\"\"Reduces elements to a single one, short-circuiting on error.\n\n    Uses the first element as the initial accumulator. If **func** returns an error, stops immediately.\n\n    Args:\n        func (Callable[[T, T], Result[T, E]]): Function that reduces two items, returns a `Result[T, E]`.\n\n    Returns:\n        Result[Option[T], E]: Final accumulated value or the first error. Returns `Ok(NONE)` for empty iterable.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; def checked_add(x: int, y: int) -&gt; pc.Result[int, str]:\n    ...     if x + y &gt; 100:\n    ...         return pc.Err(\"overflow\")\n    ...     return pc.Ok(x + y)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).try_reduce(checked_add)\n    Ok(Some(6))\n    &gt;&gt;&gt; pc.Iter([50, 60]).try_reduce(checked_add)\n    Err('overflow')\n    &gt;&gt;&gt; pc.Iter([]).try_reduce(checked_add)\n    Ok(NONE)\n\n    ```\n    \"\"\"\n    return tls.try_reduce(self.__iter__(), func)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyoiterator/#pyochain.traits._iterable.PyoIterator.unique","level":2,"title":"<code>unique(key=None)</code>","text":"<p>Return only unique elements of the iterable.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], Any] | None</code> <p>Function to transform items before comparison.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>An <code>Iterator</code> of the unique items.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Iter([1, 2, 3]).unique().collect()\nSeq(1, 2, 3)\n&gt;&gt;&gt; pc.Iter([1, 2, 1, 3]).unique().collect()\nSeq(1, 2, 3)\n</code></pre> Uniqueness can be defined by key keyword <pre><code>&gt;&gt;&gt; pc.Iter([\"cat\", \"mouse\", \"dog\", \"hen\"]).unique(key=len).collect()\nSeq('cat', 'mouse')\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def unique(self, key: Callable[[T], Any] | None = None) -&gt; Self:\n    \"\"\"Return only unique elements of the iterable.\n\n    Args:\n        key (Callable[[T], Any] | None): Function to transform items before comparison.\n\n    Returns:\n        Self: An `Iterator` of the unique items.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Iter([1, 2, 3]).unique().collect()\n    Seq(1, 2, 3)\n    &gt;&gt;&gt; pc.Iter([1, 2, 1, 3]).unique().collect()\n    Seq(1, 2, 3)\n\n    ```\n    Uniqueness can be defined by key keyword\n    ```python\n    &gt;&gt;&gt; pc.Iter([\"cat\", \"mouse\", \"dog\", \"hen\"]).unique(key=len).collect()\n    Seq('cat', 'mouse')\n\n    ```\n    \"\"\"\n    return self.__class__(cz.itertoolz.unique(self.__iter__(), key=key))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoIterator"],"tags":[]},{"location":"reference/pyokeysview/","level":1,"title":"PyoKeysView","text":"<p>               Bases: <code>KeysView[K]</code>, <code>PyoMappingView[K]</code>, <code>PyoSet[K]</code></p> <p>A view of the keys in a pyochain mapping.</p> <p>This class provides a view over the keys contained in a pyochain mapping, with additional methods from the <code>PyoMappingView</code>, <code>PyoSet</code>, and <code>PyoCollection</code> traits.</p> <p>Keys views support set-like operations since dictionary keys are unique.</p> See Also <p><code>PyoMapping.keys()</code>: Method that returns this view.</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoKeysView[K](KeysView[K], PyoMappingView[K], PyoSet[K]):\n    \"\"\"A view of the keys in a pyochain mapping.\n\n    This class provides a view over the keys contained in a pyochain mapping, with\n    additional methods from the `PyoMappingView`, `PyoSet`, and `PyoCollection` traits.\n\n    Keys views support set-like operations since dictionary keys are unique.\n\n    See Also:\n        `PyoMapping.keys()`: Method that returns this view.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>","path":["API Reference","Traits & Mixins","PyoKeysView"],"tags":[]},{"location":"reference/pyomapping/","level":1,"title":"PyoMapping","text":"<p>               Bases: <code>PyoCollection[K]</code>, <code>Mapping[K, V]</code></p> <p>Base trait for eager pyochain immutable mapping collections.</p> <p><code>PyoMapping[K, V]</code> is the shared trait for concrete, eager mapping-like collections such as <code>Dict</code>.</p> <p>It extends <code>PyoCollection[K]</code> and <code>collections.abc.Mapping[K, V]</code>.</p> <p>This is equivalent to subclassing <code>collections.abc.Mapping[K, V]</code> (this trait already does), meaning any concrete subclass must implement the required <code>Mapping</code> dunder methods:</p> <ul> <li><code>__getitem__</code></li> <li><code>__iter__</code></li> <li><code>__len__</code></li> </ul> <p>On top of the standard <code>Mapping</code> protocol, it provides the additional pyochain API (from <code>PyoCollection</code>, <code>Pipeable</code>, <code>Checkable</code>, plus any helpers defined here).</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoMapping[K, V](PyoCollection[K], Mapping[K, V]):\n    \"\"\"Base trait for eager pyochain immutable mapping collections.\n\n    `PyoMapping[K, V]` is the shared trait for concrete, eager mapping-like\n    collections such as `Dict`.\n\n    It extends `PyoCollection[K]` and `collections.abc.Mapping[K, V]`.\n\n    This is equivalent to subclassing `collections.abc.Mapping[K, V]` (this trait\n    already does), meaning any concrete subclass must implement the required\n    `Mapping` dunder methods:\n\n    - `__getitem__`\n    - `__iter__`\n    - `__len__`\n\n    On top of the standard `Mapping` protocol, it provides the additional\n    pyochain API (from `PyoCollection`, `Pipeable`, `Checkable`, plus any helpers defined here).\n    \"\"\"\n\n    __slots__ = ()\n\n    def keys(self) -&gt; PyoKeysView[K]:\n        \"\"\"Return a view of the `Mapping` keys.\n\n        Returns:\n            PyoKeysView[K]: A view of the dictionary's keys.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.keys()\n        PyoKeysView(Dict(1: 'a', 2: 'b'))\n\n        ```\n        \"\"\"\n        return PyoKeysView(self)\n\n    def values(self) -&gt; PyoValuesView[V]:\n        \"\"\"Return a view of the `Mapping` values.\n\n        Returns:\n            PyoValuesView[V]: A view of the dictionary's values.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.values()\n        PyoValuesView(Dict(1: 'a', 2: 'b'))\n\n        ```\n        \"\"\"\n        return PyoValuesView(self)\n\n    def items(self) -&gt; PyoItemsView[K, V]:\n        \"\"\"Return a view of the `Mapping` items.\n\n        Returns:\n            PyoItemsView[K, V]: A view of the dictionary's (key, value) pairs.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.items()\n        PyoItemsView(Dict(1: 'a', 2: 'b'))\n\n        ```\n        \"\"\"\n        return PyoItemsView(self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMapping"],"tags":[]},{"location":"reference/pyomapping/#pyochain.traits._iterable.PyoMapping.items","level":2,"title":"<code>items()</code>","text":"<p>Return a view of the <code>Mapping</code> items.</p> <p>Returns:</p> Type Description <code>PyoItemsView[K, V]</code> <p>PyoItemsView[K, V]: A view of the dictionary's (key, value) pairs.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.items()\nPyoItemsView(Dict(1: 'a', 2: 'b'))\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def items(self) -&gt; PyoItemsView[K, V]:\n    \"\"\"Return a view of the `Mapping` items.\n\n    Returns:\n        PyoItemsView[K, V]: A view of the dictionary's (key, value) pairs.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.items()\n    PyoItemsView(Dict(1: 'a', 2: 'b'))\n\n    ```\n    \"\"\"\n    return PyoItemsView(self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMapping"],"tags":[]},{"location":"reference/pyomapping/#pyochain.traits._iterable.PyoMapping.keys","level":2,"title":"<code>keys()</code>","text":"<p>Return a view of the <code>Mapping</code> keys.</p> <p>Returns:</p> Type Description <code>PyoKeysView[K]</code> <p>PyoKeysView[K]: A view of the dictionary's keys.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.keys()\nPyoKeysView(Dict(1: 'a', 2: 'b'))\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def keys(self) -&gt; PyoKeysView[K]:\n    \"\"\"Return a view of the `Mapping` keys.\n\n    Returns:\n        PyoKeysView[K]: A view of the dictionary's keys.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.keys()\n    PyoKeysView(Dict(1: 'a', 2: 'b'))\n\n    ```\n    \"\"\"\n    return PyoKeysView(self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMapping"],"tags":[]},{"location":"reference/pyomapping/#pyochain.traits._iterable.PyoMapping.values","level":2,"title":"<code>values()</code>","text":"<p>Return a view of the <code>Mapping</code> values.</p> <p>Returns:</p> Type Description <code>PyoValuesView[V]</code> <p>PyoValuesView[V]: A view of the dictionary's values.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.values()\nPyoValuesView(Dict(1: 'a', 2: 'b'))\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def values(self) -&gt; PyoValuesView[V]:\n    \"\"\"Return a view of the `Mapping` values.\n\n    Returns:\n        PyoValuesView[V]: A view of the dictionary's values.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.values()\n    PyoValuesView(Dict(1: 'a', 2: 'b'))\n\n    ```\n    \"\"\"\n    return PyoValuesView(self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMapping"],"tags":[]},{"location":"reference/pyomappingview/","level":1,"title":"PyoMappingView","text":"<p>               Bases: <code>MappingView</code>, <code>PyoCollection[T]</code></p> <p>Base trait for eager pyochain mapping view collections.</p> <p><code>PyoMappingView[T]</code> is the shared trait for concrete mapping views returned by mapping operations.</p> <p>This trait extends both <code>MappingView</code> from <code>collections.abc</code> and <code>PyoCollection[T]</code>.</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoMappingView[T](MappingView, PyoCollection[T]):\n    \"\"\"Base trait for eager pyochain mapping view collections.\n\n    `PyoMappingView[T]` is the shared trait for concrete mapping views\n    returned by mapping operations.\n\n    This trait extends both `MappingView` from `collections.abc` and `PyoCollection[T]`.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMappingView"],"tags":[]},{"location":"reference/pyomutablemapping/","level":1,"title":"PyoMutableMapping","text":"<p>               Bases: <code>PyoMapping[K, V]</code>, <code>MutableMapping[K, V]</code></p> <p>Base trait for eager pyochain mutable mapping collections.</p> <p><code>PyoMutableMapping[K, V]</code> is the shared trait for concrete, eager mutable mapping-like collections such as <code>Dict</code>.</p> <p>It extends <code>PyoMapping[K, V]</code> and <code>collections.abc.MutableMapping[K, V]</code>.</p> <p>This is equivalent to subclassing <code>collections.abc.MutableMapping[K, V]</code> (this trait already does), meaning any concrete subclass must implement the required <code>MutableMapping</code> dunder methods:</p> <ul> <li><code>__getitem__</code></li> <li><code>__setitem__</code></li> <li><code>__delitem__</code></li> <li><code>__iter__</code></li> <li><code>__len__</code></li> </ul> <p>On top of the standard <code>MutableMapping</code> protocol, it provides the additional pyochain API (from <code>PyoMapping</code>, <code>PyoCollection</code>, <code>Pipeable</code>, <code>Checkable</code>, plus any helpers defined here).</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoMutableMapping[K, V](PyoMapping[K, V], MutableMapping[K, V]):\n    \"\"\"Base trait for eager pyochain mutable mapping collections.\n\n    `PyoMutableMapping[K, V]` is the shared trait for concrete, eager mutable mapping-like\n    collections such as `Dict`.\n\n    It extends `PyoMapping[K, V]` and `collections.abc.MutableMapping[K, V]`.\n\n    This is equivalent to subclassing `collections.abc.MutableMapping[K, V]` (this trait\n    already does), meaning any concrete subclass must implement the required\n    `MutableMapping` dunder methods:\n\n    - `__getitem__`\n    - `__setitem__`\n    - `__delitem__`\n    - `__iter__`\n    - `__len__`\n\n    On top of the standard `MutableMapping` protocol, it provides the additional\n    pyochain API (from `PyoMapping`, `PyoCollection`, `Pipeable`, `Checkable`, plus any helpers defined here).\n    \"\"\"\n\n    __slots__ = ()\n\n    def insert(self, key: K, value: V) -&gt; Option[V]:\n        \"\"\"Insert a key-value pair into the `MutableMapping`.\n\n        If the `MutableMapping` did not have this **key** present, `NONE` is returned.\n\n        If the `MutableMapping` did have this **key** present, the **value** is updated, and the old value is returned.\n\n        The **key** is not updated.\n\n        Args:\n            key (K): The key to insert.\n            value (V): The value associated with the key.\n\n        Returns:\n            Option[V]: The previous value associated with the key, or None if the key was not present.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict.new()\n        &gt;&gt;&gt; data.insert(37, \"a\")\n        NONE\n        &gt;&gt;&gt; data.is_empty()\n        False\n\n        &gt;&gt;&gt; data.insert(37, \"b\")\n        Some('a')\n        &gt;&gt;&gt; data.insert(37, \"c\")\n        Some('b')\n        &gt;&gt;&gt; data[37]\n        'c'\n\n        ```\n        \"\"\"\n        previous = self.get(key, None)\n        self[key] = value\n        return Option(previous)\n\n    def try_insert(self, key: K, value: V) -&gt; Result[V, KeyError]:\n        \"\"\"Tries to insert a key-value pair into the `MutableMapping`, and returns a `Result[V, KeyError]` containing the value in the entry (if successful).\n\n        If the `MutableMapping` already had this **key** present, nothing is updated, and an error containing the occupied entry and the value is returned.\n\n        Args:\n            key (K): The key to insert.\n            value (V): The value associated with the key.\n\n        Returns:\n            Result[V, KeyError]: `Ok` containing the value if the **key** was not present, or `Err` containing a `KeyError` if the **key** already existed.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; d = pc.Dict.new()\n        &gt;&gt;&gt; d.try_insert(37, \"a\").unwrap()\n        'a'\n        &gt;&gt;&gt; d.try_insert(37, \"b\")\n        Err(KeyError('Key 37 already exists with value a.'))\n\n        ```\n        \"\"\"\n        if key in self:\n            return Err(KeyError(f\"Key {key} already exists with value {self[key]}.\"))\n        self[key] = value\n        return Ok(value)\n\n    def remove(self, key: K) -&gt; Option[V]:\n        \"\"\"Remove a **key** from the `MutableMapping` and return its value if it existed.\n\n        Equivalent to `dict.pop(key, None)`, with an `Option` return type.\n\n        Args:\n            key (K): The key to remove.\n\n        Returns:\n            Option[V]: The value associated with the removed **key**, or `None` if the **key** was not present.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.remove(1)\n        Some('a')\n        &gt;&gt;&gt; data.remove(3)\n        NONE\n\n        ```\n        \"\"\"\n        return Option(self.pop(key, None))\n\n    def remove_entry(self, key: K) -&gt; Option[tuple[K, V]]:\n        \"\"\"Remove a key from the `MutableMapping` and return the item if it existed.\n\n        Return an `Option[tuple[K, V]]` containing the (key, value) pair if the key was present.\n\n        Args:\n            key (K): The key to remove.\n\n        Returns:\n            Option[tuple[K, V]]: `Some((key, value))` pair associated with the removed key, or `None` if the **key** was not present.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n        &gt;&gt;&gt; data.remove_entry(1)\n        Some((1, 'a'))\n        &gt;&gt;&gt; data.remove_entry(3)\n        NONE\n\n        ```\n        \"\"\"\n        return Some((key, self.pop(key))) if key in self else NONE\n\n    def get_item(self, key: K) -&gt; Option[V]:\n        \"\"\"Retrieve a value from the `MutableMapping`.\n\n        Returns `Some(value)` if the **key** exists, or `None` if it does not.\n\n        Args:\n            key (K): The key to look up.\n\n        Returns:\n            Option[V]: `Some(value)` that is associated with the **key**, or `None` if not found.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; data = {\"a\": 1}\n        &gt;&gt;&gt; pc.Dict(data).get_item(\"a\")\n        Some(1)\n        &gt;&gt;&gt; pc.Dict(data).get_item(\"x\").unwrap_or('Not Found')\n        'Not Found'\n\n        ```\n        \"\"\"\n        return Option(self.get(key, None))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableMapping"],"tags":[]},{"location":"reference/pyomutablemapping/#pyochain.traits._iterable.PyoMutableMapping.get_item","level":2,"title":"<code>get_item(key)</code>","text":"<p>Retrieve a value from the <code>MutableMapping</code>.</p> <p>Returns <code>Some(value)</code> if the key exists, or <code>None</code> if it does not.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to look up.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: <code>Some(value)</code> that is associated with the key, or <code>None</code> if not found.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = {\"a\": 1}\n&gt;&gt;&gt; pc.Dict(data).get_item(\"a\")\nSome(1)\n&gt;&gt;&gt; pc.Dict(data).get_item(\"x\").unwrap_or('Not Found')\n'Not Found'\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def get_item(self, key: K) -&gt; Option[V]:\n    \"\"\"Retrieve a value from the `MutableMapping`.\n\n    Returns `Some(value)` if the **key** exists, or `None` if it does not.\n\n    Args:\n        key (K): The key to look up.\n\n    Returns:\n        Option[V]: `Some(value)` that is associated with the **key**, or `None` if not found.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = {\"a\": 1}\n    &gt;&gt;&gt; pc.Dict(data).get_item(\"a\")\n    Some(1)\n    &gt;&gt;&gt; pc.Dict(data).get_item(\"x\").unwrap_or('Not Found')\n    'Not Found'\n\n    ```\n    \"\"\"\n    return Option(self.get(key, None))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableMapping"],"tags":[]},{"location":"reference/pyomutablemapping/#pyochain.traits._iterable.PyoMutableMapping.insert","level":2,"title":"<code>insert(key, value)</code>","text":"<p>Insert a key-value pair into the <code>MutableMapping</code>.</p> <p>If the <code>MutableMapping</code> did not have this key present, <code>NONE</code> is returned.</p> <p>If the <code>MutableMapping</code> did have this key present, the value is updated, and the old value is returned.</p> <p>The key is not updated.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to insert.</p> required <code>value</code> <code>V</code> <p>The value associated with the key.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: The previous value associated with the key, or None if the key was not present.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict.new()\n&gt;&gt;&gt; data.insert(37, \"a\")\nNONE\n&gt;&gt;&gt; data.is_empty()\nFalse\n\n&gt;&gt;&gt; data.insert(37, \"b\")\nSome('a')\n&gt;&gt;&gt; data.insert(37, \"c\")\nSome('b')\n&gt;&gt;&gt; data[37]\n'c'\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def insert(self, key: K, value: V) -&gt; Option[V]:\n    \"\"\"Insert a key-value pair into the `MutableMapping`.\n\n    If the `MutableMapping` did not have this **key** present, `NONE` is returned.\n\n    If the `MutableMapping` did have this **key** present, the **value** is updated, and the old value is returned.\n\n    The **key** is not updated.\n\n    Args:\n        key (K): The key to insert.\n        value (V): The value associated with the key.\n\n    Returns:\n        Option[V]: The previous value associated with the key, or None if the key was not present.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict.new()\n    &gt;&gt;&gt; data.insert(37, \"a\")\n    NONE\n    &gt;&gt;&gt; data.is_empty()\n    False\n\n    &gt;&gt;&gt; data.insert(37, \"b\")\n    Some('a')\n    &gt;&gt;&gt; data.insert(37, \"c\")\n    Some('b')\n    &gt;&gt;&gt; data[37]\n    'c'\n\n    ```\n    \"\"\"\n    previous = self.get(key, None)\n    self[key] = value\n    return Option(previous)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableMapping"],"tags":[]},{"location":"reference/pyomutablemapping/#pyochain.traits._iterable.PyoMutableMapping.remove","level":2,"title":"<code>remove(key)</code>","text":"<p>Remove a key from the <code>MutableMapping</code> and return its value if it existed.</p> <p>Equivalent to <code>dict.pop(key, None)</code>, with an <code>Option</code> return type.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>Option[V]</code> <p>Option[V]: The value associated with the removed key, or <code>None</code> if the key was not present.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.remove(1)\nSome('a')\n&gt;&gt;&gt; data.remove(3)\nNONE\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def remove(self, key: K) -&gt; Option[V]:\n    \"\"\"Remove a **key** from the `MutableMapping` and return its value if it existed.\n\n    Equivalent to `dict.pop(key, None)`, with an `Option` return type.\n\n    Args:\n        key (K): The key to remove.\n\n    Returns:\n        Option[V]: The value associated with the removed **key**, or `None` if the **key** was not present.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.remove(1)\n    Some('a')\n    &gt;&gt;&gt; data.remove(3)\n    NONE\n\n    ```\n    \"\"\"\n    return Option(self.pop(key, None))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableMapping"],"tags":[]},{"location":"reference/pyomutablemapping/#pyochain.traits._iterable.PyoMutableMapping.remove_entry","level":2,"title":"<code>remove_entry(key)</code>","text":"<p>Remove a key from the <code>MutableMapping</code> and return the item if it existed.</p> <p>Return an <code>Option[tuple[K, V]]</code> containing the (key, value) pair if the key was present.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>Option[tuple[K, V]]</code> <p>Option[tuple[K, V]]: <code>Some((key, value))</code> pair associated with the removed key, or <code>None</code> if the key was not present.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n&gt;&gt;&gt; data.remove_entry(1)\nSome((1, 'a'))\n&gt;&gt;&gt; data.remove_entry(3)\nNONE\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def remove_entry(self, key: K) -&gt; Option[tuple[K, V]]:\n    \"\"\"Remove a key from the `MutableMapping` and return the item if it existed.\n\n    Return an `Option[tuple[K, V]]` containing the (key, value) pair if the key was present.\n\n    Args:\n        key (K): The key to remove.\n\n    Returns:\n        Option[tuple[K, V]]: `Some((key, value))` pair associated with the removed key, or `None` if the **key** was not present.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; data = pc.Dict({1: \"a\", 2: \"b\"})\n    &gt;&gt;&gt; data.remove_entry(1)\n    Some((1, 'a'))\n    &gt;&gt;&gt; data.remove_entry(3)\n    NONE\n\n    ```\n    \"\"\"\n    return Some((key, self.pop(key))) if key in self else NONE\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableMapping"],"tags":[]},{"location":"reference/pyomutablemapping/#pyochain.traits._iterable.PyoMutableMapping.try_insert","level":2,"title":"<code>try_insert(key, value)</code>","text":"<p>Tries to insert a key-value pair into the <code>MutableMapping</code>, and returns a <code>Result[V, KeyError]</code> containing the value in the entry (if successful).</p> <p>If the <code>MutableMapping</code> already had this key present, nothing is updated, and an error containing the occupied entry and the value is returned.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>K</code> <p>The key to insert.</p> required <code>value</code> <code>V</code> <p>The value associated with the key.</p> required <p>Returns:</p> Type Description <code>Result[V, KeyError]</code> <p>Result[V, KeyError]: <code>Ok</code> containing the value if the key was not present, or <code>Err</code> containing a <code>KeyError</code> if the key already existed.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; d = pc.Dict.new()\n&gt;&gt;&gt; d.try_insert(37, \"a\").unwrap()\n'a'\n&gt;&gt;&gt; d.try_insert(37, \"b\")\nErr(KeyError('Key 37 already exists with value a.'))\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def try_insert(self, key: K, value: V) -&gt; Result[V, KeyError]:\n    \"\"\"Tries to insert a key-value pair into the `MutableMapping`, and returns a `Result[V, KeyError]` containing the value in the entry (if successful).\n\n    If the `MutableMapping` already had this **key** present, nothing is updated, and an error containing the occupied entry and the value is returned.\n\n    Args:\n        key (K): The key to insert.\n        value (V): The value associated with the key.\n\n    Returns:\n        Result[V, KeyError]: `Ok` containing the value if the **key** was not present, or `Err` containing a `KeyError` if the **key** already existed.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; d = pc.Dict.new()\n    &gt;&gt;&gt; d.try_insert(37, \"a\").unwrap()\n    'a'\n    &gt;&gt;&gt; d.try_insert(37, \"b\")\n    Err(KeyError('Key 37 already exists with value a.'))\n\n    ```\n    \"\"\"\n    if key in self:\n        return Err(KeyError(f\"Key {key} already exists with value {self[key]}.\"))\n    self[key] = value\n    return Ok(value)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableMapping"],"tags":[]},{"location":"reference/pyomutablesequence/","level":1,"title":"PyoMutableSequence","text":"<p>               Bases: <code>PyoSequence[T]</code>, <code>MutableSequence[T]</code></p> <p>Base trait for eager pyochain mutable sequence collections.</p> <p><code>PyoMutableSequence[T]</code> is the shared trait for concrete, eager mutable sequence-like collections: <code>Vec</code>.</p> <p>It extends <code>PyoSequence[T]</code> and <code>collections.abc.MutableSequence[T]</code>.</p> <p>This is equivalent to subclassing <code>collections.abc.MutableSequence[T]</code> (this trait already does), meaning any concrete subclass must implement the required <code>MutableSequence</code> dunder methods:</p> <ul> <li><code>__getitem__</code></li> <li><code>__setitem__</code></li> <li><code>__delitem__</code></li> <li><code>__len__</code></li> <li><code>insert</code></li> </ul> <p>On top of the standard <code>MutableSequence</code> protocol, it provides the additional pyochain API (from <code>PyoSequence</code>, <code>PyoCollection</code>, <code>Pipeable</code>, <code>Checkable</code>), and various methods inspired from Rust's <code>Vec</code> type.</p> <p>Those methods provides memory-efficient in-place operations.</p> <p>They are slower than simple <code>.extend()</code>, slices and <code>clear()</code> calls, but avoids all intermediate allocations, making them suitable for large collections where memory usage is a concern.</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoMutableSequence[T](PyoSequence[T], MutableSequence[T]):\n    \"\"\"Base trait for eager pyochain mutable sequence collections.\n\n    `PyoMutableSequence[T]` is the shared trait for concrete, eager mutable sequence-like\n    collections: `Vec`.\n\n    It extends `PyoSequence[T]` and `collections.abc.MutableSequence[T]`.\n\n    This is equivalent to subclassing `collections.abc.MutableSequence[T]` (this trait\n    already does), meaning any concrete subclass must implement the required\n    `MutableSequence` dunder methods:\n\n    - `__getitem__`\n    - `__setitem__`\n    - `__delitem__`\n    - `__len__`\n    - `insert`\n\n    On top of the standard `MutableSequence` protocol, it provides the additional\n    pyochain API (from `PyoSequence`, `PyoCollection`, `Pipeable`, `Checkable`), and various methods inspired from Rust's `Vec` type.\n\n    Those methods provides memory-efficient in-place operations.\n\n    They are slower than simple `.extend()`, slices and `clear()` calls, but avoids all intermediate allocations, making them suitable for large collections where memory usage is a concern.\n    \"\"\"\n\n    __slots__ = ()\n\n    def retain(self, predicate: Callable[[T], bool]) -&gt; None:\n        \"\"\"Retains only the elements specified by the *predicate*.\n\n        In other words, remove all elements e for which the *predicate* function returns `False`.\n\n        This method operates in place, visiting each element exactly once in forward order, and preserves the order of the retained elements.\n\n        Note:\n            This is similar to filtering, but operates in place without allocating a new collection once collected.\n\n            For example `new_list = list(filter(predicate, my_list))` followed by `my_list.clear()` would allocate a new collection before clearing the original, resulting in higher peak memory usage.\n\n        Args:\n            predicate (Callable[[T], bool]): A function that returns `True` for elements to keep and `False` for elements to remove.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4])\n        &gt;&gt;&gt; vec.retain(lambda x: x % 2 == 0)\n        &gt;&gt;&gt; vec\n        Vec(2, 4)\n\n        ```\n        External state may be used to decide which elements to keep.\n\n        ```python\n        &gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; keep = pc.Seq([False, True, True, False, True]).iter()\n        &gt;&gt;&gt; vec.retain(lambda _: next(keep))\n        &gt;&gt;&gt; vec\n        Vec(2, 3, 5)\n\n        ```\n        \"\"\"\n        write_idx = 0\n        length = len(self)\n        for read_idx in range(length):\n            if predicate(self[read_idx]):\n                self[write_idx] = self[read_idx]\n                write_idx += 1\n        pop = self.pop\n        while len(self) &gt; write_idx:\n            pop(write_idx)\n\n    def truncate(self, length: int) -&gt; None:\n        \"\"\"Shortens the `MutableSequence`, keeping the first *length* elements and dropping the rest.\n\n        If *length* is greater or equal to the `MutableSequence` current `__len__()`, this has no effect.\n\n        The `.drain()` method can emulate `.truncate()`, but causes the excess elements to be returned instead of dropped.\n\n        Note:\n            This is equivalent to `del seq[length:]`, except that it won't create an intermediate slice object.\n\n        Args:\n            length (int): The length to truncate the `MutableSequence` to.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; # Truncating a five element vector to two elements:\n        &gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4, 5])\n        &gt;&gt;&gt; vec.truncate(2)\n        &gt;&gt;&gt; vec\n        Vec(1, 2)\n\n        ```\n        No truncation occurs when len is greater than the `MutableSequence` current length:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; vec = pc.Vec([1, 2, 3])\n        &gt;&gt;&gt; vec.truncate(8)\n        &gt;&gt;&gt; vec\n        Vec(1, 2, 3)\n\n        ```\n        Truncating when len == 0 is equivalent to calling the clear method.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; vec = pc.Vec([1, 2, 3])\n        &gt;&gt;&gt; vec.truncate(0)\n        &gt;&gt;&gt; vec\n        Vec()\n\n        ```\n        \"\"\"\n        pop = self.pop\n        for _ in range(len(self) - length):\n            pop()\n\n    def extend_move(self, other: Self | list[T]) -&gt; None:\n        \"\"\"Moves all the elements of *other* into *self*, leaving *other* empty.\n\n        Note:\n            This is equivalent to `extend(other)` followed by `other.clear()`, but avoids intermediate allocations by moving elements one at a time.\n\n        Args:\n            other (Self | list[T]): The other `MutableSequence` to move elements from.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; v1 = pc.Vec([1, 2, 3])\n        &gt;&gt;&gt; v2 = pc.Vec([4, 5, 6])\n        &gt;&gt;&gt; v1.extend_move(v2)\n        &gt;&gt;&gt; v1\n        Vec(1, 2, 3, 4, 5, 6)\n        &gt;&gt;&gt; v2\n        Vec()\n\n        ```\n        \"\"\"\n        pop = functools.partial(other.pop, 0)\n        self.extend(pop() for _ in range(len(other)))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableSequence"],"tags":[]},{"location":"reference/pyomutablesequence/#pyochain.traits._iterable.PyoMutableSequence.extend_move","level":2,"title":"<code>extend_move(other)</code>","text":"<p>Moves all the elements of other into self, leaving other empty.</p> Note <p>This is equivalent to <code>extend(other)</code> followed by <code>other.clear()</code>, but avoids intermediate allocations by moving elements one at a time.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self | list[T]</code> <p>The other <code>MutableSequence</code> to move elements from.</p> required <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; v1 = pc.Vec([1, 2, 3])\n&gt;&gt;&gt; v2 = pc.Vec([4, 5, 6])\n&gt;&gt;&gt; v1.extend_move(v2)\n&gt;&gt;&gt; v1\nVec(1, 2, 3, 4, 5, 6)\n&gt;&gt;&gt; v2\nVec()\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def extend_move(self, other: Self | list[T]) -&gt; None:\n    \"\"\"Moves all the elements of *other* into *self*, leaving *other* empty.\n\n    Note:\n        This is equivalent to `extend(other)` followed by `other.clear()`, but avoids intermediate allocations by moving elements one at a time.\n\n    Args:\n        other (Self | list[T]): The other `MutableSequence` to move elements from.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; v1 = pc.Vec([1, 2, 3])\n    &gt;&gt;&gt; v2 = pc.Vec([4, 5, 6])\n    &gt;&gt;&gt; v1.extend_move(v2)\n    &gt;&gt;&gt; v1\n    Vec(1, 2, 3, 4, 5, 6)\n    &gt;&gt;&gt; v2\n    Vec()\n\n    ```\n    \"\"\"\n    pop = functools.partial(other.pop, 0)\n    self.extend(pop() for _ in range(len(other)))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableSequence"],"tags":[]},{"location":"reference/pyomutablesequence/#pyochain.traits._iterable.PyoMutableSequence.retain","level":2,"title":"<code>retain(predicate)</code>","text":"<p>Retains only the elements specified by the predicate.</p> <p>In other words, remove all elements e for which the predicate function returns <code>False</code>.</p> <p>This method operates in place, visiting each element exactly once in forward order, and preserves the order of the retained elements.</p> Note <p>This is similar to filtering, but operates in place without allocating a new collection once collected.</p> <p>For example <code>new_list = list(filter(predicate, my_list))</code> followed by <code>my_list.clear()</code> would allocate a new collection before clearing the original, resulting in higher peak memory usage.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[T], bool]</code> <p>A function that returns <code>True</code> for elements to keep and <code>False</code> for elements to remove.</p> required <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4])\n&gt;&gt;&gt; vec.retain(lambda x: x % 2 == 0)\n&gt;&gt;&gt; vec\nVec(2, 4)\n</code></pre> External state may be used to decide which elements to keep.</p> <pre><code>&gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4, 5])\n&gt;&gt;&gt; keep = pc.Seq([False, True, True, False, True]).iter()\n&gt;&gt;&gt; vec.retain(lambda _: next(keep))\n&gt;&gt;&gt; vec\nVec(2, 3, 5)\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def retain(self, predicate: Callable[[T], bool]) -&gt; None:\n    \"\"\"Retains only the elements specified by the *predicate*.\n\n    In other words, remove all elements e for which the *predicate* function returns `False`.\n\n    This method operates in place, visiting each element exactly once in forward order, and preserves the order of the retained elements.\n\n    Note:\n        This is similar to filtering, but operates in place without allocating a new collection once collected.\n\n        For example `new_list = list(filter(predicate, my_list))` followed by `my_list.clear()` would allocate a new collection before clearing the original, resulting in higher peak memory usage.\n\n    Args:\n        predicate (Callable[[T], bool]): A function that returns `True` for elements to keep and `False` for elements to remove.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4])\n    &gt;&gt;&gt; vec.retain(lambda x: x % 2 == 0)\n    &gt;&gt;&gt; vec\n    Vec(2, 4)\n\n    ```\n    External state may be used to decide which elements to keep.\n\n    ```python\n    &gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; keep = pc.Seq([False, True, True, False, True]).iter()\n    &gt;&gt;&gt; vec.retain(lambda _: next(keep))\n    &gt;&gt;&gt; vec\n    Vec(2, 3, 5)\n\n    ```\n    \"\"\"\n    write_idx = 0\n    length = len(self)\n    for read_idx in range(length):\n        if predicate(self[read_idx]):\n            self[write_idx] = self[read_idx]\n            write_idx += 1\n    pop = self.pop\n    while len(self) &gt; write_idx:\n        pop(write_idx)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableSequence"],"tags":[]},{"location":"reference/pyomutablesequence/#pyochain.traits._iterable.PyoMutableSequence.truncate","level":2,"title":"<code>truncate(length)</code>","text":"<p>Shortens the <code>MutableSequence</code>, keeping the first length elements and dropping the rest.</p> <p>If length is greater or equal to the <code>MutableSequence</code> current <code>__len__()</code>, this has no effect.</p> <p>The <code>.drain()</code> method can emulate <code>.truncate()</code>, but causes the excess elements to be returned instead of dropped.</p> Note <p>This is equivalent to <code>del seq[length:]</code>, except that it won't create an intermediate slice object.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>The length to truncate the <code>MutableSequence</code> to.</p> required <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; # Truncating a five element vector to two elements:\n&gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4, 5])\n&gt;&gt;&gt; vec.truncate(2)\n&gt;&gt;&gt; vec\nVec(1, 2)\n</code></pre> No truncation occurs when len is greater than the <code>MutableSequence</code> current length: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; vec = pc.Vec([1, 2, 3])\n&gt;&gt;&gt; vec.truncate(8)\n&gt;&gt;&gt; vec\nVec(1, 2, 3)\n</code></pre> Truncating when len == 0 is equivalent to calling the clear method. <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; vec = pc.Vec([1, 2, 3])\n&gt;&gt;&gt; vec.truncate(0)\n&gt;&gt;&gt; vec\nVec()\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def truncate(self, length: int) -&gt; None:\n    \"\"\"Shortens the `MutableSequence`, keeping the first *length* elements and dropping the rest.\n\n    If *length* is greater or equal to the `MutableSequence` current `__len__()`, this has no effect.\n\n    The `.drain()` method can emulate `.truncate()`, but causes the excess elements to be returned instead of dropped.\n\n    Note:\n        This is equivalent to `del seq[length:]`, except that it won't create an intermediate slice object.\n\n    Args:\n        length (int): The length to truncate the `MutableSequence` to.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; # Truncating a five element vector to two elements:\n    &gt;&gt;&gt; vec = pc.Vec([1, 2, 3, 4, 5])\n    &gt;&gt;&gt; vec.truncate(2)\n    &gt;&gt;&gt; vec\n    Vec(1, 2)\n\n    ```\n    No truncation occurs when len is greater than the `MutableSequence` current length:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; vec = pc.Vec([1, 2, 3])\n    &gt;&gt;&gt; vec.truncate(8)\n    &gt;&gt;&gt; vec\n    Vec(1, 2, 3)\n\n    ```\n    Truncating when len == 0 is equivalent to calling the clear method.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; vec = pc.Vec([1, 2, 3])\n    &gt;&gt;&gt; vec.truncate(0)\n    &gt;&gt;&gt; vec\n    Vec()\n\n    ```\n    \"\"\"\n    pop = self.pop\n    for _ in range(len(self) - length):\n        pop()\n</code></pre>","path":["API Reference","Traits & Mixins","PyoMutableSequence"],"tags":[]},{"location":"reference/pyosequence/","level":1,"title":"PyoSequence","text":"<p>               Bases: <code>PyoCollection[T]</code>, <code>Sequence[T]</code></p> <p>Base trait for eager pyochain sequences.</p> <p><code>PyoSequence[T]</code> is the shared trait for concrete, eager sequence-like collections: <code>Seq</code> and <code>Vec</code>.</p> <p>It extends <code>PyoCollection[T]</code> and <code>collections.abc.Sequence[T]</code>.</p> <p>This is equivalent to subclassing <code>collections.abc.Sequence[T]</code> (this trait already does), meaning any concrete subclass must implement the required <code>Sequence</code> dunder methods:</p> <ul> <li><code>__getitem__</code></li> <li><code>__len__</code></li> <li><code>__contains__</code></li> <li><code>__iter__</code></li> </ul> <p>On top of the standard <code>Sequence</code> protocol, it provides the additional pyochain API (from <code>PyoCollection</code>, <code>Pipeable</code>, <code>Checkable</code>, plus any helpers defined here).</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoSequence[T](PyoCollection[T], Sequence[T]):\n    \"\"\"Base trait for eager pyochain sequences.\n\n    `PyoSequence[T]` is the shared trait for concrete, eager sequence-like\n    collections: `Seq` and `Vec`.\n\n    It extends `PyoCollection[T]` and `collections.abc.Sequence[T]`.\n\n    This is equivalent to subclassing `collections.abc.Sequence[T]` (this trait\n    already does), meaning any concrete subclass must implement the required\n    `Sequence` dunder methods:\n\n    - `__getitem__`\n    - `__len__`\n    - `__contains__`\n    - `__iter__`\n\n    On top of the standard `Sequence` protocol, it provides the additional\n    pyochain API (from `PyoCollection`, `Pipeable`, `Checkable`, plus any helpers defined here).\n\n    \"\"\"\n\n    __slots__ = ()\n\n    @overload\n    def get(self, index: int) -&gt; Option[T]: ...\n    @overload\n    def get(self, index: slice) -&gt; Option[Sequence[T]]: ...\n    def get(self, index: int | slice) -&gt; Option[T] | Option[Sequence[T]]:\n        \"\"\"Return the element at the specified index as `Some(value)`, or `None` if the index is out of bounds.\n\n        Args:\n            index (int | slice): The index or slice of the element to retrieve.\n\n        Returns:\n            Option[T] | Option[Sequence[T]]: `Some(value)` if the index is valid, otherwise `None`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([10, 20, 30]).get(1)\n        Some(20)\n        &gt;&gt;&gt; pc.Seq([10, 20, 30]).get(5)\n        NONE\n\n        ```\n        \"\"\"\n        try:\n            return Some(self.__getitem__(index))  # pyright: ignore[reportReturnType]\n        except IndexError:\n            return NONE\n\n    def rev(self) -&gt; Iter[T]:\n        \"\"\"Return an `Iterator` with the elements of the `Sequence` in reverse order.\n\n        Returns:\n            Iter[T]: An `Iterator` with the elements in reverse order.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2, 3]).rev().collect()\n        Seq(3, 2, 1)\n\n        ```\n        \"\"\"\n        from .._iter import Iter\n\n        return Iter(reversed(self))\n\n    def is_distinct(self) -&gt; bool:\n        \"\"\"Return True if all items of the `Sequence` are distinct.\n\n        Returns:\n            bool: True if all items are distinct, False otherwise.\n\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\n        True\n\n        ```\n        \"\"\"\n        return cz.itertoolz.isdistinct(self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSequence"],"tags":[]},{"location":"reference/pyosequence/#pyochain.traits._iterable.PyoSequence.get","level":2,"title":"<code>get(index)</code>","text":"<pre><code>get(index: int) -&gt; Option[T]\n</code></pre><pre><code>get(index: slice) -&gt; Option[Sequence[T]]\n</code></pre> <p>Return the element at the specified index as <code>Some(value)</code>, or <code>None</code> if the index is out of bounds.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int | slice</code> <p>The index or slice of the element to retrieve.</p> required <p>Returns:</p> Type Description <code>Option[T] | Option[Sequence[T]]</code> <p>Option[T] | Option[Sequence[T]]: <code>Some(value)</code> if the index is valid, otherwise <code>None</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([10, 20, 30]).get(1)\nSome(20)\n&gt;&gt;&gt; pc.Seq([10, 20, 30]).get(5)\nNONE\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def get(self, index: int | slice) -&gt; Option[T] | Option[Sequence[T]]:\n    \"\"\"Return the element at the specified index as `Some(value)`, or `None` if the index is out of bounds.\n\n    Args:\n        index (int | slice): The index or slice of the element to retrieve.\n\n    Returns:\n        Option[T] | Option[Sequence[T]]: `Some(value)` if the index is valid, otherwise `None`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([10, 20, 30]).get(1)\n    Some(20)\n    &gt;&gt;&gt; pc.Seq([10, 20, 30]).get(5)\n    NONE\n\n    ```\n    \"\"\"\n    try:\n        return Some(self.__getitem__(index))  # pyright: ignore[reportReturnType]\n    except IndexError:\n        return NONE\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSequence"],"tags":[]},{"location":"reference/pyosequence/#pyochain.traits._iterable.PyoSequence.is_distinct","level":2,"title":"<code>is_distinct()</code>","text":"<p>Return True if all items of the <code>Sequence</code> are distinct.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all items are distinct, False otherwise.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\nTrue\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_distinct(self) -&gt; bool:\n    \"\"\"Return True if all items of the `Sequence` are distinct.\n\n    Returns:\n        bool: True if all items are distinct, False otherwise.\n\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2]).is_distinct()\n    True\n\n    ```\n    \"\"\"\n    return cz.itertoolz.isdistinct(self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSequence"],"tags":[]},{"location":"reference/pyosequence/#pyochain.traits._iterable.PyoSequence.rev","level":2,"title":"<code>rev()</code>","text":"<p>Return an <code>Iterator</code> with the elements of the <code>Sequence</code> in reverse order.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> with the elements in reverse order.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Seq([1, 2, 3]).rev().collect()\nSeq(3, 2, 1)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def rev(self) -&gt; Iter[T]:\n    \"\"\"Return an `Iterator` with the elements of the `Sequence` in reverse order.\n\n    Returns:\n        Iter[T]: An `Iterator` with the elements in reverse order.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Seq([1, 2, 3]).rev().collect()\n    Seq(3, 2, 1)\n\n    ```\n    \"\"\"\n    from .._iter import Iter\n\n    return Iter(reversed(self))\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSequence"],"tags":[]},{"location":"reference/pyoset/","level":1,"title":"PyoSet","text":"<p>               Bases: <code>PyoCollection[T]</code>, <code>Set[T]</code></p> <p>Base trait for eager pyochain set-like collections.</p> <p><code>PyoSet[T]</code> is the shared trait for concrete, eager set-like collections: <code>Set</code> and <code>FrozenSet</code>.</p> <p>It extends <code>PyoCollection[T]</code> and <code>collections.abc.Set[T]</code>.</p> <p>This is equivalent to subclassing <code>collections.abc.Set[T]</code> (this trait already does), meaning any concrete subclass must implement the required <code>Set</code> dunder methods:</p> <ul> <li><code>__contains__</code></li> <li><code>__iter__</code></li> <li><code>__len__</code></li> </ul> <p>On top of the standard <code>Set</code> protocol, it provides the additional pyochain API (from <code>PyoCollection</code>, <code>Pipeable</code>, <code>Checkable</code>, plus any helpers defined here).</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoSet[T](PyoCollection[T], AbstractSet[T]):\n    \"\"\"Base trait for eager pyochain set-like collections.\n\n    `PyoSet[T]` is the shared trait for concrete, eager set-like\n    collections: `Set` and `FrozenSet`.\n\n    It extends `PyoCollection[T]` and `collections.abc.Set[T]`.\n\n    This is equivalent to subclassing `collections.abc.Set[T]` (this trait\n    already does), meaning any concrete subclass must implement the required\n    `Set` dunder methods:\n\n    - `__contains__`\n    - `__iter__`\n    - `__len__`\n\n    On top of the standard `Set` protocol, it provides the additional\n    pyochain API (from `PyoCollection`, `Pipeable`, `Checkable`, plus any helpers defined here).\n\n    \"\"\"\n\n    __slots__ = ()\n\n    def is_subset(self, other: AbstractSet[T]) -&gt; bool:\n        \"\"\"Check if the `Set` is a subset of another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to compare with.\n\n        Returns:\n            bool: True if the `Set` is a subset of the other set, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2}).is_subset({1, 2, 3})\n        True\n        &gt;&gt;&gt; pc.Set({1, 4}).is_subset({1, 2, 3})\n        False\n\n        ```\n        \"\"\"\n        return self &lt;= other\n\n    def is_subset_strict(self, other: AbstractSet[T]) -&gt; bool:\n        \"\"\"Check if the `Set` is a proper subset of another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to compare with.\n\n        Returns:\n            bool: `True` if the `Set` is a proper subset of the other set, `False` otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2}).is_subset_strict({1, 2, 3})\n        True\n        &gt;&gt;&gt; pc.Set({1, 2}).is_subset_strict({1, 2})\n        False\n\n        ```\n        \"\"\"\n        return self &lt; other\n\n    def eq(self, other: AbstractSet[T]) -&gt; bool:\n        \"\"\"Check if the `Set` is equal to another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to compare with.\n\n        Returns:\n            bool: True if the `Set` is equal to the other set, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2}).eq({2, 1})\n        True\n        &gt;&gt;&gt; pc.Set({1, 2}).eq({1, 2, 3})\n        False\n\n        ```\n        \"\"\"\n        return self == other\n\n    def is_superset(self, other: AbstractSet[T]) -&gt; bool:\n        \"\"\"Check if the `Set` is a superset of another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to compare with.\n\n        Returns:\n            bool: True if the `Set` is a superset of the other set, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset({1, 2})\n        True\n        &gt;&gt;&gt; pc.Set({1, 2}).is_superset({1, 2, 3})\n        False\n\n        ```\n        \"\"\"\n        return self &gt;= other\n\n    def intersection(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the intersection of the `Set` with another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to intersect with.\n\n        Returns:\n            Self: A new `Set` containing the intersection of the two sets.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).intersection({2, 3})\n        Set(2,)\n\n        ```\n        \"\"\"\n        return self.__class__(self &amp; other)\n\n    def r_intersection(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the intersection of another set with the `Set`.\n\n        Args:\n            other (AbstractSet[T]): The other set to intersect with.\n\n        Returns:\n            Self: A new `Set` containing the intersection of the two sets.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({2, 3}).r_intersection({1, 2})\n        Set(2,)\n\n        ```\n        \"\"\"\n        return self.__class__(other &amp; self)\n\n    def union(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the union of the `Set` with another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to unite with.\n\n        Returns:\n            Self: A new `Set` containing the union of the two sets.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3]).union([4]).iter().sort()\n        Vec(1, 2, 3, 4)\n\n        ```\n        \"\"\"\n        return self.__class__(self | other)\n\n    def r_union(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the union of another set with the `Set`.\n\n        Args:\n            other (AbstractSet[T]): The other set to unite with.\n\n        Returns:\n            Self: A new `Set` containing the union of the two sets.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({2, 3}).r_union({1, 2}).iter().sort()\n        Vec(1, 2, 3)\n\n        ```\n        \"\"\"\n        return self.__class__(other | self)\n\n    def difference(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the difference of the `Set` with another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to subtract.\n\n        Returns:\n            Self: A new `Set` containing the difference of the two sets.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\n        Set(1,)\n\n        ```\n        \"\"\"\n        return self.__class__(self - other)\n\n    def r_difference(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the reverse difference of the `Set` with another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to subtract from.\n\n        Returns:\n            Self: A new `Set` containing the reverse difference of the two sets.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({2, 3}).r_difference({1, 2})\n        Set(1,)\n\n        ```\n        \"\"\"\n        return self.__class__(other - self)\n\n    def symmetric_difference(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the symmetric difference of the `Set` with another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to symmetric difference with.\n\n        Returns:\n            Self: A new `Set` containing the symmetric difference of the two sets.\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\n        Vec(1, 3)\n        &gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\n        Vec(1, 2, 4, 5)\n\n        ```\n        \"\"\"\n        return self.__class__(self ^ other)\n\n    def r_symmetric_difference(self, other: AbstractSet[T]) -&gt; Self:\n        \"\"\"Return the symmetric difference of the `Set` with another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to symmetric difference with.\n\n        Returns:\n            Self: A new `Set` containing the symmetric difference of the two sets.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({2, 3}).r_symmetric_difference({1, 2}).iter().sort()\n        Vec(1, 3)\n\n        ```\n        \"\"\"\n        return self.__class__(other ^ self)\n\n    def is_disjoint(self, other: AbstractSet[T]) -&gt; bool:\n        \"\"\"Check if the `Set` has no elements in common with another set.\n\n        Args:\n            other (AbstractSet[T]): The other set to compare with.\n\n        Returns:\n            bool: True if the `Set` and the other set have no elements in common, False otherwise.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint({3, 4})\n        True\n        &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint({2, 3})\n        False\n\n        ```\n        \"\"\"\n        return self.isdisjoint(other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.difference","level":2,"title":"<code>difference(other)</code>","text":"<p>Return the difference of the <code>Set</code> with another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to subtract.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the difference of the two sets.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\nSet(1,)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def difference(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the difference of the `Set` with another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to subtract.\n\n    Returns:\n        Self: A new `Set` containing the difference of the two sets.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).difference([2, 3])\n    Set(1,)\n\n    ```\n    \"\"\"\n    return self.__class__(self - other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.eq","level":2,"title":"<code>eq(other)</code>","text":"<p>Check if the <code>Set</code> is equal to another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the <code>Set</code> is equal to the other set, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).eq({2, 1})\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).eq({1, 2, 3})\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def eq(self, other: AbstractSet[T]) -&gt; bool:\n    \"\"\"Check if the `Set` is equal to another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to compare with.\n\n    Returns:\n        bool: True if the `Set` is equal to the other set, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).eq({2, 1})\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).eq({1, 2, 3})\n    False\n\n    ```\n    \"\"\"\n    return self == other\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.intersection","level":2,"title":"<code>intersection(other)</code>","text":"<p>Return the intersection of the <code>Set</code> with another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to intersect with.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the intersection of the two sets.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).intersection({2, 3})\nSet(2,)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def intersection(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the intersection of the `Set` with another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to intersect with.\n\n    Returns:\n        Self: A new `Set` containing the intersection of the two sets.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).intersection({2, 3})\n    Set(2,)\n\n    ```\n    \"\"\"\n    return self.__class__(self &amp; other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.is_disjoint","level":2,"title":"<code>is_disjoint(other)</code>","text":"<p>Check if the <code>Set</code> has no elements in common with another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the <code>Set</code> and the other set have no elements in common, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).is_disjoint({3, 4})\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).is_disjoint({2, 3})\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_disjoint(self, other: AbstractSet[T]) -&gt; bool:\n    \"\"\"Check if the `Set` has no elements in common with another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to compare with.\n\n    Returns:\n        bool: True if the `Set` and the other set have no elements in common, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint({3, 4})\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).is_disjoint({2, 3})\n    False\n\n    ```\n    \"\"\"\n    return self.isdisjoint(other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.is_subset","level":2,"title":"<code>is_subset(other)</code>","text":"<p>Check if the <code>Set</code> is a subset of another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the <code>Set</code> is a subset of the other set, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).is_subset({1, 2, 3})\nTrue\n&gt;&gt;&gt; pc.Set({1, 4}).is_subset({1, 2, 3})\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_subset(self, other: AbstractSet[T]) -&gt; bool:\n    \"\"\"Check if the `Set` is a subset of another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to compare with.\n\n    Returns:\n        bool: True if the `Set` is a subset of the other set, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).is_subset({1, 2, 3})\n    True\n    &gt;&gt;&gt; pc.Set({1, 4}).is_subset({1, 2, 3})\n    False\n\n    ```\n    \"\"\"\n    return self &lt;= other\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.is_subset_strict","level":2,"title":"<code>is_subset_strict(other)</code>","text":"<p>Check if the <code>Set</code> is a proper subset of another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the <code>Set</code> is a proper subset of the other set, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2}).is_subset_strict({1, 2, 3})\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).is_subset_strict({1, 2})\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_subset_strict(self, other: AbstractSet[T]) -&gt; bool:\n    \"\"\"Check if the `Set` is a proper subset of another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to compare with.\n\n    Returns:\n        bool: `True` if the `Set` is a proper subset of the other set, `False` otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2}).is_subset_strict({1, 2, 3})\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).is_subset_strict({1, 2})\n    False\n\n    ```\n    \"\"\"\n    return self &lt; other\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.is_superset","level":2,"title":"<code>is_superset(other)</code>","text":"<p>Check if the <code>Set</code> is a superset of another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the <code>Set</code> is a superset of the other set, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset({1, 2})\nTrue\n&gt;&gt;&gt; pc.Set({1, 2}).is_superset({1, 2, 3})\nFalse\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def is_superset(self, other: AbstractSet[T]) -&gt; bool:\n    \"\"\"Check if the `Set` is a superset of another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to compare with.\n\n    Returns:\n        bool: True if the `Set` is a superset of the other set, False otherwise.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 3}).is_superset({1, 2})\n    True\n    &gt;&gt;&gt; pc.Set({1, 2}).is_superset({1, 2, 3})\n    False\n\n    ```\n    \"\"\"\n    return self &gt;= other\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.r_difference","level":2,"title":"<code>r_difference(other)</code>","text":"<p>Return the reverse difference of the <code>Set</code> with another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to subtract from.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the reverse difference of the two sets.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({2, 3}).r_difference({1, 2})\nSet(1,)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def r_difference(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the reverse difference of the `Set` with another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to subtract from.\n\n    Returns:\n        Self: A new `Set` containing the reverse difference of the two sets.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({2, 3}).r_difference({1, 2})\n    Set(1,)\n\n    ```\n    \"\"\"\n    return self.__class__(other - self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.r_intersection","level":2,"title":"<code>r_intersection(other)</code>","text":"<p>Return the intersection of another set with the <code>Set</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to intersect with.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the intersection of the two sets.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({2, 3}).r_intersection({1, 2})\nSet(2,)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def r_intersection(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the intersection of another set with the `Set`.\n\n    Args:\n        other (AbstractSet[T]): The other set to intersect with.\n\n    Returns:\n        Self: A new `Set` containing the intersection of the two sets.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({2, 3}).r_intersection({1, 2})\n    Set(2,)\n\n    ```\n    \"\"\"\n    return self.__class__(other &amp; self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.r_symmetric_difference","level":2,"title":"<code>r_symmetric_difference(other)</code>","text":"<p>Return the symmetric difference of the <code>Set</code> with another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to symmetric difference with.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the symmetric difference of the two sets.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({2, 3}).r_symmetric_difference({1, 2}).iter().sort()\nVec(1, 3)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def r_symmetric_difference(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the symmetric difference of the `Set` with another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to symmetric difference with.\n\n    Returns:\n        Self: A new `Set` containing the symmetric difference of the two sets.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({2, 3}).r_symmetric_difference({1, 2}).iter().sort()\n    Vec(1, 3)\n\n    ```\n    \"\"\"\n    return self.__class__(other ^ self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.r_union","level":2,"title":"<code>r_union(other)</code>","text":"<p>Return the union of another set with the <code>Set</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to unite with.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the union of the two sets.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({2, 3}).r_union({1, 2}).iter().sort()\nVec(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def r_union(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the union of another set with the `Set`.\n\n    Args:\n        other (AbstractSet[T]): The other set to unite with.\n\n    Returns:\n        Self: A new `Set` containing the union of the two sets.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({2, 3}).r_union({1, 2}).iter().sort()\n    Vec(1, 2, 3)\n\n    ```\n    \"\"\"\n    return self.__class__(other | self)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.symmetric_difference","level":2,"title":"<code>symmetric_difference(other)</code>","text":"<p>Return the symmetric difference of the <code>Set</code> with another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to symmetric difference with.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the symmetric difference of the two sets.</p> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\nVec(1, 3)\n&gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\nVec(1, 2, 4, 5)\n</code></pre> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def symmetric_difference(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the symmetric difference of the `Set` with another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to symmetric difference with.\n\n    Returns:\n        Self: A new `Set` containing the symmetric difference of the two sets.\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).symmetric_difference([2, 3]).iter().sort()\n    Vec(1, 3)\n    &gt;&gt;&gt; pc.Set({1, 2, 3}).symmetric_difference([3, 4, 5]).iter().sort()\n    Vec(1, 2, 4, 5)\n\n    ```\n    \"\"\"\n    return self.__class__(self ^ other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyoset/#pyochain.traits._iterable.PyoSet.union","level":2,"title":"<code>union(other)</code>","text":"<p>Return the union of the <code>Set</code> with another set.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Set[T]</code> <p>The other set to unite with.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>A new <code>Set</code> containing the union of the two sets.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3]).union([4]).iter().sort()\nVec(1, 2, 3, 4)\n</code></pre></p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>def union(self, other: AbstractSet[T]) -&gt; Self:\n    \"\"\"Return the union of the `Set` with another set.\n\n    Args:\n        other (AbstractSet[T]): The other set to unite with.\n\n    Returns:\n        Self: A new `Set` containing the union of the two sets.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Set({1, 2, 2}).union([2, 3]).union([4]).iter().sort()\n    Vec(1, 2, 3, 4)\n\n    ```\n    \"\"\"\n    return self.__class__(self | other)\n</code></pre>","path":["API Reference","Traits & Mixins","PyoSet"],"tags":[]},{"location":"reference/pyovaluesview/","level":1,"title":"PyoValuesView","text":"<p>               Bases: <code>ValuesView[V]</code>, <code>PyoMappingView[V]</code></p> <p>A view of the values in a pyochain mapping.</p> <p>This class provides a view over the values contained in a pyochain mapping, with additional methods from the <code>PyoMappingView</code> and <code>PyoCollection</code> traits.</p> See Also <p><code>PyoMapping.values()</code>: Method that returns this view.</p> Source code in <code>src/pyochain/traits/_iterable.py</code> <pre><code>class PyoValuesView[V](ValuesView[V], PyoMappingView[V]):\n    \"\"\"A view of the values in a pyochain mapping.\n\n    This class provides a view over the values contained in a pyochain mapping, with\n    additional methods from the `PyoMappingView` and `PyoCollection` traits.\n\n    See Also:\n        `PyoMapping.values()`: Method that returns this view.\n    \"\"\"\n\n    __slots__ = ()\n</code></pre>","path":["API Reference","Traits & Mixins","PyoValuesView"],"tags":[]},{"location":"reference/result/","level":1,"title":"Result","text":"<p>               Bases: <code>Pipeable</code>, <code>ABC</code></p> <p><code>Result[T, E]</code> is the type used for returning and propagating errors.</p> <p>It is a class that can represent two variants, <code>Ok[T]</code>, representing success and containing a value, and <code>Err[E]</code>, representing error and containing an error value.</p> <p>Functions return <code>Result</code> whenever errors are expected and recoverable.</p> <p>For example, I/O or web requests can fail for many reasons, and using <code>Result</code> forces the caller to handle the possibility of failure.</p> <p>This is directly inspired by Rust's <code>Result</code> type, and provides similar functionality for error handling in Python.</p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.and_","level":2,"title":"<code>and_(res)</code>","text":"<p>Returns <code>res</code> if the result is <code>Ok</code>, otherwise returns the <code>Err</code> value.</p> <p>This is often used for chaining operations that might fail.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>Result[U, E]</code> <p>The result to return if the original result is <code>Ok</code>.</p> required <p>Returns:</p> Type Description <code>Result[U, E]</code> <p>Result[U, E]: <code>res</code> if the original result is <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x = pc.Ok(2)\n&gt;&gt;&gt; y = pc.Err(\"late error\")\n&gt;&gt;&gt; x.and_(y)\nErr('late error')\n&gt;&gt;&gt; x = pc.Err(\"early error\")\n&gt;&gt;&gt; y = pc.Ok(\"foo\")\n&gt;&gt;&gt; x.and_(y)\nErr('early error')\n\n&gt;&gt;&gt; x = pc.Err(\"not a 2\")\n&gt;&gt;&gt; y = pc.Err(\"late error\")\n&gt;&gt;&gt; x.and_(y)\nErr('not a 2')\n\n&gt;&gt;&gt; x = pc.Ok(2)\n&gt;&gt;&gt; y = pc.Ok(\"different result type\")\n&gt;&gt;&gt; x.and_(y)\nOk('different result type')\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.and_then","level":2,"title":"<code>and_then(fn, *args, **kwargs)</code>","text":"<p>Calls a function if the result is <code>Ok</code>, otherwise returns the <code>Err</code> value.</p> <p>This is often used for chaining operations that might fail.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[T, P], Result[R, E]]</code> <p>The function to call with the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[R, E]</code> <p>Result[R, E]: The result of the function if <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def to_str(x: int) -&gt; Result[str, str]:\n...     return pc.Ok(str(x))\n&gt;&gt;&gt; pc.Ok(2).and_then(to_str)\nOk('2')\n&gt;&gt;&gt; pc.Err(\"error\").and_then(to_str)\nErr('error')\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.and_then_star","level":2,"title":"<code>and_then_star(func)</code>","text":"<pre><code>and_then_star(\n    func: Callable[[Any], Result[R, E]],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2], Result[R, E]],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3], Result[R, E]],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3, T4], Result[R, E]],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3, T4, T5], Result[R, E]],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], Result[R, E]],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7], Result[R, E]\n    ],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8], Result[R, E]\n    ],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9], Result[R, E]\n    ],\n) -&gt; Result[R, E]\n</code></pre><pre><code>and_then_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10],\n        Result[R, E],\n    ],\n) -&gt; Result[R, E]\n</code></pre> <p>Calls a function if the result is <code>Ok</code>, unpacking the tuple.</p> <p>Done by applying a function to a contained <code>Ok</code> value (which is expected to be a tuple).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Result[R, E]]</code> <p>The function to call with the unpacked <code>Ok</code> value.</p> required <p>Returns:</p> Type Description <code>Result[R, E]</code> <p>Result[R, E]: The result of the function if <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def to_str(x: int, y: int) -&gt; pc.Result[str, str]:\n...     return pc.Ok(f\"{x},{y}\")\n&gt;&gt;&gt; pc.Ok((2, 3)).and_then_star(to_str)\nOk('2,3')\n&gt;&gt;&gt; pc.Err(\"error\").and_then_star(to_str)\nErr('error')\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.err","level":2,"title":"<code>err()</code>","text":"<p>Converts from <code>Result[T, E]</code> to <code>Option[E]</code>.</p> <p><code>Err(e)</code> becomes <code>Some(e)</code>, and <code>Ok(v)</code> becomes <code>None</code>.</p> <p>Returns:</p> Type Description <code>Option[E]</code> <p>Option[E]: An <code>Option</code> containing the <code>Err</code> value, or <code>None</code> if the result is <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).err()\nNONE\n&gt;&gt;&gt; pc.Err(\"error\").err()\nSome('error')\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.expect","level":2,"title":"<code>expect(msg)</code>","text":"<p>Returns the contained <code>Ok</code> value.</p> <p>Raises an exception with a provided message if the value is an <code>Err</code>.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to include in the exception if the result is <code>Err</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).expect(\"No error\")\n2\n&gt;&gt;&gt; pc.Err(\"emergency failure\").expect(\"Testing expect\")\nTraceback (most recent call last):\n...\nResultUnwrapError: Testing expect: 'emergency failure'\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.expect_err","level":2,"title":"<code>expect_err(msg)</code>","text":"<p>Returns the contained <code>Err</code> value.</p> <p>Raises an exception with a provided message if the value is an <code>Ok</code>.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to include in the exception if the result is <code>Ok</code>.</p> required <p>Returns:</p> Name Type Description <code>E</code> <code>E</code> <p>The contained <code>Err</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"emergency failure\").expect_err(\"Testing expect_err\")\n'emergency failure'\n&gt;&gt;&gt; pc.Ok(10).expect_err(\"Testing expect_err\")\nTraceback (most recent call last):\n...\nResultUnwrapError: Testing expect_err: expected Err, got Ok(10)\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.flatten","level":2,"title":"<code>flatten()</code>","text":"<p>Flattens a nested <code>Result</code>.</p> <p>Converts from <code>Result[Result[T, E], E]</code> to <code>Result[T, E]</code>.</p> <p>Equivalent to calling <code>Result.and_then(lambda x: x)</code>, but more convenient when there's no need to process the inner <code>Ok</code> value.</p> <p>Returns:</p> Type Description <code>Result[T1, E1]</code> <p>Result[T, E]: The flattened result.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; nested_ok: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Ok(2))\n&gt;&gt;&gt; nested_ok.flatten()\nOk(2)\n&gt;&gt;&gt; nested_err: pc.Result[pc.Result[int, str], str] = pc.Ok(pc.Err(\"inner error\"))\n&gt;&gt;&gt; nested_err.flatten()\nErr('inner error')\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.inspect","level":2,"title":"<code>inspect(fn, *args, **kwargs)</code>","text":"<p>Applies a function to the contained <code>Ok</code> value, returning the original <code>Result</code>.</p> <p>This is primarily useful for debugging or logging, allowing side effects to be performed on the <code>Ok</code> value without changing the result.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[T, P], object]</code> <p>Function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The original result, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; seen: list[int] = []\n&gt;&gt;&gt; pc.Ok(2).inspect(lambda x: seen.append(x))\nOk(2)\n&gt;&gt;&gt; seen\n[2]\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.inspect_err","level":2,"title":"<code>inspect_err(fn, *args, **kwargs)</code>","text":"<p>Applies a function to the contained <code>Err</code> value, returning the original <code>Result</code>.</p> <p>This mirrors :meth:<code>inspect</code> but operates on the error value. It is useful for logging or debugging error paths while keeping the <code>Result</code> unchanged.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], object]</code> <p>Function to apply to the <code>Err</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The original result, unchanged.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; seen: list[str] = []\n&gt;&gt;&gt; pc.Err(\"oops\").inspect_err(lambda e: seen.append(e))\nErr('oops')\n&gt;&gt;&gt; seen\n['oops']\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.is_err","level":2,"title":"<code>is_err()</code>","text":"<p>Returns <code>True</code> if the result is <code>Err</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the result is an <code>Err</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n&gt;&gt;&gt; x.is_err()\nFalse\n&gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n&gt;&gt;&gt; y.is_err()\nTrue\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.is_err_and","level":2,"title":"<code>is_err_and(pred, *args, **kwargs)</code>","text":"<p>Returns True if the result is Err and the predicate is true for the error value.</p> <p>Parameters:</p> Name Type Description Default <code>pred</code> <code>Callable[Concatenate[E, P], bool]</code> <p>Predicate function to apply to the Err value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to pred.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to pred.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if Err and pred(error) is true, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"foo\").is_err_and(lambda e: len(e) == 3)\nTrue\n&gt;&gt;&gt; pc.Err(\"bar\").is_err_and(lambda e: e == \"baz\")\nFalse\n&gt;&gt;&gt; pc.Ok(2).is_err_and(lambda e: True)\nFalse\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.is_ok","level":2,"title":"<code>is_ok()</code>","text":"<p>Returns <code>True</code> if the result is <code>Ok</code>.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the result is an <code>Ok</code> variant, <code>False</code> otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; x: pc.Result[int, str] = pc.Ok(2)\n&gt;&gt;&gt; x.is_ok()\nTrue\n&gt;&gt;&gt; y: pc.Result[int, str] = pc.Err(\"Some error message\")\n&gt;&gt;&gt; y.is_ok()\nFalse\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.is_ok_and","level":2,"title":"<code>is_ok_and(pred, *args, **kwargs)</code>","text":"<p>Returns True if the result is <code>Ok</code> and the predicate is true for the contained value.</p> <p>Parameters:</p> Name Type Description Default <code>pred</code> <code>Callable[Concatenate[T, P], bool]</code> <p>Predicate function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to pred.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to pred.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if <code>Ok</code> and pred(value) is true, False otherwise.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).is_ok_and(lambda x: x &gt; 1)\nTrue\n&gt;&gt;&gt; pc.Ok(0).is_ok_and(lambda x: x &gt; 1)\nFalse\n&gt;&gt;&gt; pc.Err(\"err\").is_ok_and(lambda x: x &gt; 1)\nFalse\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.iter","level":2,"title":"<code>iter()</code>","text":"<p>Returns a <code>Iter[T]</code> over the possibly contained value.</p> <p>The iterator yields one value if the result is <code>Ok</code>, otherwise none.</p> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An iterator over the <code>Ok</code> value, or empty if <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(7).iter().next()\nSome(7)\n&gt;&gt;&gt; pc.Err(\"nothing!\").iter().next()\nNONE\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.map","level":2,"title":"<code>map(fn, *args, **kwargs)</code>","text":"<p>Maps a <code>Result[T, E]</code> to <code>Result[U, E]</code>.</p> <p>Done by applying a function to a contained <code>Ok</code> value, leaving an <code>Err</code> value untouched.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[T, P], R]</code> <p>The function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[R, E]</code> <p>Result[R, E]: A new <code>Result</code> with the mapped value if <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).map(lambda x: x * 2)\nOk(4)\n&gt;&gt;&gt; pc.Err(\"error\").map(lambda x: x * 2)\nErr('error')\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.map_err","level":2,"title":"<code>map_err(fn, *args, **kwargs)</code>","text":"<p>Maps a <code>Result[T, E]</code> to <code>Result[T, R]</code>.</p> <p>Done by applying a function to a contained <code>Err</code> value, leaving an <code>Ok</code> value untouched.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], R]</code> <p>The function to apply to the <code>Err</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, R]</code> <p>Result[T, R]: A new <code>Result</code> with the mapped error if <code>Err</code>, otherwise the original <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).map_err(len)\nOk(2)\n&gt;&gt;&gt; pc.Err(\"foo\").map_err(len)\nErr(3)\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.map_or","level":2,"title":"<code>map_or(default, f, *args, **kwargs)</code>","text":"<p>Applies a function to the <code>Ok</code> value if present, otherwise returns the default value.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>R</code> <p>Value to return if the result is Err.</p> required <code>f</code> <code>Callable[Concatenate[T, P], R]</code> <p>Function to apply to the <code>Ok</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to f.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to f.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>R</code> <code>R</code> <p>Result of f(value) if Ok, otherwise default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).map_or(10, lambda x: x * 2)\n4\n&gt;&gt;&gt; pc.Err(\"err\").map_or(10, lambda x: x * 2)\n10\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.map_or_else","level":2,"title":"<code>map_or_else(ok, err)</code>","text":"<p>Maps a <code>Result[T, E]</code> to <code>U</code>.</p> <p>Done by applying a fallback function to a contained <code>Err</code> value, or a default function to a contained <code>Ok</code> value.</p> <p>Parameters:</p> Name Type Description Default <code>ok</code> <code>Callable[[T], U]</code> <p>The function to apply to the <code>Ok</code> value.</p> required <code>err</code> <code>Callable[[E], U]</code> <p>The function to apply to the <code>Err</code> value.</p> required <p>Returns:</p> Name Type Description <code>U</code> <code>U</code> <p>The result of applying the appropriate function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; k = 21\n&gt;&gt;&gt; pc.Ok(\"foo\").map_or_else(len, lambda e: k * 2)\n3\n&gt;&gt;&gt; pc.Err(\"bar\").map_or_else(len, lambda e: k * 2)\n42\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.map_star","level":2,"title":"<code>map_star(func)</code>","text":"<pre><code>map_star(func: Callable[[Any], R]) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2], R]) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(func: Callable[[T1, T2, T3], R]) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4], R],\n) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5], R],\n) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6], R],\n) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7], R],\n) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8], R],\n) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(\n    func: Callable[[T1, T2, T3, T4, T5, T6, T7, T8, T9], R],\n) -&gt; Result[R, E]\n</code></pre><pre><code>map_star(\n    func: Callable[\n        [T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], R\n    ],\n) -&gt; Result[R, E]\n</code></pre> <p>Maps a <code>Result[tuple, E]</code> to <code>Result[R, E]</code> by unpacking the tuple.</p> <p>Done by applying a function to a contained <code>Ok</code> value (which is expected to be a tuple).</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., R]</code> <p>The function to apply to the unpacked <code>Ok</code> value.</p> required <p>Returns:</p> Type Description <code>Result[R, E]</code> <p>Result[R, E]: A new <code>Result</code> with the mapped value if <code>Ok</code>, otherwise the original <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok((2, 3)).map_star(lambda x, y: x + y)\nOk(5)\n&gt;&gt;&gt; pc.Err(\"error\").map_star(lambda x, y: x + y)\nErr('error')\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.ok","level":2,"title":"<code>ok()</code>","text":"<p>Converts from <code>Result[T, E]</code> to <code>Option[T]</code>.</p> <p><code>Ok(v)</code> becomes <code>Some(v)</code>, and <code>Err(e)</code> becomes <code>None</code>.</p> <p>Returns:</p> Type Description <code>Option[T]</code> <p>Option[T]: An <code>Option</code> containing the <code>Ok</code> value, or <code>None</code> if the result is <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).ok()\nSome(2)\n&gt;&gt;&gt; pc.Err(\"error\").ok()\nNONE\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.or_","level":2,"title":"<code>or_(res)</code>","text":"<p>Returns res if the result is <code>Err</code>, otherwise returns the <code>Ok</code> value of self.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>Result[T, F]</code> <p>The result to return if the original result is <code>Err</code>.</p> required <p>Returns:</p> Type Description <code>Result[T, F]</code> <p>Result[T, F]: The original <code>Ok</code> value, or <code>res</code> if the original result is <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).or_(pc.Err(\"late error\"))\nOk(2)\n&gt;&gt;&gt; pc.Err(\"early error\").or_(pc.Ok(2))\nOk(2)\n&gt;&gt;&gt; pc.Err(\"not a 2\").or_(pc.Err(\"late error\"))\nErr('late error')\n&gt;&gt;&gt; pc.Ok(2).or_(pc.Ok(100))\nOk(2)\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.or_else","level":2,"title":"<code>or_else(fn, *args, **kwargs)</code>","text":"<p>Calls a function if the result is <code>Err</code>, otherwise returns the <code>Ok</code> value.</p> <p>This is often used for handling errors by trying an alternative operation.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], Result[T, E]]</code> <p>The function to call with the <code>Err</code> value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Result[T, E]</code> <p>Result[T, E]: The original <code>Ok</code> value, or the result of the function if <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; def fallback(e: str) -&gt; Result[int, str]:\n...     return pc.Ok(len(e))\n&gt;&gt;&gt; pc.Ok(2).or_else(fallback)\nOk(2)\n&gt;&gt;&gt; pc.Err(\"foo\").or_else(fallback)\nOk(3)\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.transpose","level":2,"title":"<code>transpose()</code>","text":"<p>Transposes a Result containing an Option into an Option containing a Result.</p> <p>Can only be called if the inner type is <code>Option[T, E]</code>.</p> <p><code>Ok(Some(v)) -&gt; Some(Ok(v)), Ok(NONE) -&gt; NONE, Err(e) -&gt; Some(Err(e))</code></p> <p>Returns:</p> Type Description <code>Option[Result[T, E]]</code> <p>Option[Result[T, E]]: Option containing a Result or NONE.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(pc.Some(2)).transpose()\nSome(Ok(2))\n&gt;&gt;&gt; pc.Ok(pc.NONE).transpose()\nNONE\n&gt;&gt;&gt; pc.Err(\"err\").transpose()\nSome(Err('err'))\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.unwrap","level":2,"title":"<code>unwrap()</code>","text":"<p>Returns the contained <code>Ok</code> value.</p> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Err</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap()\nTraceback (most recent call last):\n...\nResultUnwrapError: called `unwrap` on an `Err`: 'emergency failure'\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.unwrap_err","level":2,"title":"<code>unwrap_err()</code>","text":"<p>Returns the contained <code>Err</code> value.</p> <p>Returns:</p> Name Type Description <code>E</code> <code>E</code> <p>The contained <code>Err</code> value.</p> <p>Raises:</p> Type Description <code>ResultUnwrapError</code> <p>If the result is <code>Ok</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Err(\"emergency failure\").unwrap_err()\n'emergency failure'\n</code></pre> <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap_err()\nTraceback (most recent call last):\n...\nResultUnwrapError: called `unwrap_err` on Ok\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.unwrap_or","level":2,"title":"<code>unwrap_or(default)</code>","text":"<p>Returns the contained <code>Ok</code> value or a provided default.</p> <p>Parameters:</p> Name Type Description Default <code>default</code> <code>T</code> <p>The value to return if the result is <code>Err</code>.</p> required <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value or the provided default.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap_or(10)\n2\n&gt;&gt;&gt; pc.Err(\"error\").unwrap_or(10)\n10\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/result/#pyochain.rs.Result.unwrap_or_else","level":2,"title":"<code>unwrap_or_else(fn, *args, **kwargs)</code>","text":"<p>Returns the contained <code>Ok</code> value or computes it from a function.</p> <p>Parameters:</p> Name Type Description Default <code>fn</code> <code>Callable[Concatenate[E, P], T]</code> <p>A function that takes the <code>Err</code> value and returns a default value.</p> required <code>*args</code> <code>P.args</code> <p>Additional positional arguments to pass to fn.</p> <code>()</code> <code>**kwargs</code> <code>P.kwargs</code> <p>Additional keyword arguments to pass to fn.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>T</code> <code>T</code> <p>The contained <code>Ok</code> value or the result of the function.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Ok(2).unwrap_or_else(len)\n2\n&gt;&gt;&gt; pc.Err(\"foo\").unwrap_or_else(len)\n3\n</code></pre></p>","path":["API Reference","Error Handling","Result"],"tags":[]},{"location":"reference/resultunwraperror/","level":1,"title":"ResultUnwrapError","text":"<p>               Bases: <code>RuntimeError</code></p>","path":["API Reference","Error Handling","ResultUnwrapError"],"tags":[]},{"location":"reference/seq/","level":1,"title":"Seq","text":"<p>               Bases: <code>PyoSequence[T]</code></p> <p>Represent an in memory <code>Sequence</code>.</p> <p>Implements the <code>Sequence</code> Protocol from <code>collections.abc</code>.</p> <p>Provides a subset of <code>Iter</code> methods with eager evaluation, and is the return type of <code>Iter.collect()</code>.</p> <p>The underlying data structure is an immutable <code>tuple</code>, hence the memory efficiency is better than a <code>Vec</code>.</p> Tip <p><code>Seq(tuple)</code> is preferred over <code>Seq(list)</code> as this is a no-copy operation (Python optimizes <code>tuple</code> creation from another <code>tuple</code>). If you have an existing <code>list</code>, consider using <code>Vec.from_ref()</code> instead to avoid unnecessary copying.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The data to initialize the Seq with.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Seq[T](PyoSequence[T]):\n    \"\"\"Represent an in memory `Sequence`.\n\n    Implements the `Sequence` Protocol from `collections.abc`.\n\n    Provides a subset of `Iter` methods with eager evaluation, and is the return type of `Iter.collect()`.\n\n    The underlying data structure is an immutable `tuple`, hence the memory efficiency is better than a `Vec`.\n\n    Tip:\n        `Seq(tuple)` is preferred over `Seq(list)` as this is a no-copy operation (Python optimizes `tuple` creation from another `tuple`).\n        If you have an existing `list`, consider using `Vec.from_ref()` instead to avoid unnecessary copying.\n\n    Args:\n            data (Iterable[T]): The data to initialize the Seq with.\n    \"\"\"\n\n    __slots__ = (\"_inner\",)\n    _inner: tuple[T, ...]\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = tuple(data)\n\n    def __iter__(self) -&gt; Iterator[T]:\n        return iter(self._inner)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({_get_repr(self._inner)})\"\n\n    def __len__(self) -&gt; int:\n        return len(self._inner)\n\n    @overload\n    def __getitem__(self, index: int) -&gt; T: ...\n    @overload\n    def __getitem__(self, index: slice) -&gt; Sequence[T]: ...\n    def __getitem__(self, index: int | slice[Any, Any, Any]) -&gt; T | Sequence[T]:\n        return self._inner.__getitem__(index)\n</code></pre>","path":["API Reference","Collections","Seq"],"tags":[]},{"location":"reference/set/","level":1,"title":"Set","text":"<p>               Bases: <code>PyoSet[T]</code></p> <p><code>Set</code> represent an in- memory unordered  collection of unique elements.</p> <p>Implements the <code>Collection</code> Protocol from <code>collections.abc</code>, so it can be used as a standard immutable collection.</p> <p>The underlying data structure is a <code>frozenset</code>.</p> Tip <ul> <li><code>Set(frozenset)</code> is a no-copy operation since Python optimizes this under the hood.</li> <li>If you have an existing <code>set</code>, prefer using <code>SetMut.from_ref()</code> to avoid unnecessary copying.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The data to initialize the Set with.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Set[T](PyoSet[T]):\n    \"\"\"`Set` represent an in- memory **unordered**  collection of **unique** elements.\n\n    Implements the `Collection` Protocol from `collections.abc`, so it can be used as a standard immutable collection.\n\n    The underlying data structure is a `frozenset`.\n\n    Tip:\n        - `Set(frozenset)` is a no-copy operation since Python optimizes this under the hood.\n        - If you have an existing `set`, prefer using `SetMut.from_ref()` to avoid unnecessary copying.\n\n    Args:\n            data (Iterable[T]): The data to initialize the Set with.\n    \"\"\"\n\n    __slots__ = (\"_inner\",)\n    __match_args__ = (\"_inner\",)\n    _inner: frozenset[T]\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = frozenset(data)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({_get_repr(self._inner)})\"\n\n    def __contains__(self, item: object) -&gt; bool:\n        return item in self._inner\n\n    def __iter__(self) -&gt; Iterator[T]:\n        return iter(self._inner)\n\n    def __len__(self) -&gt; int:\n        return len(self._inner)\n</code></pre>","path":["API Reference","Collections","Set"],"tags":[]},{"location":"reference/setmut/","level":1,"title":"SetMut","text":"<p>               Bases: <code>Set[T]</code>, <code>MutableSet[T]</code></p> <p>A mutable <code>set</code> wrapper with functional API.</p> <p>Unlike <code>Set</code> which is immutable, <code>SetMut</code> allows in-place modification of elements.</p> <p>Implement the <code>MutableSet</code> interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable <code>set</code>.</p> <p>Underlying data structure is a <code>set</code>.</p> Tip <p>If you have an existing <code>set</code>, prefer using <code>SetMut.from_ref()</code> to avoid unnecessary copying.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The mutable set to wrap.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class SetMut[T](Set[T], MutableSet[T]):\n    \"\"\"A mutable `set` wrapper with functional API.\n\n    Unlike `Set` which is immutable, `SetMut` allows in-place modification of elements.\n\n    Implement the `MutableSet` interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable `set`.\n\n    Underlying data structure is a `set`.\n\n    Tip:\n        If you have an existing `set`, prefer using `SetMut.from_ref()` to avoid unnecessary copying.\n\n    Args:\n        data (Iterable[T]): The mutable set to wrap.\n    \"\"\"\n\n    __slots__ = ()\n    _inner: set[T]  # type: ignore[override]\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = set(data)  # type: ignore[override]\n\n    @staticmethod\n    def from_ref[V](data: set[V]) -&gt; SetMut[V]:\n        \"\"\"Create a `SetMut` from a reference to an existing `set`.\n\n        This method wraps the provided `set` without copying it, allowing for efficient object instanciation.\n\n        This is the recommended way to create a `SetMut` from foreign functions that return `set` objects.\n\n        Warning:\n            Since the `SetMut` directly references the original `set`, any modifications made to the `SetMut` will also affect the original `set`, and vice versa.\n\n        Args:\n            data (set[V]): The `set` to wrap.\n\n        Returns:\n            SetMut[V]: A new `SetMut` instance wrapping the provided `set`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; original_set = {1, 2, 3}\n        &gt;&gt;&gt; set_obj = pc.SetMut.from_ref(original_set)\n        &gt;&gt;&gt; set_obj\n        SetMut(1, 2, 3)\n        &gt;&gt;&gt; original_set.add(4)\n        &gt;&gt;&gt; set_obj\n        SetMut(1, 2, 3, 4)\n\n\n        ```\n        \"\"\"\n        instance: SetMut[V] = SetMut.__new__(SetMut)  # pyright: ignore[reportUnknownVariableType]\n        instance._inner = data\n        return instance\n\n    def add(self, value: T) -&gt; None:\n        \"\"\"Add an element to **self**.\n\n        Args:\n            value (T): The element to add.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; s = pc.SetMut({'a', 'b'})\n        &gt;&gt;&gt; s.add('c')\n        &gt;&gt;&gt; s.iter().sort()\n        Vec('a', 'b', 'c')\n\n        ```\n        \"\"\"\n        self._inner.add(value)\n\n    def discard(self, value: T) -&gt; None:\n        \"\"\"Remove an element from **self** if it is a member.\n\n        Unlike `.remove()`, the `discard()` method does not raise an exception when an element is missing from the set.\n\n        Args:\n            value (T): The element to remove.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; s = pc.SetMut({'a', 'b', 'c'})\n        &gt;&gt;&gt; s.discard('b')\n        &gt;&gt;&gt; s.iter().sort()\n        Vec('a', 'c')\n\n        ```\n        \"\"\"\n        self._inner.discard(value)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.add","level":2,"title":"<code>add(value)</code>","text":"<p>Add an element to self.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The element to add.</p> required <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; s = pc.SetMut({'a', 'b'})\n&gt;&gt;&gt; s.add('c')\n&gt;&gt;&gt; s.iter().sort()\nVec('a', 'b', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def add(self, value: T) -&gt; None:\n    \"\"\"Add an element to **self**.\n\n    Args:\n        value (T): The element to add.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; s = pc.SetMut({'a', 'b'})\n    &gt;&gt;&gt; s.add('c')\n    &gt;&gt;&gt; s.iter().sort()\n    Vec('a', 'b', 'c')\n\n    ```\n    \"\"\"\n    self._inner.add(value)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.discard","level":2,"title":"<code>discard(value)</code>","text":"<p>Remove an element from self if it is a member.</p> <p>Unlike <code>.remove()</code>, the <code>discard()</code> method does not raise an exception when an element is missing from the set.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>T</code> <p>The element to remove.</p> required <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; s = pc.SetMut({'a', 'b', 'c'})\n&gt;&gt;&gt; s.discard('b')\n&gt;&gt;&gt; s.iter().sort()\nVec('a', 'c')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def discard(self, value: T) -&gt; None:\n    \"\"\"Remove an element from **self** if it is a member.\n\n    Unlike `.remove()`, the `discard()` method does not raise an exception when an element is missing from the set.\n\n    Args:\n        value (T): The element to remove.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; s = pc.SetMut({'a', 'b', 'c'})\n    &gt;&gt;&gt; s.discard('b')\n    &gt;&gt;&gt; s.iter().sort()\n    Vec('a', 'c')\n\n    ```\n    \"\"\"\n    self._inner.discard(value)\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/setmut/#pyochain._iter.SetMut.from_ref","level":2,"title":"<code>from_ref(data)</code>  <code>staticmethod</code>","text":"<p>Create a <code>SetMut</code> from a reference to an existing <code>set</code>.</p> <p>This method wraps the provided <code>set</code> without copying it, allowing for efficient object instanciation.</p> <p>This is the recommended way to create a <code>SetMut</code> from foreign functions that return <code>set</code> objects.</p> Warning <p>Since the <code>SetMut</code> directly references the original <code>set</code>, any modifications made to the <code>SetMut</code> will also affect the original <code>set</code>, and vice versa.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>set[V]</code> <p>The <code>set</code> to wrap.</p> required <p>Returns:</p> Type Description <code>SetMut[V]</code> <p>SetMut[V]: A new <code>SetMut</code> instance wrapping the provided <code>set</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; original_set = {1, 2, 3}\n&gt;&gt;&gt; set_obj = pc.SetMut.from_ref(original_set)\n&gt;&gt;&gt; set_obj\nSetMut(1, 2, 3)\n&gt;&gt;&gt; original_set.add(4)\n&gt;&gt;&gt; set_obj\nSetMut(1, 2, 3, 4)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef from_ref[V](data: set[V]) -&gt; SetMut[V]:\n    \"\"\"Create a `SetMut` from a reference to an existing `set`.\n\n    This method wraps the provided `set` without copying it, allowing for efficient object instanciation.\n\n    This is the recommended way to create a `SetMut` from foreign functions that return `set` objects.\n\n    Warning:\n        Since the `SetMut` directly references the original `set`, any modifications made to the `SetMut` will also affect the original `set`, and vice versa.\n\n    Args:\n        data (set[V]): The `set` to wrap.\n\n    Returns:\n        SetMut[V]: A new `SetMut` instance wrapping the provided `set`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; original_set = {1, 2, 3}\n    &gt;&gt;&gt; set_obj = pc.SetMut.from_ref(original_set)\n    &gt;&gt;&gt; set_obj\n    SetMut(1, 2, 3)\n    &gt;&gt;&gt; original_set.add(4)\n    &gt;&gt;&gt; set_obj\n    SetMut(1, 2, 3, 4)\n\n\n    ```\n    \"\"\"\n    instance: SetMut[V] = SetMut.__new__(SetMut)  # pyright: ignore[reportUnknownVariableType]\n    instance._inner = data\n    return instance\n</code></pre>","path":["API Reference","Collections","SetMut"],"tags":[]},{"location":"reference/some/","level":1,"title":"Some","text":"<p>               Bases: <code>Option[T]</code></p> <p>Option variant representing the presence of a value.</p> <p>For more documentation, see the <code>Option[T]</code> class.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>T</code> <p>The contained value.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Some(42)\nSome(42)\n</code></pre></p>","path":["API Reference","Optional Values","Some"],"tags":[]},{"location":"reference/some/#pyochain.rs.Some.__new__","level":2,"title":"<code>__new__(value)</code>","text":"<p>Bypass Option's redirect by directly creating a Some instance.</p>","path":["API Reference","Optional Values","Some"],"tags":[]},{"location":"reference/unzipped/","level":1,"title":"Unzipped","text":"<p>               Bases: <code>Pipeable</code>, <code>Checkable</code></p> <p>Represents the result of unzipping an <code>Iter</code> of pairs into two separate <code>Iter</code>.</p> See Also <p><code>Iter.unzip()</code></p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pairs = pc.Iter(((1, 'a'), (2, 'b'), (3, 'c')))\n&gt;&gt;&gt; unzipped = pairs.unzip()\n&gt;&gt;&gt; unzipped.left.collect()\nSeq(1, 2, 3)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@dataclass(slots=True)\nclass Unzipped[T, V](Pipeable, Checkable):\n    \"\"\"Represents the result of unzipping an `Iter` of pairs into two separate `Iter`.\n\n    See Also:\n        `Iter.unzip()`\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pairs = pc.Iter(((1, 'a'), (2, 'b'), (3, 'c')))\n    &gt;&gt;&gt; unzipped = pairs.unzip()\n    &gt;&gt;&gt; unzipped.left.collect()\n    Seq(1, 2, 3)\n\n    ```\n    \"\"\"  # noqa: DOC601, DOC603\n\n    left: Iter[T]\n    \"\"\"An `Iter` over the first elements of the pairs.\"\"\"\n    right: Iter[V]\n    \"\"\"An `Iter` over the second elements of the pairs.\"\"\"\n\n    def __bool__(self) -&gt; bool:\n        return bool(self.left) and bool(self.right)\n</code></pre>","path":["API Reference","Iterators","Unzipped"],"tags":[]},{"location":"reference/unzipped/#pyochain._iter.Unzipped.left","level":2,"title":"<code>left</code>  <code>instance-attribute</code>","text":"<p>An <code>Iter</code> over the first elements of the pairs.</p>","path":["API Reference","Iterators","Unzipped"],"tags":[]},{"location":"reference/unzipped/#pyochain._iter.Unzipped.right","level":2,"title":"<code>right</code>  <code>instance-attribute</code>","text":"<p>An <code>Iter</code> over the second elements of the pairs.</p>","path":["API Reference","Iterators","Unzipped"],"tags":[]},{"location":"reference/vec/","level":1,"title":"Vec","text":"<p>               Bases: <code>Seq[T]</code>, <code>PyoMutableSequence[T]</code></p> <p>A <code>MutableSequence</code> wrapper with functional API.</p> <p>Implement <code>MutableSequence</code> Protocol from <code>collections.abc</code>.</p> <p>Unlike <code>Seq</code> which is immutable, <code>Vec</code> allows in-place modification of elements.</p> <p>Implement the <code>MutableSequence</code> interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable sequence.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[T]</code> <p>The <code>Iterable</code> to wrap.</p> required Source code in <code>src/pyochain/_iter.py</code> <pre><code>class Vec[T](Seq[T], PyoMutableSequence[T]):\n    \"\"\"A `MutableSequence` wrapper with functional API.\n\n    Implement `MutableSequence` Protocol from `collections.abc`.\n\n    Unlike `Seq` which is immutable, `Vec` allows in-place modification of elements.\n\n    Implement the `MutableSequence` interface, so elements can be modified in place, and passed to any function/object expecting a standard mutable sequence.\n\n    Args:\n        data (Iterable[T]): The `Iterable` to wrap.\n    \"\"\"\n\n    __slots__ = ()\n    _inner: list[T]  # type: ignore[override]\n\n    def __init__(self, data: Iterable[T]) -&gt; None:\n        self._inner = list(data)  # type: ignore[override]\n\n    @staticmethod\n    def from_ref[V](data: list[V]) -&gt; Vec[V]:\n        \"\"\"Create a `Vec` from a reference to an existing `list`.\n\n        This method wraps the provided `list` without copying it, allowing for efficient creation of a `Vec`.\n\n        This is the recommended way to create a `Vec` from foreign functions.\n\n        Warning:\n            Since the `Vec` directly references the original `list`, any modifications made to the `Vec` will also affect the original `list`, and vice versa.\n\n        Args:\n            data (list[V]): The `list` to wrap.\n\n        Returns:\n            Vec[V]: A new Vec instance wrapping the provided `list`.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; original_list = [1, 2, 3]\n        &gt;&gt;&gt; vec = pc.Vec.from_ref(original_list)\n        &gt;&gt;&gt; vec\n        Vec(1, 2, 3)\n        &gt;&gt;&gt; vec[0] = 10\n        &gt;&gt;&gt; original_list\n        [10, 2, 3]\n\n        ```\n        \"\"\"\n        instance: Vec[V] = Vec.__new__(Vec)  # pyright: ignore[reportUnknownVariableType]\n        instance._inner = data\n        return instance\n\n    @overload\n    def __setitem__(self, index: int, value: T) -&gt; None: ...\n    @overload\n    def __setitem__(self, index: slice, value: Iterable[T]) -&gt; None: ...\n    def __setitem__(self, index: int | slice, value: T | Iterable[T]) -&gt; None:\n        return self._inner.__setitem__(index, value)  # type: ignore[arg-type]\n\n    def __delitem__(self, index: int | slice) -&gt; None:\n        del self._inner[index]\n\n    def insert(self, index: int, value: T) -&gt; None:\n        \"\"\"Inserts an element at position index within the vector, shifting all elements after it to the right.\n\n        Args:\n            index (int): Position where to insert the element.\n            value (T): The element to insert.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; vec = pc.Vec(['a', 'b', 'c'])\n        &gt;&gt;&gt; vec.insert(1, 'd')\n        &gt;&gt;&gt; vec\n        Vec('a', 'd', 'b', 'c')\n        &gt;&gt;&gt; vec.insert(4, 'e')\n        &gt;&gt;&gt; vec\n        Vec('a', 'd', 'b', 'c', 'e')\n\n        ```\n        \"\"\"\n        self._inner.insert(index, value)\n\n    @overload\n    def sort[U: SupportsRichComparison[Any]](\n        self: Vec[U], *, key: None = None, reverse: bool = False\n    ) -&gt; Vec[U]: ...\n    @overload\n    def sort(\n        self, *, key: Callable[[T], SupportsRichComparison[Any]], reverse: bool = False\n    ) -&gt; Vec[T]: ...\n    @overload\n    def sort(\n        self,\n        *,\n        key: None = None,\n        reverse: bool = False,\n    ) -&gt; Never: ...\n    def sort(\n        self,\n        *,\n        key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n        reverse: bool = False,\n    ) -&gt; Vec[Any]:\n        \"\"\"Sort the elements of the `Vec` in place.\n\n        Warning:\n            This method modifies the `Vec` in place and returns the same instance for chaining.\n\n        Args:\n            key (Callable[[T], SupportsRichComparison[Any]] | None): Optional function to extract a comparison key from each element.\n            reverse (bool): If True, sort in descending order.\n\n        Returns:\n            Vec[Any]: The sorted `Vec` instance (self).\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; pc.Vec((3, 1, 2)).sort()\n        Vec(1, 2, 3)\n        &gt;&gt;&gt; pc.Iter((3, 1, 2)).map(str).collect(pc.Vec).sort(key=int)\n        Vec('1', '2', '3')\n\n        ```\n        \"\"\"\n        self._inner.sort(key=key, reverse=reverse)  # type: ignore[arg-type]\n        return self\n\n    def extract_if(\n        self, predicate: Callable[[T], bool], start: int = 0, end: int | None = None\n    ) -&gt; Iter[T]:\n        \"\"\"Creates an `Iter` which uses a *predicate* to determine if an element in the `Vec` should be removed.\n\n        If the *predicate* returns `True`, the element is removed from the `Vec` and yielded.\n\n        If the *predicate* returns `False`, the element remains in the `Vec` and will not be yielded.\n\n        You can specify a range for the extraction.\n\n        If the returned ExtractIf is not exhausted, e.g. because it is dropped without iterating or the iteration short-circuits, then the remaining elements will be retained.\n\n        Use retain_mut with a negated predicate if you do not need the returned iterator.\n\n        Using this method is equivalent to the following code:\n        ```python\n            data = pc.Vec([ ... ])\n            for i in range(data.length()):\n                if predicate(data[i]):\n                    val = data.pop(i)\n                    # your code here\n        ```\n        \"\"\"\n\n        def _extract_if_gen() -&gt; Iterator[T]:\n            effective_end = end if end is not None else len(self)\n            i = start\n            pop = self.pop\n            while i &lt; effective_end and i &lt; len(self):\n                if predicate(self[i]):\n                    yield pop(i)\n                    effective_end -= 1\n                else:\n                    i += 1\n\n        return Iter(_extract_if_gen())\n\n    def drain(self, start: int | None = None, end: int | None = None) -&gt; Iter[T]:\n        \"\"\"Removes the subslice indicated by the given *start* and *end* from the `Vec`, returning an `Iterator` over the removed subslice.\n\n        If the `Iterator` is dropped before being fully consumed, it drops the remaining removed elements.\n\n        Note:\n            In CPython, remaining elements are cleaned up when the `Iterator` is garbage collected via `__del__`.\n            However, in interactive environments like doctests, garbage collection may not happen immediately.\n            To guarantee cleanup, fully consume the `Iterator` or explicitly call `.collect()` on it.\n\n        Args:\n            start (int | None): Starting index of the subslice to drain. Defaults to `0` if `None`.\n            end (int | None): Ending index of the subslice to drain. Defaults to `len(self)` if `None`.\n\n        Returns:\n            Iter[T]: An `Iterator` over the drained elements.\n\n        Examples:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; v = pc.Vec([1, 2, 3])\n        &gt;&gt;&gt; u = v.drain(1).collect();\n        &gt;&gt;&gt; v\n        Vec(1)\n        &gt;&gt;&gt; u\n        Seq(2, 3)\n        &gt;&gt;&gt; # A full range clears the vector, like `clear()` does\n        &gt;&gt;&gt; _ = v.drain().collect();\n        &gt;&gt;&gt; v\n        Vec()\n\n        ```\n        Fully consuming the `Iterator` removes all drained elements\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; v = pc.Vec([1, 2, 3])\n        &gt;&gt;&gt; _ = v.drain(0, 3).collect()\n        &gt;&gt;&gt; v\n        Vec()\n\n        ```\n        \"\"\"\n        return Iter(\n            DrainIterator(self, start if start else 0, end if end else len(self))\n        )\n\n    def concat(self, other: list[T] | Self) -&gt; Vec[T]:\n        \"\"\"Concatenate another `Vec` or `list` to **self** and return a new `Vec`.\n\n        Note:\n            This is equivalent to `list_1 + list_2` for standard lists.\n\n        Args:\n            other (list[T] | Self): The other `Vec` to concatenate.\n\n        Returns:\n            Vec[T]: The new `Vec` after concatenation.\n\n        See Also:\n            `Vec.extend()` which modifies **self** in place.\n\n        Example:\n        ```python\n        &gt;&gt;&gt; import pyochain as pc\n        &gt;&gt;&gt; v1 = pc.Vec([1, 2, 3])\n        &gt;&gt;&gt; v2 = [4, 5, 6] # Can also concatenate a standard list\n        &gt;&gt;&gt; v3 = v1.concat(v2)\n        &gt;&gt;&gt; v3\n        Vec(1, 2, 3, 4, 5, 6)\n        &gt;&gt;&gt; v1.clear() # Clean up the original vec\n        &gt;&gt;&gt; v1\n        Vec()\n        &gt;&gt;&gt; # New vec remains unaffected\n        &gt;&gt;&gt; v3\n        Vec(1, 2, 3, 4, 5, 6)\n\n        ```\n        \"\"\"\n        match other:\n            case Vec():\n                data = self._inner + other._inner\n            case list():\n                data = self._inner + other\n        return Vec.from_ref(data)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.concat","level":2,"title":"<code>concat(other)</code>","text":"<p>Concatenate another <code>Vec</code> or <code>list</code> to self and return a new <code>Vec</code>.</p> Note <p>This is equivalent to <code>list_1 + list_2</code> for standard lists.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>list[T] | Self</code> <p>The other <code>Vec</code> to concatenate.</p> required <p>Returns:</p> Type Description <code>Vec[T]</code> <p>Vec[T]: The new <code>Vec</code> after concatenation.</p> See Also <p><code>Vec.extend()</code> which modifies self in place.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; v1 = pc.Vec([1, 2, 3])\n&gt;&gt;&gt; v2 = [4, 5, 6] # Can also concatenate a standard list\n&gt;&gt;&gt; v3 = v1.concat(v2)\n&gt;&gt;&gt; v3\nVec(1, 2, 3, 4, 5, 6)\n&gt;&gt;&gt; v1.clear() # Clean up the original vec\n&gt;&gt;&gt; v1\nVec()\n&gt;&gt;&gt; # New vec remains unaffected\n&gt;&gt;&gt; v3\nVec(1, 2, 3, 4, 5, 6)\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def concat(self, other: list[T] | Self) -&gt; Vec[T]:\n    \"\"\"Concatenate another `Vec` or `list` to **self** and return a new `Vec`.\n\n    Note:\n        This is equivalent to `list_1 + list_2` for standard lists.\n\n    Args:\n        other (list[T] | Self): The other `Vec` to concatenate.\n\n    Returns:\n        Vec[T]: The new `Vec` after concatenation.\n\n    See Also:\n        `Vec.extend()` which modifies **self** in place.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; v1 = pc.Vec([1, 2, 3])\n    &gt;&gt;&gt; v2 = [4, 5, 6] # Can also concatenate a standard list\n    &gt;&gt;&gt; v3 = v1.concat(v2)\n    &gt;&gt;&gt; v3\n    Vec(1, 2, 3, 4, 5, 6)\n    &gt;&gt;&gt; v1.clear() # Clean up the original vec\n    &gt;&gt;&gt; v1\n    Vec()\n    &gt;&gt;&gt; # New vec remains unaffected\n    &gt;&gt;&gt; v3\n    Vec(1, 2, 3, 4, 5, 6)\n\n    ```\n    \"\"\"\n    match other:\n        case Vec():\n            data = self._inner + other._inner\n        case list():\n            data = self._inner + other\n    return Vec.from_ref(data)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.drain","level":2,"title":"<code>drain(start=None, end=None)</code>","text":"<p>Removes the subslice indicated by the given start and end from the <code>Vec</code>, returning an <code>Iterator</code> over the removed subslice.</p> <p>If the <code>Iterator</code> is dropped before being fully consumed, it drops the remaining removed elements.</p> Note <p>In CPython, remaining elements are cleaned up when the <code>Iterator</code> is garbage collected via <code>__del__</code>. However, in interactive environments like doctests, garbage collection may not happen immediately. To guarantee cleanup, fully consume the <code>Iterator</code> or explicitly call <code>.collect()</code> on it.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int | None</code> <p>Starting index of the subslice to drain. Defaults to <code>0</code> if <code>None</code>.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>Ending index of the subslice to drain. Defaults to <code>len(self)</code> if <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Iter[T]</code> <p>Iter[T]: An <code>Iterator</code> over the drained elements.</p> <p>Examples: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; v = pc.Vec([1, 2, 3])\n&gt;&gt;&gt; u = v.drain(1).collect();\n&gt;&gt;&gt; v\nVec(1)\n&gt;&gt;&gt; u\nSeq(2, 3)\n&gt;&gt;&gt; # A full range clears the vector, like `clear()` does\n&gt;&gt;&gt; _ = v.drain().collect();\n&gt;&gt;&gt; v\nVec()\n</code></pre> Fully consuming the <code>Iterator</code> removes all drained elements <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; v = pc.Vec([1, 2, 3])\n&gt;&gt;&gt; _ = v.drain(0, 3).collect()\n&gt;&gt;&gt; v\nVec()\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def drain(self, start: int | None = None, end: int | None = None) -&gt; Iter[T]:\n    \"\"\"Removes the subslice indicated by the given *start* and *end* from the `Vec`, returning an `Iterator` over the removed subslice.\n\n    If the `Iterator` is dropped before being fully consumed, it drops the remaining removed elements.\n\n    Note:\n        In CPython, remaining elements are cleaned up when the `Iterator` is garbage collected via `__del__`.\n        However, in interactive environments like doctests, garbage collection may not happen immediately.\n        To guarantee cleanup, fully consume the `Iterator` or explicitly call `.collect()` on it.\n\n    Args:\n        start (int | None): Starting index of the subslice to drain. Defaults to `0` if `None`.\n        end (int | None): Ending index of the subslice to drain. Defaults to `len(self)` if `None`.\n\n    Returns:\n        Iter[T]: An `Iterator` over the drained elements.\n\n    Examples:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; v = pc.Vec([1, 2, 3])\n    &gt;&gt;&gt; u = v.drain(1).collect();\n    &gt;&gt;&gt; v\n    Vec(1)\n    &gt;&gt;&gt; u\n    Seq(2, 3)\n    &gt;&gt;&gt; # A full range clears the vector, like `clear()` does\n    &gt;&gt;&gt; _ = v.drain().collect();\n    &gt;&gt;&gt; v\n    Vec()\n\n    ```\n    Fully consuming the `Iterator` removes all drained elements\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; v = pc.Vec([1, 2, 3])\n    &gt;&gt;&gt; _ = v.drain(0, 3).collect()\n    &gt;&gt;&gt; v\n    Vec()\n\n    ```\n    \"\"\"\n    return Iter(\n        DrainIterator(self, start if start else 0, end if end else len(self))\n    )\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.extract_if","level":2,"title":"<code>extract_if(predicate, start=0, end=None)</code>","text":"<p>Creates an <code>Iter</code> which uses a predicate to determine if an element in the <code>Vec</code> should be removed.</p> <p>If the predicate returns <code>True</code>, the element is removed from the <code>Vec</code> and yielded.</p> <p>If the predicate returns <code>False</code>, the element remains in the <code>Vec</code> and will not be yielded.</p> <p>You can specify a range for the extraction.</p> <p>If the returned ExtractIf is not exhausted, e.g. because it is dropped without iterating or the iteration short-circuits, then the remaining elements will be retained.</p> <p>Use retain_mut with a negated predicate if you do not need the returned iterator.</p> <p>Using this method is equivalent to the following code: <pre><code>    data = pc.Vec([ ... ])\n    for i in range(data.length()):\n        if predicate(data[i]):\n            val = data.pop(i)\n            # your code here\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def extract_if(\n    self, predicate: Callable[[T], bool], start: int = 0, end: int | None = None\n) -&gt; Iter[T]:\n    \"\"\"Creates an `Iter` which uses a *predicate* to determine if an element in the `Vec` should be removed.\n\n    If the *predicate* returns `True`, the element is removed from the `Vec` and yielded.\n\n    If the *predicate* returns `False`, the element remains in the `Vec` and will not be yielded.\n\n    You can specify a range for the extraction.\n\n    If the returned ExtractIf is not exhausted, e.g. because it is dropped without iterating or the iteration short-circuits, then the remaining elements will be retained.\n\n    Use retain_mut with a negated predicate if you do not need the returned iterator.\n\n    Using this method is equivalent to the following code:\n    ```python\n        data = pc.Vec([ ... ])\n        for i in range(data.length()):\n            if predicate(data[i]):\n                val = data.pop(i)\n                # your code here\n    ```\n    \"\"\"\n\n    def _extract_if_gen() -&gt; Iterator[T]:\n        effective_end = end if end is not None else len(self)\n        i = start\n        pop = self.pop\n        while i &lt; effective_end and i &lt; len(self):\n            if predicate(self[i]):\n                yield pop(i)\n                effective_end -= 1\n            else:\n                i += 1\n\n    return Iter(_extract_if_gen())\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.from_ref","level":2,"title":"<code>from_ref(data)</code>  <code>staticmethod</code>","text":"<p>Create a <code>Vec</code> from a reference to an existing <code>list</code>.</p> <p>This method wraps the provided <code>list</code> without copying it, allowing for efficient creation of a <code>Vec</code>.</p> <p>This is the recommended way to create a <code>Vec</code> from foreign functions.</p> Warning <p>Since the <code>Vec</code> directly references the original <code>list</code>, any modifications made to the <code>Vec</code> will also affect the original <code>list</code>, and vice versa.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[V]</code> <p>The <code>list</code> to wrap.</p> required <p>Returns:</p> Type Description <code>Vec[V]</code> <p>Vec[V]: A new Vec instance wrapping the provided <code>list</code>.</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; original_list = [1, 2, 3]\n&gt;&gt;&gt; vec = pc.Vec.from_ref(original_list)\n&gt;&gt;&gt; vec\nVec(1, 2, 3)\n&gt;&gt;&gt; vec[0] = 10\n&gt;&gt;&gt; original_list\n[10, 2, 3]\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>@staticmethod\ndef from_ref[V](data: list[V]) -&gt; Vec[V]:\n    \"\"\"Create a `Vec` from a reference to an existing `list`.\n\n    This method wraps the provided `list` without copying it, allowing for efficient creation of a `Vec`.\n\n    This is the recommended way to create a `Vec` from foreign functions.\n\n    Warning:\n        Since the `Vec` directly references the original `list`, any modifications made to the `Vec` will also affect the original `list`, and vice versa.\n\n    Args:\n        data (list[V]): The `list` to wrap.\n\n    Returns:\n        Vec[V]: A new Vec instance wrapping the provided `list`.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; original_list = [1, 2, 3]\n    &gt;&gt;&gt; vec = pc.Vec.from_ref(original_list)\n    &gt;&gt;&gt; vec\n    Vec(1, 2, 3)\n    &gt;&gt;&gt; vec[0] = 10\n    &gt;&gt;&gt; original_list\n    [10, 2, 3]\n\n    ```\n    \"\"\"\n    instance: Vec[V] = Vec.__new__(Vec)  # pyright: ignore[reportUnknownVariableType]\n    instance._inner = data\n    return instance\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.insert","level":2,"title":"<code>insert(index, value)</code>","text":"<p>Inserts an element at position index within the vector, shifting all elements after it to the right.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Position where to insert the element.</p> required <code>value</code> <code>T</code> <p>The element to insert.</p> required <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; vec = pc.Vec(['a', 'b', 'c'])\n&gt;&gt;&gt; vec.insert(1, 'd')\n&gt;&gt;&gt; vec\nVec('a', 'd', 'b', 'c')\n&gt;&gt;&gt; vec.insert(4, 'e')\n&gt;&gt;&gt; vec\nVec('a', 'd', 'b', 'c', 'e')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def insert(self, index: int, value: T) -&gt; None:\n    \"\"\"Inserts an element at position index within the vector, shifting all elements after it to the right.\n\n    Args:\n        index (int): Position where to insert the element.\n        value (T): The element to insert.\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; vec = pc.Vec(['a', 'b', 'c'])\n    &gt;&gt;&gt; vec.insert(1, 'd')\n    &gt;&gt;&gt; vec\n    Vec('a', 'd', 'b', 'c')\n    &gt;&gt;&gt; vec.insert(4, 'e')\n    &gt;&gt;&gt; vec\n    Vec('a', 'd', 'b', 'c', 'e')\n\n    ```\n    \"\"\"\n    self._inner.insert(index, value)\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]},{"location":"reference/vec/#pyochain._iter.Vec.sort","level":2,"title":"<code>sort(*, key=None, reverse=False)</code>","text":"<pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Vec[U]\n</code></pre><pre><code>sort(\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]],\n    reverse: bool = False,\n) -&gt; Vec[T]\n</code></pre><pre><code>sort(*, key: None = None, reverse: bool = False) -&gt; Never\n</code></pre> <p>Sort the elements of the <code>Vec</code> in place.</p> Warning <p>This method modifies the <code>Vec</code> in place and returns the same instance for chaining.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Callable[[T], SupportsRichComparison[Any]] | None</code> <p>Optional function to extract a comparison key from each element.</p> <code>None</code> <code>reverse</code> <code>bool</code> <p>If True, sort in descending order.</p> <code>False</code> <p>Returns:</p> Type Description <code>Vec[Any]</code> <p>Vec[Any]: The sorted <code>Vec</code> instance (self).</p> <p>Example: <pre><code>&gt;&gt;&gt; import pyochain as pc\n&gt;&gt;&gt; pc.Vec((3, 1, 2)).sort()\nVec(1, 2, 3)\n&gt;&gt;&gt; pc.Iter((3, 1, 2)).map(str).collect(pc.Vec).sort(key=int)\nVec('1', '2', '3')\n</code></pre></p> Source code in <code>src/pyochain/_iter.py</code> <pre><code>def sort(\n    self,\n    *,\n    key: Callable[[T], SupportsRichComparison[Any]] | None = None,\n    reverse: bool = False,\n) -&gt; Vec[Any]:\n    \"\"\"Sort the elements of the `Vec` in place.\n\n    Warning:\n        This method modifies the `Vec` in place and returns the same instance for chaining.\n\n    Args:\n        key (Callable[[T], SupportsRichComparison[Any]] | None): Optional function to extract a comparison key from each element.\n        reverse (bool): If True, sort in descending order.\n\n    Returns:\n        Vec[Any]: The sorted `Vec` instance (self).\n\n    Example:\n    ```python\n    &gt;&gt;&gt; import pyochain as pc\n    &gt;&gt;&gt; pc.Vec((3, 1, 2)).sort()\n    Vec(1, 2, 3)\n    &gt;&gt;&gt; pc.Iter((3, 1, 2)).map(str).collect(pc.Vec).sort(key=int)\n    Vec('1', '2', '3')\n\n    ```\n    \"\"\"\n    self._inner.sort(key=key, reverse=reverse)  # type: ignore[arg-type]\n    return self\n</code></pre>","path":["API Reference","Collections","Vec"],"tags":[]}]}